<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Welcome">
    <meta name="description" content="1480. 一维数组的动态和给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
请返回 nums 的动态和。
class Solution &amp;#123;
   ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Welcome</title>
    <link rel="icon" type="image/png" href="/1.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.0.0"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size: 100% 100%;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Welcome</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Galleries</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Welcome</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>Galleries</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/SmileSlight/SmileSlight.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Look Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/SmileSlight/SmileSlight.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Look Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 400px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: scroll;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-07-31
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h4 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480. 一维数组的动态和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/running-sum-of-1d-array/">1480. 一维数组的动态和</a></h4><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int[] runningSum(int[] nums) &#123;
        int[] dp &#x3D; new int[nums.length];
        dp[0] &#x3D; nums[0];
        for(int i &#x3D; 1 ; i &lt; nums.length ; i++)&#123;
            dp[i] &#x3D; nums[i] + dp[i-1];
        &#125;
        return dp;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-pivot-index/">724. 寻找数组的中心下标</a></h4><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p>
<p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>
<p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int pivotIndex(int[] nums) &#123;
        int[] dp &#x3D; new int[nums.length];
        dp[0] &#x3D; 0;
        int total &#x3D; Arrays.stream(nums).reduce(0, Integer::sum);
        &#x2F;&#x2F;int total &#x3D; Arrays.stream(nums).sum();
        if( total - nums[0] &#x3D;&#x3D; 0 ) return 0;
        for(int i &#x3D; 1 ; i &lt; nums.length ; i++)&#123;
            dp[i] &#x3D;  dp [i-1] + nums[i-1];
            if(2 * dp[i] &#x3D;&#x3D; total - nums[i]) return i;
        &#125;
        return -1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/isomorphic-strings/">205. 同构字符串</a></h4><p>给定两个字符串 s 和 t ，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public boolean isIsomorphic(String s, String t) &#123;
        Map&lt;Character,Character&gt; st &#x3D; new HashMap&lt;&gt;();
        Map&lt;Character,Character&gt; ts &#x3D; new HashMap&lt;&gt;();
        for(int i &#x3D; 0 ; i &lt; s.length() ; i++)&#123;
            char a &#x3D; s.charAt(i);
            char b &#x3D; t.charAt(i);
            &#x2F;&#x2F; 对于已有映射 a -&gt; s2t[a]，若和当前字符映射 a -&gt; b 不匹配，
            &#x2F;&#x2F; 说明有一对多的映射关系，则返回 false ；
            &#x2F;&#x2F; 对于映射 b -&gt; a 也同理
            if( (st.containsKey(a) &amp;&amp; st.get(a) !&#x3D; b ) || (ts.containsKey(b) &amp;&amp; ts.get(b) !&#x3D; a) ) return false;
            st.put(a,b);
            ts.put(b,a);
        &#125;
        return true;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h4><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public boolean isSubsequence(String s, String t) &#123;
        if(s.length() &#x3D;&#x3D; 0) return true;
        if(s.length() &gt; t.length()) return false;
        for(int i &#x3D; 0, j &#x3D; 0 ; i &lt; t.length() ; i++)&#123;
            if( s.charAt(j) &#x3D;&#x3D; t.charAt(i)) j++;
            if( j &#x3D;&#x3D; s.length()) return true;
        &#125;
        return false;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode slow &#x3D; head, fast &#x3D; head;
        while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123;
            slow &#x3D; slow.next;
            fast &#x3D; fast.next.next;
        &#125;
        return slow;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;遍历字典法
&#x2F;**
 * Definition for singly-linked list.
 * class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123;
 *         val &#x3D; x;
 *         next &#x3D; null;
 *     &#125;
 * &#125;
 *&#x2F;
public class Solution &#123;
    public ListNode detectCycle(ListNode head) &#123;
        Set&lt;ListNode&gt; dic &#x3D; new HashSet&lt;&gt;();
        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return null;
        while(!dic.contains(head))&#123;
            dic.add(head);
            head &#x3D; head.next;
            if(head &#x3D;&#x3D; null) return null;
        &#125;
        return head;
    &#125;
&#125;

&#x2F;&#x2F;快慢指针法
public class Solution &#123;
    public ListNode detectCycle(ListNode head) &#123;
        ListNode fast &#x3D; head, slow &#x3D; head;
        while (true) &#123;
            if (fast &#x3D;&#x3D; null || fast.next &#x3D;&#x3D; null) return null;
            fast &#x3D; fast.next.next;
            slow &#x3D; slow.next;
            if (fast &#x3D;&#x3D; slow) break;
        &#125;
        fast &#x3D; head;
        while (slow !&#x3D; fast) &#123;
            slow &#x3D; slow.next;
            fast &#x3D; fast.next;
        &#125;
        return fast;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Solution &#123;
    public int maxProfit(int prices[]) &#123;
        int minprice &#x3D; Integer.MAX_VALUE;
        int maxprofit &#x3D; 0;
        for (int i &#x3D; 0; i &lt; prices.length; i++) &#123;
            if (prices[i] &lt; minprice) &#123;
                minprice &#x3D; prices[i];
            &#125; else if (prices[i] - minprice &gt; maxprofit) &#123;
                maxprofit &#x3D; prices[i] - minprice;
            &#125;
        &#125;
        return maxprofit;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindrome/">409. 最长回文串</a></h4><p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。</p>
<p>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int longestPalindrome(String s) &#123;
        &#x2F;&#x2F; 统计各字符数量
        HashMap&lt;Character, Integer&gt; counter &#x3D; new HashMap&lt;&gt;();
        for (int i &#x3D; 0; i &lt; s.length(); i++)
            counter.merge(s.charAt(i), 1, (a, b) -&gt; a + b);
        &#x2F;&#x2F; 统计构造回文串的最大长度
        int res &#x3D; 0, odd &#x3D; 0;  
        for (Map.Entry&lt;Character, Integer&gt; kv : counter.entrySet()) &#123;
            &#x2F;&#x2F; 将当前字符出现次数向下取偶数，并计入 res
            int count &#x3D; kv.getValue();
            int rem &#x3D; count % 2;
            res +&#x3D; count - rem;
            &#x2F;&#x2F; 若当前字符出现次数为奇数，则将 odd 置 1
            if (rem &#x3D;&#x3D; 1) odd &#x3D; 1;
        &#125;
        return res + odd;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="589-N-叉树的前序遍历"><a href="#589-N-叉树的前序遍历" class="headerlink" title="589. N 叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></h4><p>给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。</p>
<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;递归
&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
    public int val;
    public List&lt;Node&gt; children;

    public Node() &#123;&#125;

    public Node(int _val) &#123;
        val &#x3D; _val;
    &#125;

    public Node(int _val, List&lt;Node&gt; _children) &#123;
        val &#x3D; _val;
        children &#x3D; _children;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
    List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();
    public List&lt;Integer&gt; preorder(Node root) &#123;
        dfs(root);
        return ans;
    &#125;
    void dfs(Node root) &#123;
        if (root &#x3D;&#x3D; null) return ;
        ans.add(root.val);
        for (Node node : root.children) dfs(node);
    &#125;
&#125;


&#x2F;&#x2F;迭代法
class Solution &#123;
    public List&lt;Integer&gt; preorder(Node root) &#123;
        if(root &#x3D;&#x3D; null)
            return new ArrayList&lt;&gt;();
        List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();
        Deque&lt;Node&gt; deque &#x3D; new ArrayDeque&lt;&gt;();
        deque.addLast(root);
        while(!deque.isEmpty()) &#123;
            Node node &#x3D; deque.pollLast();
            if(node !&#x3D; null) &#123;
                ans.add(node.val);
                for(int i &#x3D; node.children.size() - 1; i &gt;&#x3D; 0; i--)
                    deque.addLast(node.children.get(i));
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();
        LinkedList&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;&gt;();
        if(root !&#x3D; null) que.addLast(root);
        while(!que.isEmpty())&#123;
            List&lt;Integer&gt; level &#x3D; new ArrayList&lt;&gt;();
            int n &#x3D; que.size();
            for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i++)&#123;
                TreeNode node &#x3D; que.removeFirst();
                level.add(node.val);
                if(node.left !&#x3D; null) que.addLast(node.left);
                if(node.right !&#x3D; null) que.addLast(node.right);
            &#125;
            res.add(level);
        &#125;
        return res;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int search(int[] nums, int target) &#123;
        int n &#x3D; nums.length;
        int l &#x3D; 0;
        int r &#x3D; n-1;
        while(l &lt;&#x3D; r)&#123;
            int m &#x3D; ( l + r ) &#x2F; 2;
            if(nums[m] &gt; target) r &#x3D; m - 1;
            else if(nums[m] &lt; target) l &#x3D; m + 1;
            else return m;
        &#125;
        return -1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a></h4><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;查找左值模板
public class Solution extends VersionControl &#123;
    public int firstBadVersion(int n) &#123;
        int l &#x3D; 1;
        int r &#x3D; n;
        while(l &lt;&#x3D; r)&#123;
            int m &#x3D; l + (r - l)&#x2F;2;
            if(isBadVersion(m)) r &#x3D; m -1;
            else l &#x3D; m + 1;
        &#125;
        return l;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val = val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     &#125;
 * &#125;
 */</span>

<span class="token comment">//递归法</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">return</span> <span class="token function">rescur</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token class-name">Long</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">,</span><span class="token class-name">Long</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">boolean</span> <span class="token function">rescur</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">,</span><span class="token keyword">long</span> min<span class="token punctuation">,</span><span class="token keyword">long</span> max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> min <span class="token operator">||</span> node<span class="token punctuation">.</span>val <span class="token operator">>=</span> max<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">rescur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>min<span class="token punctuation">,</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rescur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node<span class="token punctuation">.</span>val<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">//中序遍历</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> pre <span class="token operator">=</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> pre<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        pre <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;

&#x2F;&#x2F;二叉搜索树特性
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        &#x2F;&#x2F;如果小于等于0，说明p和q位于root的两侧，直接返回即可
        if (((long)(root.val - p.val) * (root.val - q.val)) &lt;&#x3D; 0)
            return root;
        &#x2F;&#x2F;否则，p和q位于root的同一侧，就继续往下找
        return lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);
    &#125;
&#125;

&#x2F;&#x2F;无特性二叉树
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode cur, TreeNode p, TreeNode q) &#123;
        if (cur &#x3D;&#x3D; null || cur &#x3D;&#x3D; p || cur &#x3D;&#x3D; q)
            return cur;
        TreeNode left &#x3D; lowestCommonAncestor(cur.left, p, q);
        TreeNode right &#x3D; lowestCommonAncestor(cur.right, p, q);
        &#x2F;&#x2F;如果left为空，说明这两个节点在cur结点的右子树上，我们只需要返回右子树查找的结果即可
        if (left &#x3D;&#x3D; null)
            return right;
        &#x2F;&#x2F;同上
        if (right &#x3D;&#x3D; null)
            return left;
        &#x2F;&#x2F;如果left和right都不为空，说明这两个节点一个在cur的左子树上一个在cur的右子树上，
        &#x2F;&#x2F;我们只需要返回cur结点即可。
        return cur;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></h4><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。</p>
<p>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。</p>
<p>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。</p>
<p>最后返回 经过上色渲染后的图像 。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int[][] floodFill(int[][] image, int sr, int sc, int color) &#123;
        int n &#x3D; image.length;
        if(n &#x3D;&#x3D; 0) return image;
        int m &#x3D; image[0].length;
        if(image[sr][sc] &#x3D;&#x3D; color) return image;
        return  colorfill(image,sr,sc,color,image[sr][sc]);
    &#125;
    int[][] colorfill(int[][] image,int x,int y,int newcolor,int oldcolor)&#123;
        int n &#x3D; image.length;
        int m &#x3D; image[0].length;
        if( x &gt;&#x3D; n || y &gt;&#x3D; m || x &lt; 0 || y &lt; 0 || image[x][y] !&#x3D; oldcolor || image[x][y] &#x3D;&#x3D; newcolor) return image;
        int temp &#x3D; image[x][y];
        image[x][y] &#x3D; newcolor;
        colorfill(image,x+1,y,newcolor,temp);
        colorfill(image,x-1,y,newcolor,temp);
        colorfill(image,x,y+1,newcolor,temp);
        colorfill(image,x,y-1,newcolor,temp);
        return image;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;DFS
class Solution &#123;
    public int numIslands(char[][] grid) &#123;
        int count &#x3D; 0;
        for(int i &#x3D; 0; i &lt; grid.length; i++) &#123;
            for(int j &#x3D; 0; j &lt; grid[0].length; j++) &#123;
                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;
                    dfs(grid, i, j);
                    count++;
                &#125;
            &#125;
        &#125;
        return count;
    &#125;
    private void dfs(char[][] grid, int i, int j)&#123;
        if(i &lt; 0 || j &lt; 0 || i &gt;&#x3D; grid.length || j &gt;&#x3D; grid[0].length || grid[i][j] &#x3D;&#x3D; &#39;0&#39;) return;
        grid[i][j] &#x3D; &#39;0&#39;;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    &#125;
&#125;

&#x2F;&#x2F;BFS
class Solution &#123;
    public int numIslands(char[][] grid) &#123;
        int count &#x3D; 0;
        for(int i &#x3D; 0; i &lt; grid.length; i++) &#123;
            for(int j &#x3D; 0; j &lt; grid[0].length; j++) &#123;
                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;
                    bfs(grid, i, j);
                    count++;
                &#125;
            &#125;
        &#125;
        return count;
    &#125;
    private void bfs(char[][] grid, int i, int j)&#123;
        Queue&lt;int[]&gt; list &#x3D; new LinkedList&lt;&gt;();
        list.add(new int[] &#123; i, j &#125;);
        while(!list.isEmpty())&#123;
            int[] cur &#x3D; list.remove();
            i &#x3D; cur[0]; j &#x3D; cur[1];
            if(0 &lt;&#x3D; i &amp;&amp; i &lt; grid.length &amp;&amp; 0 &lt;&#x3D; j &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;
                grid[i][j] &#x3D; &#39;0&#39;;
                list.add(new int[] &#123; i + 1, j &#125;);
                list.add(new int[] &#123; i - 1, j &#125;);
                list.add(new int[] &#123; i, j + 1 &#125;);
                list.add(new int[] &#123; i, j - 1 &#125;);
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;开dp数组
class Solution &#123;
    public int maxSubArray(int[] nums) &#123;
        int n &#x3D; nums.length;
        if( n &#x3D;&#x3D; 0) return 0;
        int[] dp &#x3D; new int[nums.length];
        dp[0] &#x3D; nums[0];
        int max &#x3D; dp[0];
        for(int i &#x3D; 1 ; i &lt; n ; i++)&#123;
            dp[i] &#x3D; Math.max(nums[i]+dp[i-1],nums[i]);
            max &#x3D; Math.max(dp[i],max);
        &#125;
        return max;
    &#125;
&#125;

&#x2F;&#x2F;原本数组上
class Solution &#123;
    public int maxSubArray(int[] nums) &#123;
        int res &#x3D; nums[0];
        for(int i &#x3D; 1; i &lt; nums.length; i++) &#123;
            nums[i] &#x3D; Math.max( nums[i] + nums[i - 1], nums[i]);
            res &#x3D; Math.max(res, nums[i]);
        &#125;
        return res;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<pre class="line-numbers language-jAVA" data-language="jAVA"><code class="language-jAVA">class Solution &#123;
    public int maxValue(int[][] grid) &#123;
        int m &#x3D; grid.length, n &#x3D; grid[0].length;
        for(int i &#x3D; 0; i &lt; m; i++) &#123;
            for(int j &#x3D; 0; j &lt; n; j++) &#123;
                if(i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0) continue;
                if(i &#x3D;&#x3D; 0) grid[i][j] +&#x3D; grid[i][j - 1] ;
                else if(j &#x3D;&#x3D; 0) grid[i][j] +&#x3D; grid[i - 1][j];
                else grid[i][j] +&#x3D; Math.max(grid[i][j - 1], grid[i - 1][j]);
            &#125;
        &#125;
        return grid[m - 1][n - 1];
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int minCostClimbingStairs(int[] cost) &#123;
        for (int i &#x3D; 2; i &lt; cost.length; i++) &#123;
            cost[i] &#x3D; Math.min(cost[i - 2], cost[i - 1]) + cost[i];
        &#125;
        return Math.min(cost[cost.length - 2], cost[cost.length - 1]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int uniquePaths(int m, int n) &#123;
        if(m &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 0) return 0;
        if(m &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 1) return 1;
        int[][] dp &#x3D; new int[m][n];
        dp[0][0] &#x3D; 1;
        for(int i &#x3D; 0 ; i &lt; m ; i++)&#123;
            for(int j &#x3D; 0 ; j &lt; n ; j++)&#123;
                if(i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) dp[i][j] &#x3D; 1;
                else&#123;
                    dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1];
                &#125;
            &#125;
        &#125;
        return dp[m-1][n-1];
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;
        &#x2F;&#x2F; 用于返回字母异位词的起始索引
        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();
        &#x2F;&#x2F; 用 map 存储目标值中各个单词出现的次数
        HashMap&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();
        for (Character c : p.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1);
        &#x2F;&#x2F; 用另外一个 map 存储滑动窗口中有效字符出现的次数
        HashMap&lt;Character, Integer&gt; window &#x3D; new HashMap&lt;&gt;();
        int left &#x3D; 0; &#x2F;&#x2F; 左指针
        int right &#x3D; 0; &#x2F;&#x2F; 右指针
        int valid &#x3D; p.length(); &#x2F;&#x2F; 只有当 valid &#x3D;&#x3D; 0 时，才说明 window 中包含了目标子串
        while (right &lt; s.length()) &#123;
            &#x2F;&#x2F; 如果目标子串中包含了该字符，才存入 window 中
            if (map.containsKey(s.charAt(right))) &#123;
                window.put(s.charAt(right), window.getOrDefault(s.charAt(right), 0) + 1);
                &#x2F;&#x2F; 只有当 window 中该有效字符数量不大于map中该字符数量，才能算一次有效包含
                if (window.get(s.charAt(right)) &lt;&#x3D; map.get(s.charAt(right))) &#123;
                    valid--;
                &#125;
            &#125;
            &#x2F;&#x2F; 如果 window 符合要求，即两个 map 存储的有效字符相同，就可以移动左指针了
            &#x2F;&#x2F; 但是只有二个map存储的数据完全相同，才可以记录当前的起始索引，也就是left指针所在位置
            while (valid &#x3D;&#x3D; 0) &#123;
                if (right - left + 1 &#x3D;&#x3D; p.length()) res.add(left);
                &#x2F;&#x2F; 如果左指针指的是有效字符,需要更改 window 中的 key 对应的 value
                &#x2F;&#x2F; 如果 有效字符对应的数量比目标子串少，说明无法匹配了
                if (map.containsKey(s.charAt(left))) &#123;
                    window.put(s.charAt(left), window.get(s.charAt(left)) - 1);
                    if (window.get(s.charAt(left)) &lt; map.get(s.charAt(left))) &#123;
                        valid++;
                    &#125;
                &#125;
                left++;
            &#125;
            right++;
        &#125;
        return res;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h4><p>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。</p>
<p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int characterReplacement(String s, int k) &#123;
        if (s &#x3D;&#x3D; null) &#123;
            return 0;
        &#125;
        int[] map &#x3D; new int[26];
        char[] chars &#x3D; s.toCharArray();
        int left &#x3D; 0;
        int right &#x3D; 0;
        int historyCharMax &#x3D; 0;
        for (right &#x3D; 0; right &lt; chars.length; right++) &#123;
            int index &#x3D; chars[right] - &#39;A&#39;;
            map[index]++;
            historyCharMax &#x3D; Math.max(historyCharMax, map[index]);
            if (right - left + 1 &gt; historyCharMax + k) &#123;
                map[chars[left] - &#39;A&#39;]--;
                left++;
            &#125;
        &#125;
        return chars.length - left;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();
        for(int i &#x3D; 0; i&lt; nums.length; i++) &#123;
            if(map.containsKey(target - nums[i])) &#123;
                return new int[] &#123;map.get(target-nums[i]),i&#125;;
            &#125;
            map.put(nums[i], i);
        &#125;
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bulls-and-cows/">299. 猜数字游戏</a></h4><p>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：</p>
<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>
<p>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），<br>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。<br>给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。</p>
<p>提示的格式为 “xAyB” ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。</p>
<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public String getHint(String secret, String guess) &#123;
        int[] ab &#x3D; new int[2];
        HashMap&lt;Character,Integer&gt; dic &#x3D; new HashMap&lt;&gt;();
        for(char x : secret.toCharArray())&#123;
            if(dic.containsKey(x)) dic.replace(x,dic.get(x)+1);
            else dic.put(x,1);
        &#125;
        int i &#x3D; 0;
        for(char x : guess.toCharArray())&#123;
            if(x &#x3D;&#x3D; secret.charAt(i))&#123;
                ab[0]++;
                &#x2F;&#x2F;System.out.printf(&quot;ab[0]:%d &quot;,ab[0]);
                if(dic.containsKey(x)) dic.replace(x,dic.get(x)-1);
            &#125;
            i++;
        &#125;
        i &#x3D; 0;
        for(char x : guess.toCharArray())&#123;
            if(x !&#x3D; secret.charAt(i) &amp;&amp; dic.containsKey(x) &amp;&amp; dic.get(x) &gt; 0)&#123;
                dic.replace(x,dic.get(x)-1);
                ab[1]++;
                &#x2F;&#x2F;System.out.printf(&quot;ab[1]:%d &quot;,ab[1]);
            &#125;
            i++; 
        &#125;
        return ab[0] + &quot;A&quot; + ab[1] + &quot;B&quot;;
    &#125;
&#125;

&#x2F;&#x2F;better
class Solution &#123;
    public String getHint(String secret, String guess) &#123;
        int n &#x3D; secret.length();
        int a &#x3D; 0, b &#x3D; 0;
        int[] cnt1 &#x3D; new int[10], cnt2 &#x3D; new int[10];
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int c1 &#x3D; secret.charAt(i) - &#39;0&#39;, c2&#x3D; guess.charAt(i) - &#39;0&#39;;
            if (c1 &#x3D;&#x3D; c2) &#123;
                a++;
            &#125; else &#123;
                cnt1[c1]++;
                cnt2[c2]++;
            &#125;
        &#125;
        for (int i &#x3D; 0; i &lt; 10; i++) b +&#x3D; Math.min(cnt1[i], cnt2[i]);
        return a + &quot;A&quot; + b + &quot;B&quot;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h4><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public boolean backspaceCompare(String S, String T) &#123;
        int i &#x3D; S.length() - 1, j &#x3D; T.length() - 1;
        int skipS &#x3D; 0, skipT &#x3D; 0;

        while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) &#123;
            while (i &gt;&#x3D; 0) &#123;
                if (S.charAt(i) &#x3D;&#x3D; &#39;#&#39;) &#123;
                    skipS++;
                    i--;
                &#125; else if (skipS &gt; 0) &#123;
                    skipS--;
                    i--;
                &#125; else &#123;
                    break;
                &#125;
            &#125;
            while (j &gt;&#x3D; 0) &#123;
                if (T.charAt(j) &#x3D;&#x3D; &#39;#&#39;) &#123;
                    skipT++;
                    j--;
                &#125; else if (skipT &gt; 0) &#123;
                    skipT--;
                    j--;
                &#125; else &#123;
                    break;
                &#125;
            &#125;
            if (i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0) &#123;
                if (S.charAt(i) !&#x3D; T.charAt(j)) &#123;
                    return false;
                &#125;
            &#125; else &#123;
                if (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) &#123;
                    return false;
                &#125;
            &#125;
            i--;
            j--;
        &#125;
        return true;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;栈
class Solution &#123;
    public String decodeString(String s) &#123;
        StringBuilder res &#x3D; new StringBuilder();
        int multi &#x3D; 0;
        LinkedList&lt;Integer&gt; stack_multi &#x3D; new LinkedList&lt;&gt;();
        LinkedList&lt;String&gt; stack_res &#x3D; new LinkedList&lt;&gt;();
        for(Character c : s.toCharArray()) &#123;
            if(c &#x3D;&#x3D; &#39;[&#39;) &#123;
                stack_multi.addLast(multi);
                stack_res.addLast(res.toString());
                multi &#x3D; 0;
                res &#x3D; new StringBuilder();
            &#125;
            else if(c &#x3D;&#x3D; &#39;]&#39;) &#123;
                StringBuilder tmp &#x3D; new StringBuilder();
                int cur_multi &#x3D; stack_multi.removeLast();
                for(int i &#x3D; 0; i &lt; cur_multi; i++) tmp.append(res);
                res &#x3D; new StringBuilder(stack_res.removeLast() + tmp);
            &#125;
            else if(c &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;) multi &#x3D; multi * 10 + Integer.parseInt(c + &quot;&quot;);
            else res.append(c);
        &#125;
        return res.toString();
    &#125;
&#125;

&#x2F;&#x2F;递归
class Solution &#123;
    public String decodeString(String s) &#123;
        return dfs(s, 0)[0];
    &#125;
    private String[] dfs(String s, int i) &#123;
        StringBuilder res &#x3D; new StringBuilder();
        int multi &#x3D; 0;
        while(i &lt; s.length()) &#123;
            if(s.charAt(i) &gt;&#x3D; &#39;0&#39; &amp;&amp; s.charAt(i) &lt;&#x3D; &#39;9&#39;) 
                multi &#x3D; multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); 
            else if(s.charAt(i) &#x3D;&#x3D; &#39;[&#39;) &#123;
                String[] tmp &#x3D; dfs(s, i + 1);
                i &#x3D; Integer.parseInt(tmp[0]);
                while(multi &gt; 0) &#123;
                    res.append(tmp[1]);
                    multi--;
                &#125;
            &#125;
            else if(s.charAt(i) &#x3D;&#x3D; &#39;]&#39;) 
                return new String[] &#123; String.valueOf(i), res.toString() &#125;;
            else 
                res.append(String.valueOf(s.charAt(i)));
            i++;
        &#125;
        return new String[] &#123; res.toString() &#125;;
    &#125; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前K个高频单词</a></h4><p>给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Solution &#123;

    public List&lt;String&gt; topKFrequent(String[] words, int k) &#123;
        &#x2F;&#x2F; 1.初始化 哈希表 key -&gt; 字符串 value -&gt; 出现的次数。
        Map&lt;String, Integer&gt; count &#x3D; new HashMap&lt;&gt;();
        for (String word : words) &#123;
            count.put(word, count.getOrDefault(word, 0) + 1);
        &#125;
        &#x2F;&#x2F; 2.用 list 存储字符 key 然后自定义 Comparator 比较器对 value 进行排序。
        List&lt;String&gt; candidates &#x3D; new ArrayList&lt;&gt;(count.keySet());
        &#x2F;&#x2F; 此处为使用 lambda 写法
        candidates.sort((a, b) -&gt; &#123;
            &#x2F;&#x2F; 字符串频率相等按照字典序比较使得大的在堆顶,Java 可以直接使用 compareTo 方法即可。
            if (count.get(a).equals(count.get(b))) &#123;
                return a.compareTo(b);
            &#125; else &#123;
                &#x2F;&#x2F; 字符串频率不等则按照频率排列。
                return count.get(b) - count.get(a);
            &#125;
        &#125;);
        &#x2F;&#x2F; 3.截取前 K 大个高频单词返回结果。
        return candidates.subList(0, k);        
    &#125;    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Smile Slight</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://smileslight.github.io/2023/07/31/20221019-LC75/">https://smileslight.github.io/2023/07/31/20221019-LC75/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Smile Slight</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/07/31/20221019-Offer/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-07-31
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Smile Slight
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/07/31/20221019-Daily/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-07-31
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Smile Slight
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="632021463"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">Smile Slight</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/SmileSlight" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1585118039@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1585118039" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1585118039" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
