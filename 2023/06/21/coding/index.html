<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="coding, Welcome">
    <meta name="description" content="算法体系刷题归纳">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>coding | Welcome</title>
    <link rel="icon" type="image/png" href="/1.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.0.0"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size: 100% 100%;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Welcome</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Galleries</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Welcome</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>Galleries</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/SmileSlight/SmileSlight.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Look Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/SmileSlight/SmileSlight.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Look Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">coding</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 400px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: scroll;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C/">
                                <span class="chip bg-color">C++</span>
                            </a>
                        
                            <a href="/tags/%E5%88%B7%E9%A2%98/">
                                <span class="chip bg-color">刷题</span>
                            </a>
                        
                            <a href="/tags/OJ/">
                                <span class="chip bg-color">OJ</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-06-21
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="【体系路线】"><a href="#【体系路线】" class="headerlink" title="【体系路线】"></a>【体系路线】</h2><p><img src="https://img-blog.csdnimg.cn/0ef9deb774ee4800b3f8ed01715a974e.png" alt="img"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。                                                                </p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;[left,right] 
class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left &#x3D; 0;
        int right &#x3D; nums.size()-1;
        while(left &lt;&#x3D; right )&#123;
            int middle &#x3D; left + ((right - left) &#x2F; 2);
            if(nums[middle] &gt; target) right &#x3D; middle - 1;
            else if(nums[middle] &lt; target) left &#x3D; middle + 1;
            else return middle;
        &#125;
        return -1;
    &#125;
&#125;;

&#x2F;&#x2F;[left,right)
class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left &#x3D; 0;
        int right &#x3D; nums.size();
        while(left &lt; right )&#123;
            int middle &#x3D; left + ((right - left) &#x2F; 2);  &#x2F;&#x2F; int middle &#x3D; left + ((right - left) &gt;&gt; 1)
            if(nums[middle] &gt; target) right &#x3D; middle;
            else if(nums[middle] &lt; target) left &#x3D; middle + 1;
            else return middle;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h4><blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
        int l &#x3D; 0;
        int r &#x3D; nums.size() - 1;
        while( l &lt;&#x3D; r)&#123;
            int m &#x3D; l + ((r - l) &gt;&gt; 1);
            if(nums[m] &gt; target) r &#x3D; m - 1;
            else if(nums[m] &lt; target) l &#x3D; m + 1;
            else return m;
        &#125;
        return l;
    &#125;
&#125;;

class Solution &#123;
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
        int l &#x3D; 0;
        int r &#x3D; nums.size();
        while( l &lt; r)&#123;
            int m &#x3D; l + ((r - l) &gt;&gt; 1);
            if(nums[m] &gt; target) r &#x3D; m;
            else if(nums[m] &lt; target) l &#x3D; m + 1;
            else return m;
        &#125;
        return l;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><blockquote>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        int leftBorder &#x3D; getLeftBorder(nums, target);
        int rightBorder &#x3D; getRightBorder(nums, target);
        &#x2F;&#x2F; 情况一
        if (leftBorder &#x3D;&#x3D; -2 || rightBorder &#x3D;&#x3D; -2) return &#123;-1, -1&#125;;
        &#x2F;&#x2F; 情况三
        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;
        &#x2F;&#x2F; 情况二
        return &#123;-1, -1&#125;;
    &#125;
private:
     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left &#x3D; 0;
        int right &#x3D; nums.size() - 1;
        int rightBorder &#x3D; -2; &#x2F;&#x2F; 记录一下rightBorder没有被赋值的情况
        while (left &lt;&#x3D; right) &#123;
            int middle &#x3D; left + ((right - left) &#x2F; 2);
            if (nums[middle] &gt; target) &#123;
                right &#x3D; middle - 1;
            &#125; else &#123; &#x2F;&#x2F; 寻找右边界，nums[middle] &#x3D;&#x3D; target的时候更新left
                left &#x3D; middle + 1;
                rightBorder &#x3D; left;
            &#125;
        &#125;
        return rightBorder;
    &#125;
    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left &#x3D; 0;
        int right &#x3D; nums.size() - 1;
        int leftBorder &#x3D; -2; &#x2F;&#x2F; 记录一下leftBorder没有被赋值的情况
        while (left &lt;&#x3D; right) &#123;
            int middle &#x3D; left + ((right - left) &#x2F; 2);
            if (nums[middle] &gt;&#x3D; target) &#123; &#x2F;&#x2F; 寻找左边界，nums[middle] &#x3D;&#x3D; target的时候更新right
                right &#x3D; middle - 1;
                leftBorder &#x3D; right;
            &#125; else &#123;
                left &#x3D; middle + 1;
            &#125;
        &#125;
        return leftBorder;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h4><blockquote>
<p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 牛顿迭代法
class Solution &#123;
public:
    int mySqrt(int x) &#123;
        long long a &#x3D; x;
        while ( a * a &gt; x) a &#x3D; (a + x &#x2F; a ) &#x2F; 2;
        return (int)a;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a></h4><blockquote>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;原理: (n + 1)^2 - n^2 &#x3D; 2n + 1
class Solution &#123;
public:
    bool isPerfectSquare(int num) 
    &#123;
        int num1 &#x3D; 1;
        while(num &gt; 0) 
        &#123;
            num -&#x3D; num1;
            num1 +&#x3D; 2;
        &#125;
        return num &#x3D;&#x3D; 0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;new
class Solution &#123;
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
        int slowIndex &#x3D; 0; int fastIndex &#x3D; 0;
        while(fastIndex &lt; nums.size())&#123;
            if (val !&#x3D; nums[fastIndex]) nums[slowIndex++] &#x3D; nums[fastIndex++];
            else fastIndex++;
        &#125;
        return slowIndex;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><blockquote>
<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;
        if(nums.size() &#x3D;&#x3D; 0) return 0;
        int p &#x3D; 0;
        int q &#x3D; 1;
        while( q &lt; nums.size())&#123;
            if(nums[p] !&#x3D; nums[q])&#123;
                if(q - p &gt; 1)&#123;
                    nums[p + 1] &#x3D; nums[q];
                &#125;
                p++;
            &#125;
            q++;
        &#125;
        return p + 1 ;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><blockquote>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;
        int k &#x3D; A.size() - 1;
        vector&lt;int&gt; result(A.size(), 0);
        for (int i &#x3D; 0, j &#x3D; A.size() - 1; i &lt;&#x3D; j;) &#123; &#x2F;&#x2F; 注意这里要i &lt;&#x3D; j，因为最后要处理两个元素
            if (A[i] * A[i] &lt; A[j] * A[j])  &#123;
                result[k--] &#x3D; A[j] * A[j];
                j--;
            &#125;
            else &#123;
                result[k--] &#x3D; A[i] * A[i];
                i++;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;
        int result &#x3D; INT32_MAX;
        int sum &#x3D; 0; &#x2F;&#x2F; 滑动窗口数值之和
        int i &#x3D; 0; &#x2F;&#x2F; 滑动窗口起始位置
        int subLength &#x3D; 0; &#x2F;&#x2F; 滑动窗口的长度
        for (int j &#x3D; 0; j &lt; nums.size(); j++) &#123;
            sum +&#x3D; nums[j];
            &#x2F;&#x2F; 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum &gt;&#x3D; s) &#123;
                subLength &#x3D; (j - i + 1); &#x2F;&#x2F; 取子序列的长度
                result &#x3D; result &lt; subLength ? result : subLength;
                sum -&#x3D; nums[i++]; &#x2F;&#x2F; 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            &#125;
        &#125;
        &#x2F;&#x2F; 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result &#x3D;&#x3D; INT32_MAX ? 0 : result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h4><blockquote>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;
        int ans &#x3D; 0;
        int tot &#x3D; 0; &#x2F;&#x2F;种类
        int i &#x3D; 0; &#x2F;&#x2F;滑动窗口左端
        vector&lt;int&gt; cnts(fruits.size() + 1); &#x2F;&#x2F;
        for(int j &#x3D; 0; j &lt; fruits.size() ; j++)&#123;
            if(++cnts[fruits[j]] &#x3D;&#x3D; 1) tot++;
            while(tot &gt; 2) &#123;
                if( --cnts[fruits[i++]] &#x3D;&#x3D; 0) tot--;
            &#125;
            ans &#x3D; ans &gt; (j - i + 1) ? ans : (j - i + 1);
        &#125;
        return ans;
    &#125;
&#125;;
&#x2F;&#x2F; 可读性更高
class Solution &#123;
public:
    int totalFruit(vector&lt;int&gt;&amp; fruits) &#123;
        int ans &#x3D; 0;
        int tot &#x3D; 0; &#x2F;&#x2F;种类
        int i &#x3D; 0; &#x2F;&#x2F;滑动窗口左端
        vector&lt;int&gt; cnts(fruits.size() + 1);  &#x2F;&#x2F; 统计每个种类水果的当前数量
        for(int j &#x3D; 0; j &lt; fruits.size() ; j++)&#123;
            cnts[fruits[j]]++;   &#x2F;&#x2F; 对应水果的数量+1
            if(cnts[fruits[j]] &#x3D;&#x3D; 1) tot++; &#x2F;&#x2F; 新的水果 种类数+1
            while(tot &gt; 2)&#123;  &#x2F;&#x2F; 种类数超过2 即超过窗口大小
                cnts[fruits[i]]--; &#x2F;&#x2F; 首先窗口左端对应水果数量-1 收缩
                if(cnts[fruits[i]] &#x3D;&#x3D; 0) tot--; &#x2F;&#x2F; 如果此时该种水果数量为0 则少了一种水果 种类数-1
                i++;  &#x2F;&#x2F; 左端向前移动 窗口收缩
            &#125;
            ans &#x3D; max(j - i + 1, ans); &#x2F;&#x2F; 选最大值
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="X76-最小覆盖子串"><a href="#X76-最小覆盖子串" class="headerlink" title="X76. 最小覆盖子串"></a>X<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><blockquote>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    unordered_map &lt;char, int&gt; ori, cnt;

    bool check() &#123;
        for (const auto &amp;p: ori) &#123;
            if (cnt[p.first] &lt; p.second) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;

    string minWindow(string s, string t) &#123;
        for (const auto &amp;c: t) &#123;
            ++ori[c];
        &#125;

        int l &#x3D; 0, r &#x3D; -1;
        int len &#x3D; INT_MAX, ansL &#x3D; -1, ansR &#x3D; -1;

        while (r &lt; int(s.size())) &#123;
            if (ori.find(s[++r]) !&#x3D; ori.end()) &#123;
                ++cnt[s[r]];
            &#125;
            while (check() &amp;&amp; l &lt;&#x3D; r) &#123;
                if (r - l + 1 &lt; len) &#123;
                    len &#x3D; r - l + 1;
                    ansL &#x3D; l;
                &#125;
                if (ori.find(s[l]) !&#x3D; ori.end()) &#123;
                    --cnt[s[l]];
                &#125;
                ++l;
            &#125;
        &#125;

        return ansL &#x3D;&#x3D; -1 ? string() : s.substr(ansL, len);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h4><blockquote>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        vector &lt;int&gt; ans;
        if(matrix.empty()) return ans; &#x2F;&#x2F;若数组为空，直接返回答案
        int u &#x3D; 0; &#x2F;&#x2F;赋值上下左右边界
        int d &#x3D; matrix.size() - 1;
        int l &#x3D; 0;
        int r &#x3D; matrix[0].size() - 1;
        while(true)
        &#123;
            for(int i &#x3D; l; i &lt;&#x3D; r; ++i) ans.push_back(matrix[u][i]); &#x2F;&#x2F;向右移动直到最右
            if(++ u &gt; d) break; &#x2F;&#x2F;重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i &#x3D; u; i &lt;&#x3D; d; ++i) ans.push_back(matrix[i][r]); &#x2F;&#x2F;向下
            if(-- r &lt; l) break; &#x2F;&#x2F;重新设定有边界
            for(int i &#x3D; r; i &gt;&#x3D; l; --i) ans.push_back(matrix[d][i]); &#x2F;&#x2F;向左
            if(-- d &lt; u) break; &#x2F;&#x2F;重新设定下边界
            for(int i &#x3D; d; i &gt;&#x3D; u; --i) ans.push_back(matrix[i][l]); &#x2F;&#x2F;向上
            if(++ l &gt; r) break; &#x2F;&#x2F;重新设定左边界
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><blockquote>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;
        int l &#x3D; 0 ,r &#x3D; n - 1,t &#x3D; 0 , b &#x3D; n -1;
        vector&lt;vector&lt;int&gt;&gt; mat(n,vector&lt;int&gt; (n,1));  &#x2F;&#x2F;二维vector初始化
        int num &#x3D; 1;
        int tar &#x3D; n * n;
        while(num &lt;&#x3D; tar)&#123;
            for(int i &#x3D; l; i &lt;&#x3D; r; i++) mat[t][i] &#x3D; num++; &#x2F;&#x2F; left to right.
            t++;
            for(int i &#x3D; t; i &lt;&#x3D; b; i++) mat[i][r] &#x3D; num++; &#x2F;&#x2F; top to bottom.
            r--;
            for(int i &#x3D; r; i &gt;&#x3D; l; i--) mat[b][i] &#x3D; num++; &#x2F;&#x2F; right to left.
            b--;
            for(int i &#x3D; b; i &gt;&#x3D; t; i--) mat[i][l] &#x3D; num++; &#x2F;&#x2F; bottom to top.
            l++;
        &#125;
        return mat;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="03-移除链表元素"><a href="#03-移除链表元素" class="headerlink" title="03. 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">03. 移除链表元素</a></h4><blockquote>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* removeElements(ListNode* head, int val) &#123;
        if(head &#x3D;&#x3D; nullptr) return head;
        ListNode* res &#x3D; head;
        while(res !&#x3D; nullptr &amp;&amp; res-&gt;val &#x3D;&#x3D; val) res &#x3D; (res-&gt;next &#x3D;&#x3D; nullptr ? nullptr : res-&gt;next);
        ListNode* p &#x3D; res;
        ListNode* q &#x3D; p;
        while(q !&#x3D; nullptr)&#123;
            p &#x3D; q;
            q &#x3D; q-&gt;next;
            while(q !&#x3D; nullptr &amp;&amp; q-&gt;val &#x3D;&#x3D; val)&#123;
                p-&gt;next &#x3D; q-&gt;next;
                q &#x3D; q-&gt;next;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h4><blockquote>
<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<p>在链表类中实现这些功能：</p>
<ul>
<li><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</p>
</li>
<li><p>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</p>
</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MyLinkedList &#123;
public:
    &#x2F;&#x2F; 定义链表节点结构体
    struct LinkedNode &#123;
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr)&#123;&#125;
    &#125;;

    &#x2F;&#x2F; 初始化链表
    MyLinkedList() &#123;
        _dummyHead &#x3D; new LinkedNode(0); &#x2F;&#x2F; 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size &#x3D; 0;
    &#125;

    &#x2F;&#x2F; 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) &#123;
        if (index &gt; (_size - 1) || index &lt; 0) &#123;
            return -1;
        &#125;
        LinkedNode* cur &#x3D; _dummyHead-&gt;next;
        while(index--)&#123; &#x2F;&#x2F; 如果--index 就会陷入死循环
            cur &#x3D; cur-&gt;next;
        &#125;
        return cur-&gt;val;
    &#125;

    &#x2F;&#x2F; 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) &#123;
        LinkedNode* newNode &#x3D; new LinkedNode(val);
        newNode-&gt;next &#x3D; _dummyHead-&gt;next;
        _dummyHead-&gt;next &#x3D; newNode;
        _size++;
    &#125;

    &#x2F;&#x2F; 在链表最后面添加一个节点
    void addAtTail(int val) &#123;
        LinkedNode* newNode &#x3D; new LinkedNode(val);
        LinkedNode* cur &#x3D; _dummyHead;
        while(cur-&gt;next !&#x3D; nullptr)&#123;
            cur &#x3D; cur-&gt;next;
        &#125;
        cur-&gt;next &#x3D; newNode;
        _size++;
    &#125;

    &#x2F;&#x2F; 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    &#x2F;&#x2F; 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    &#x2F;&#x2F; 如果index大于链表的长度，则返回空
    &#x2F;&#x2F; 如果index小于0，则置为0，作为链表的新头节点。
    void addAtIndex(int index, int val) &#123;
        if (index &gt; _size || index &lt; 0) &#123;
            return;
        &#125;
        LinkedNode* newNode &#x3D; new LinkedNode(val);
        LinkedNode* cur &#x3D; _dummyHead;
        while(index--) &#123;
            cur &#x3D; cur-&gt;next;
        &#125;
        newNode-&gt;next &#x3D; cur-&gt;next;
        cur-&gt;next &#x3D; newNode;
        _size++;
    &#125;

    &#x2F;&#x2F; 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) &#123;
        if (index &gt;&#x3D; _size || index &lt; 0) &#123;
            return;
        &#125;
        LinkedNode* cur &#x3D; _dummyHead;
        while(index--) &#123;
            cur &#x3D; cur -&gt;next;
        &#125;
        LinkedNode* tmp &#x3D; cur-&gt;next;
        cur-&gt;next &#x3D; cur-&gt;next-&gt;next;
        delete tmp;
        _size--;
    &#125;

    &#x2F;&#x2F; 打印链表
    void printLinkedList() &#123;
        LinkedNode* cur &#x3D; _dummyHead;
        while (cur-&gt;next !&#x3D; nullptr) &#123;
            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; &quot; &quot;;
            cur &#x3D; cur-&gt;next;
        &#125;
        cout &lt;&lt; endl;
    &#125;
private:
    int _size;
    LinkedNode* _dummyHead;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;双指针
&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* pre &#x3D; nullptr;
        ListNode* cur &#x3D; head;
        while(cur !&#x3D; nullptr)&#123;
            ListNode* tmp &#x3D; cur;
            cur &#x3D; cur-&gt;next;
            tmp-&gt;next &#x3D; pre;
            pre &#x3D; tmp;
        &#125;
        return pre;
    &#125;
&#125;;

&#x2F;&#x2F;递归
&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverse(ListNode* pre,ListNode* cur)&#123;
        if(cur &#x3D;&#x3D; nullptr) return pre;
        ListNode* tmp &#x3D; cur;
        cur &#x3D; cur-&gt;next;
        tmp-&gt;next &#x3D; pre;
        return reverse(tmp,cur);
    &#125;
    ListNode* reverseList(ListNode* head) &#123;
        return reverse(nullptr, head);
    &#125;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* swapPairs(ListNode* head) &#123;
        if(head &#x3D;&#x3D; nullptr) return head;
        ListNode* one &#x3D; head;
        ListNode* sec;
        if(one -&gt; next !&#x3D; nullptr)&#123;
            sec &#x3D; one -&gt; next;
        &#125;
        else return head;
        ListNode* res &#x3D; sec;
        while(one !&#x3D; nullptr)&#123;
            ListNode* tmp &#x3D; (sec &#x3D;&#x3D; nullptr ? nullptr : sec -&gt; next);
            one -&gt; next &#x3D; (tmp &#x3D;&#x3D; nullptr ? nullptr : (tmp -&gt; next &#x3D;&#x3D; nullptr ? tmp : tmp -&gt; next));
            if(sec !&#x3D; nullptr) sec -&gt; next &#x3D; one;
            one &#x3D; tmp;
            sec &#x3D; (one &#x3D;&#x3D; nullptr ? nullptr : one -&gt; next);
        &#125;

        return res;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    ListNode* swapPairs(ListNode* head) &#123;
        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点
        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur &#x3D; dummyHead;
        while(cur-&gt;next !&#x3D; nullptr &amp;&amp; cur-&gt;next-&gt;next !&#x3D; nullptr) &#123;
            ListNode* tmp &#x3D; cur-&gt;next; &#x2F;&#x2F; 记录临时节点
            ListNode* tmp1 &#x3D; cur-&gt;next-&gt;next-&gt;next; &#x2F;&#x2F; 记录临时节点

            cur-&gt;next &#x3D; cur-&gt;next-&gt;next;    &#x2F;&#x2F; 步骤一
            cur-&gt;next-&gt;next &#x3D; tmp;          &#x2F;&#x2F; 步骤二
            cur-&gt;next-&gt;next-&gt;next &#x3D; tmp1;   &#x2F;&#x2F; 步骤三

            cur &#x3D; cur-&gt;next-&gt;next; &#x2F;&#x2F; cur移动两位，准备下一轮交换
        &#125;
        return dummyHead-&gt;next;
    &#125;
&#125;;

&#x2F;&#x2F;递归
class Solution &#123;
public:
    ListNode* swapPairs(ListNode* head) &#123;
        if(head &#x3D;&#x3D; nullptr || head -&gt; next &#x3D;&#x3D; nullptr) return head;
        ListNode* next &#x3D; head -&gt; next;
        head -&gt; next &#x3D; swapPairs(next -&gt; next);
        next -&gt; next &#x3D; head;
        return next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><blockquote>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
        ListNode* dummyHead &#x3D; new ListNode(0);
        dummyHead-&gt;next &#x3D; head;
        ListNode* slow &#x3D; dummyHead;
        ListNode* fast &#x3D; dummyHead;
        while(n-- &amp;&amp; fast !&#x3D; NULL) &#123;
            fast &#x3D; fast-&gt;next;
        &#125;
        fast &#x3D; fast-&gt;next; &#x2F;&#x2F; fast再提前走一步，因为需要让slow指向删除节点的上一个节点
        while (fast !&#x3D; NULL) &#123;
            fast &#x3D; fast-&gt;next;
            slow &#x3D; slow-&gt;next;
        &#125;
        slow-&gt;next &#x3D; slow-&gt;next-&gt;next; 
        
        &#x2F;&#x2F; ListNode *tmp &#x3D; slow-&gt;next;  C++释放内存的逻辑
        &#x2F;&#x2F; slow-&gt;next &#x3D; tmp-&gt;next;
        &#x2F;&#x2F; delete nth;
        
        return dummyHead-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h4><blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> </p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        ListNode* a &#x3D; headA;
        ListNode* b &#x3D; headB;
        while( a !&#x3D; b)&#123;
            if(a  &#x3D;&#x3D; nullptr) a &#x3D; headB;
            else a &#x3D; a -&gt; next;

            if(b &#x3D;&#x3D; nullptr) b &#x3D; headA;
            else b &#x3D; b -&gt; next;
        &#125;
        return a;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        ListNode* fp &#x3D; head;
        ListNode* sp &#x3D; head;
        while(true)&#123;
            if(fp &#x3D;&#x3D; nullptr || fp -&gt; next &#x3D;&#x3D; nullptr) return nullptr;
            fp &#x3D; fp -&gt; next -&gt; next;
            sp &#x3D; sp -&gt; next;
            if(fp &#x3D;&#x3D; sp) break;
        &#125;
        fp &#x3D; head;
        while(sp !&#x3D; fp)&#123;
            sp &#x3D; sp -&gt; next;
            fp &#x3D; fp -&gt; next;
        &#125;
        return sp;
    &#125;
&#125;;

&#x2F;&#x2F;  关键是 a + nb 时在入口处 以及 f &#x3D; s + nb 快指针比慢指针多走了n个圈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h4><blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isAnagram(string s, string t) &#123;
        unordered_map&lt;char,int&gt; map;
        if (s.size() !&#x3D; t.size()) return false;
        for(int i &#x3D; 0 ; i &lt; s.size() ; i++) map[s[i]]++;
        for(int j &#x3D; 0 ; j &lt; t.size() ; j++)&#123;
            if(map[t[j]] &#x3D;&#x3D; 0) return 0;
            else&#123;
                map[t[j]]--;
            &#125;
        &#125;
        return 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h4><blockquote>
<p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool canConstruct(string ransomNote, string magazine) &#123;
        int a[26];
        memset(a, 0, sizeof(a));
        if(ransomNote.size() &gt; magazine.size()) return false;
        for(auto x : magazine)&#123;
            a[x - &#39;a&#39;]++;
        &#125; 
        for(auto y : ransomNote)&#123;
            if(a[y - &#39;a&#39;] &#x3D;&#x3D; 0) return false;
            a[y - &#39;a&#39;]--;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h4><blockquote>
<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string,vector&lt;string&gt;&gt; map;
        vector&lt;vector&lt;string&gt;&gt; res;
        for(string x : strs)&#123;
            string y &#x3D; x;
            sort(x.begin(),x.end());
            map[x].push_back(y);
        &#125;
        for(auto it &#x3D; map.begin(); it !&#x3D; map.end() ; it++) res.push_back(it -&gt; second);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><blockquote>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        unordered_map&lt;int,int&gt; map;
        vector&lt;int&gt; res;
        for(int x : nums1) map[x]++;
        for(int y : nums2)&#123;
            if(map[y] &gt; 0)&#123;
                map[y] &#x3D; 0;
                res.push_back(y);
            &#125;
        &#125;  
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h4><blockquote>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isHappy(int n) &#123;
        unordered_set&lt;int&gt; dic;
        dic.emplace(n);
        while(true)&#123;
            n &#x3D; cat(n);
            if(n &#x3D;&#x3D; 1) return 1;
            else if (dic.count(n) !&#x3D; 0) return false;
            dic.emplace(n);
        &#125;
        return -1;
    &#125;

    int cat(int n)&#123;
        int sum &#x3D; 0;
        while(n !&#x3D; 0)&#123;
            int x &#x3D; n % 10;
            n &#x2F;&#x3D; 10;
            sum +&#x3D; x * x;
        &#125;
        return sum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        unordered_map&lt;int,int&gt; dic;
        vector&lt;int&gt; res;
        for(int i &#x3D; 0 ; i &lt; nums.size() ; i++)&#123;
            if(dic.find(target - nums[i]) !&#x3D; dic.end())&#123;
                res.push_back(i);
                res.push_back(dic[target - nums[i]]);
                return res;
            &#125;
            dic[nums[i]] &#x3D; i;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h4><blockquote>
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<ul>
<li><p>0 &lt;= i, j, k, l &lt; n</p>
</li>
<li><p>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
</li>
</ul>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;
        unordered_map&lt;int, int&gt; umap; 
        for (int a : A) &#123;
            for (int b : B) &#123;
                umap[a + b]++;
            &#125;
        &#125;
        int count &#x3D; 0; 
        for (int c : C) &#123;
            for (int d : D) &#123;
                if (umap.find(0 - (c + d)) !&#x3D; umap.end()) &#123;
                    count +&#x3D; umap[0 - (c + d)];
                &#125;
            &#125;
        &#125;
        return count;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; result;
        sort(nums.begin(), nums.end());
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            if (nums[i] &gt; 0) &#123;
                return result;
            &#125;
            &#x2F;&#x2F; 错误去重a方法，将会漏掉-1,-1,2 这种情况
            &#x2F;*
            if (nums[i] &#x3D;&#x3D; nums[i + 1]) &#123;
                continue;
            &#125;
            *&#x2F;
            &#x2F;&#x2F; 正确去重a方法
            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;
                continue;
            &#125;
            int left &#x3D; i + 1;
            int right &#x3D; nums.size() - 1;
            while ( left &lt; right ) &#123;
                &#x2F;&#x2F; 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;&#x3D;left 了，从而漏掉了 0,0,0 这种三元组
                &#x2F;*
                while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;
                while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;
                *&#x2F;
                if (nums[i] + nums[left] + nums[right] &gt; 0) right--;
                else if (nums[i] + nums[left] + nums[right] &lt; 0) left++;
                else &#123;
                    result.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);
                    &#x2F;&#x2F; 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;
                    while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;
                    right--;
                    left++;
                &#125;
            &#125;

        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h4><blockquote>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li>0 &lt;= a, b, c, d &lt; n</li>
<li>a、b、c 和 d 互不相同</li>
<li>nums[a] + nums[b] + nums[c] + nums[d] == target</li>
</ul>
<p>你可以按 任意顺序 返回答案 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;vector&lt;int&gt;&gt; result;
        sort(nums.begin(), nums.end());
        for (int k &#x3D; 0; k &lt; nums.size(); k++) &#123;
            &#x2F;&#x2F; 剪枝处理
            if (nums[k] &gt; target &amp;&amp; nums[k] &gt;&#x3D; 0) &#123;
            	break; &#x2F;&#x2F; 这里使用break，统一通过最后的return返回
            &#125;
            &#x2F;&#x2F; 对nums[k]去重
            if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;
                continue;
            &#125;
            for (int i &#x3D; k + 1; i &lt; nums.size(); i++) &#123;
                &#x2F;&#x2F; 2级剪枝处理
                if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;&#x3D; 0) &#123;
                    break;
                &#125;

                &#x2F;&#x2F; 对nums[i]去重
                if (i &gt; k + 1 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;
                    continue;
                &#125;
                int left &#x3D; i + 1;
                int right &#x3D; nums.size() - 1;
                while (right &gt; left) &#123;
                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出
                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;
                        right--;
                    &#x2F;&#x2F; nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出
                    &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;
                        left++;
                    &#125; else &#123;
                        result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);
                        &#x2F;&#x2F; 对nums[left]和nums[right]去重
                        while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;
                        while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;

                        &#x2F;&#x2F; 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    &#125;
                &#125;

            &#125;
        &#125;
        return result;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    void reverseString(vector&lt;char&gt;&amp; s) &#123;

        for(int i &#x3D; 0 ,j &#x3D; s.size() - 1; i  &lt; s.size()&#x2F;2 ; i++,j--)&#123;
            s[i] ^&#x3D; s[j];
            s[j] ^&#x3D; s[i];
            s[i] ^&#x3D; s[j];
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><blockquote>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<ul>
<li><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
</li>
<li><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
</li>
</ul>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    string reverseStr(string s, int k) &#123;
        for(int i &#x3D; 0 ; i &lt; s.size() ; i +&#x3D; 2 * k)&#123;
            if(i + k &lt;&#x3D; s.size()) reverse(s.begin() + i , s.begin() + i + k);
            else reverse(s.begin() + i, s.end());
        &#125;
        return s;
    &#125;
&#125;;

&#x2F;&#x2F; 常规解法
class Solution &#123;
public:
    string reverseStr(string s, int k) &#123;
        for (int i &#x3D; 0; i &lt; s.size(); i +&#x3D; (2 * k)) &#123;
            &#x2F;&#x2F; 1. 每隔 2k 个字符的前 k 个字符进行反转
            &#x2F;&#x2F; 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if (i + k &lt;&#x3D; s.size()) &#123;
                reverse(s.begin() + i, s.begin() + i + k );
            &#125; else &#123;
                &#x2F;&#x2F; 3. 剩余字符少于 k 个，则将剩余字符全部反转。
                reverse(s.begin() + i, s.end());
            &#125;
        &#125;
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><blockquote>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    string replaceSpace(string s) &#123;
        int num &#x3D; 0;
        int osize &#x3D; s.size();
        for(char x : s)&#123;
            if(x &#x3D;&#x3D; &#39; &#39;) num++;
        &#125;
        s.resize(s.size() + num * 2);
        int nsize &#x3D; s.size();
        for(int i &#x3D; osize - 1, j &#x3D; nsize - 1 ; i &lt; j ; i-- , j--)&#123;
            if(s[i] !&#x3D; &#39; &#39;) s[j] &#x3D; s[i];
            else&#123;
                s[j] &#x3D; &#39;0&#39;;
                s[j-1] &#x3D; &#39;2&#39;;
                s[j-2] &#x3D; &#39;%&#39;;
                j -&#x3D; 2;
            &#125;
        &#125;
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><blockquote>
<p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    void reverse(string&amp; s, int start, int end)&#123; &#x2F;&#x2F;翻转，区间写法：左闭右闭 []
        for (int i &#x3D; start, j &#x3D; end; i &lt; j; i++, j--) &#123;
            swap(s[i], s[j]);
        &#125;
    &#125;

    void removeExtraSpaces(string&amp; s) &#123;&#x2F;&#x2F;去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow &#x3D; 0;   &#x2F;&#x2F;整体思想参考https:&#x2F;&#x2F;programmercarl.com&#x2F;0027.移除元素.html
        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123; &#x2F;&#x2F;
            if (s[i] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F;遇到非空格就处理，即删除所有空格。
                if (slow !&#x3D; 0) s[slow++] &#x3D; &#39; &#39;; &#x2F;&#x2F;手动控制空格，给单词之间添加空格。slow !&#x3D; 0说明不是第一个单词，需要在单词前添加空格。
                while (i &lt; s.size() &amp;&amp; s[i] !&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F;补上该单词，遇到空格说明单词结束。
                    s[slow++] &#x3D; s[i++];
                &#125;
            &#125;		
        &#125;
        s.resize(slow); &#x2F;&#x2F;slow的大小即为去除多余空格后的大小。
    &#125;

    string reverseWords(string s) &#123;
        removeExtraSpaces(s); &#x2F;&#x2F;去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size() - 1);
        int start &#x3D; 0; &#x2F;&#x2F;removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i &#x3D; 0; i &lt;&#x3D; s.size(); ++i) &#123;
            if (i &#x3D;&#x3D; s.size() || s[i] &#x3D;&#x3D; &#39; &#39;) &#123; &#x2F;&#x2F;到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); &#x2F;&#x2F;翻转，注意是左闭右闭 []的翻转。
                start &#x3D; i + 1; &#x2F;&#x2F;更新下一个单词的开始下标start
            &#125;
        &#125;
        return s;
    &#125;
&#125;;

&#x2F;&#x2F; 不重写reverse
class Solution &#123;
public:
    string reverseWords(string s) &#123;
        removeExtraSpace(s);
        reverse(s.begin(), s.end());
        string::iterator start &#x3D; s.begin();
        for(string::iterator i &#x3D; s.begin(); i !&#x3D; s.end() ; i++)&#123;
            if(i &#x3D;&#x3D; (s.end() - 1)) reverse(start, s.end());
            if(*i &#x3D;&#x3D; &#39; &#39;)&#123;
                reverse(start, i);
                start &#x3D; i + 1;
            &#125;
        &#125;
        return s;
    &#125;

    void removeExtraSpace(string &amp;st)&#123;
        int s &#x3D; 0;
        for (int f &#x3D; 0 ; f &lt; st.size() ; f++)&#123;
            if(st[f] !&#x3D; &#39; &#39;)&#123;
                if(s !&#x3D; 0) st[s++] &#x3D; &#39; &#39;;
                while(f &lt; st.size() &amp;&amp; st[f] !&#x3D; &#39; &#39;) st[s++] &#x3D; st[f++];
            &#125;
        &#125;
        st.resize(s);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string reverseLeftWords(string s, int n) &#123;
        &#x2F;&#x2F; reverse(s.begin(), s.begin() + n);
        &#x2F;&#x2F; reverse(s.begin() + n, s.end());
        &#x2F;&#x2F; reverse(s.begin(), s.end());
        &#x2F;&#x2F; return s;
        string res &#x3D; s.substr(n , s.size() - n) + s.substr(0,n);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="KMP———28-找出字符串中第一个匹配项的下标"><a href="#KMP———28-找出字符串中第一个匹配项的下标" class="headerlink" title="KMP———28. 找出字符串中第一个匹配项的下标"></a><strong>KMP</strong>———<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><blockquote>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int strStr(string haystack, string needle) &#123;
        if(needle.size() &#x3D;&#x3D; 0) return 0;
        int next[needle.size()];
        getNext(next,needle);
        int j &#x3D; 0;
        for(int i &#x3D; 0; i &lt; haystack.size() ; i++)&#123;
            while(j &gt; 0 &amp;&amp; haystack[i] !&#x3D; needle[j]) &#123;
                j &#x3D; next[j - 1];
            &#125;
            if (haystack[i] &#x3D;&#x3D; needle[j]) &#123;
                j++;
            &#125;
            if (j &#x3D;&#x3D; needle.size() ) &#123;
                return (i - needle.size() + 1);
            &#125;
        &#125;
        return -1;
    &#125;

    void getNext(int * next , string s)&#123;
        int j &#x3D; 0;
        next[0] &#x3D; j;
        for(int i &#x3D; 1 ; i &lt; s.size() ; i++)&#123;
            while(j &gt; 0 &amp;&amp; s[i] !&#x3D; s[j]) j &#x3D; next[j - 1];
            if(s[i] &#x3D;&#x3D; s[j]) j++;
            next[i] &#x3D; j; 
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><blockquote>
<p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool repeatedSubstringPattern(string s) &#123;
        string t &#x3D; s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); &#x2F;&#x2F; 掐头去尾
        if (t.find(s) !&#x3D; std::string::npos) return true; &#x2F;&#x2F; r
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="27-移除元素-1"><a href="#27-移除元素-1" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;new
class Solution &#123;
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
        int slowIndex &#x3D; 0; int fastIndex &#x3D; 0;
        while(fastIndex &lt; nums.size())&#123;
            if (val !&#x3D; nums[fastIndex]) nums[slowIndex++] &#x3D; nums[fastIndex++];
            else fastIndex++;
        &#125;
        return slowIndex;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="344-反转字符串-1"><a href="#344-反转字符串-1" class="headerlink" title="344. 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><h4 id="151-反转字符串中的单词-1"><a href="#151-反转字符串中的单词-1" class="headerlink" title="151. 反转字符串中的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><h4 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><h4 id="19-删除链表的倒数第-N-个结点-1"><a href="#19-删除链表的倒数第-N-个结点-1" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><h4 id="面试题-02-07-链表相交-1"><a href="#面试题-02-07-链表相交-1" class="headerlink" title="面试题 02.07. 链表相交"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h4><h4 id="142-环形链表-II-1"><a href="#142-环形链表-II-1" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><h4 id="15-三数之和-1"><a href="#15-三数之和-1" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><h4 id="18-四数之和-1"><a href="#18-四数之和-1" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h4><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<ul>
<li><p>void push(int x) 将元素 x 推到队列的末尾</p>
</li>
<li><p>int pop() 从队列的开头移除并返回元素</p>
</li>
<li>int peek() 返回队列开头的元素</li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>
</ul>
<p>说明：</p>
<ul>
<li><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</p>
</li>
<li><p>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可</p>
</li>
</ul>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MyQueue &#123;
public:
    stack&lt;int&gt; a;
    stack&lt;int&gt; b;
    MyQueue() &#123;&#125;
    
    void push(int x) &#123;
        a.push(x);
    &#125;
    
    int pop() &#123;
        int tmp;
        if(b.empty())&#123;
            while(!a.empty())&#123;
                tmp &#x3D; a.top();
                a.pop();
                b.push(tmp);
            &#125;
        &#125;
        tmp &#x3D; b.top();
        b.pop();
        return tmp;
    &#125;
    
    int peek() &#123;
        int tmp;
        if(b.empty())&#123;
            while(!a.empty())&#123;
                tmp &#x3D; a.top();
                a.pop();
                b.push(tmp);
            &#125;
        &#125;
        return b.top();
    &#125;
    
    bool empty() &#123;
        return (a.empty() &amp;&amp; b.empty());
    &#125;
&#125;;

&#x2F;**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj &#x3D; new MyQueue();
 * obj-&gt;push(x);
 * int param_2 &#x3D; obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;peek();
 * bool param_4 &#x3D; obj-&gt;empty();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><blockquote>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<ul>
<li><p>void push(int x) 将元素 x 压入栈顶。</p>
</li>
<li><p>int pop() 移除并返回栈顶元素。</p>
</li>
<li>int top() 返回栈顶元素。</li>
<li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</li>
</ul>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MyStack &#123;
public:
    queue&lt;int&gt; a;
    queue&lt;int&gt; b;

    MyStack() &#123;&#125;
    
    void push(int x) &#123;
        a.push(x);
    &#125;
    
    int pop() &#123;
        int tmp;
        int res;
        while(a.size() !&#x3D; 1)&#123;
            tmp &#x3D; a.front();
            a.pop();
            b.push(tmp);
        &#125;
        res &#x3D; a.front();
        a.pop();
        while(b.size() !&#x3D; 0)&#123;
            tmp &#x3D; b.front();
            a.push(tmp);
            b.pop();
        &#125;
        return res;
    &#125;
    
    int top() &#123;
        int tmp;
        int res;
        while(a.size() !&#x3D; 1)&#123;
            tmp &#x3D; a.front();
            a.pop();
            b.push(tmp);
        &#125;
        res &#x3D; a.front();
        a.pop();
        b.push(res);
        while(b.size() !&#x3D; 0)&#123;
            tmp &#x3D; b.front();
            a.push(tmp);
            b.pop();
        &#125;
        return res;
    &#125;
    
    bool empty() &#123;
        return a.empty();
    &#125;
&#125;;

&#x2F;**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj &#x3D; new MyStack();
 * obj-&gt;push(x);
 * int param_2 &#x3D; obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;top();
 * bool param_4 &#x3D; obj-&gt;empty();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h4><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li><p>左括号必须用相同类型的右括号闭合。</p>
</li>
<li><p>左括号必须以正确的顺序闭合。</p>
</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ul>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isValid(string s) &#123;
        if(s.size() % 2 !&#x3D; 0) return false;
        if(s[0] &#x3D;&#x3D; &#39;]&#39; || s[0] &#x3D;&#x3D; &#39;)&#39; || s[0] &#x3D;&#x3D; &#39;&#125;&#39; ) return false;
        stack&lt;char&gt; st;
        for(char x : s)&#123;
            if(x &#x3D;&#x3D; &#39;[&#39;) st.push(&#39;]&#39;);
            else if(x &#x3D;&#x3D; &#39;(&#39;) st.push(&#39;)&#39;);
            else if(x &#x3D;&#x3D; &#39;&#123;&#39;) st.push(&#39;&#125;&#39;);
            else if(st.empty() || st.top() !&#x3D; x) return false;
            else st.pop();
        &#125;
        return st.empty();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4><blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    string removeDuplicates(string s) &#123;
        stack&lt;char&gt; st;
        for(char x : s)&#123;
            if(st.empty() || st.top() !&#x3D; x) st.push(x);
            else st.pop();
        &#125;
        string res &#x3D; &quot;&quot;;
        while (!st.empty()) &#123; 
            res +&#x3D; st.top();
            st.pop();
        &#125;
        reverse (res.begin(), res.end());
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><blockquote>
<p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        stack&lt;long long&gt; st; 
        for (int i &#x3D; 0; i &lt; tokens.size(); i++) &#123;
            if (tokens[i] &#x3D;&#x3D; &quot;+&quot; || tokens[i] &#x3D;&#x3D; &quot;-&quot; || tokens[i] &#x3D;&#x3D; &quot;*&quot; || tokens[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;
                long long num1 &#x3D; st.top();
                st.pop();
                long long num2 &#x3D; st.top();
                st.pop();
                if (tokens[i] &#x3D;&#x3D; &quot;+&quot;) st.push(num2 + num1);
                if (tokens[i] &#x3D;&#x3D; &quot;-&quot;) st.push(num2 - num1);
                if (tokens[i] &#x3D;&#x3D; &quot;*&quot;) st.push(num2 * num1);
                if (tokens[i] &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(num2 &#x2F; num1);
            &#125; else &#123;
                st.push(stoll(tokens[i]));
            &#125;
        &#125;
        int result &#x3D; st.top();
        st.pop();  
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="X239-滑动窗口最大值"><a href="#X239-滑动窗口最大值" class="headerlink" title="X239. 滑动窗口最大值"></a>X<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 .</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    class MonQueue &#123; 
    public:
        deque&lt;int&gt; q;

        void push(int x)&#123;
            while(!q.empty() &amp;&amp; q.back() &lt; x) q.pop_back();
            q.push_back(x);
        &#125;

        void pop(int x)&#123;
            if(!q.empty() &amp;&amp; q.front() &#x3D;&#x3D; x) q.pop_front();
        &#125;

        int front()&#123;
            return q.front();
        &#125;
    &#125;;
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;
        MonQueue que;
        vector&lt;int&gt; res;
        for(int i &#x3D; 0 ; i &lt; k ; i++)&#123;
            que.push(nums[i]);
        &#125;
        res.push_back(que.front());
        for(int i &#x3D; k ; i &lt; nums.size() ; i++)&#123;
            que.pop(nums[i - k]);
            que.push(nums[i]);
            res.push_back(que.front());
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="X347-前-K-个高频元素"><a href="#X347-前-K-个高频元素" class="headerlink" title="X347. 前 K 个高频元素"></a>X<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 时间复杂度：O(nlogk)
&#x2F;&#x2F; 空间复杂度：O(n)
class Solution &#123;
public:
    &#x2F;&#x2F; 小顶堆
    class mycomparison &#123;
    public:
        bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123;
            return lhs.second &gt; rhs.second;
        &#125;
    &#125;;
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;
        &#x2F;&#x2F; 要统计元素出现频率
        unordered_map&lt;int, int&gt; map; &#x2F;&#x2F; map&lt;nums[i],对应出现的次数&gt;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            map[nums[i]]++;
        &#125;

        &#x2F;&#x2F; 对频率排序
        &#x2F;&#x2F; 定义一个小顶堆，大小为k
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que;

        &#x2F;&#x2F; 用固定大小为k的小顶堆，扫面所有频率的数值
        for (unordered_map&lt;int, int&gt;::iterator it &#x3D; map.begin(); it !&#x3D; map.end(); it++) &#123;
            pri_que.push(*it);
            if (pri_que.size() &gt; k) &#123; &#x2F;&#x2F; 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            &#125;
        &#125;

        &#x2F;&#x2F; 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector&lt;int&gt; result(k);
        for (int i &#x3D; k - 1; i &gt;&#x3D; 0; i--) &#123;
            result[i] &#x3D; pri_que.top().first;
            pri_que.pop();
        &#125;
        return result;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<p>PS:<strong>后序</strong> 遍历将入栈左右节点的顺序交换 再将res反转即可。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

&#x2F;&#x2F;递归
class Solution &#123;
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        Traversal(root,res);
        return res;
    &#125;

    void Traversal(TreeNode* node,vector&lt;int&gt; &amp; res)&#123;
        if(node &#x3D;&#x3D; nullptr) return;
        res.push_back(node -&gt; val);
        Traversal(node -&gt; left,res);
        Traversal(node -&gt; right,res);
    &#125;  
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; st;
        if(root &#x3D;&#x3D; nullptr) return res;
        st.push(root);
        while(!st.empty())&#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            res.push_back(node -&gt; val);
            if(node -&gt; right) st.push(node -&gt; right);
            if(node -&gt; left) st.push(node -&gt; left);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;迭代
&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur &#x3D; root;
        while(cur !&#x3D; nullptr || !st.empty())&#123;
            if(cur !&#x3D; nullptr)&#123;
                st.push(cur);
                cur &#x3D; cur -&gt; left;
            &#125;
            else&#123;
                cur &#x3D; st.top();
                st.pop();
                res.push_back(cur-&gt;val);   
                cur &#x3D; cur-&gt;right;     
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;前序
class Solution &#123;
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        stack&lt;TreeNode*&gt; st;
        if(root !&#x3D; nullptr) st.push(root);
        while(!st.empty())&#123;
            TreeNode* node &#x3D; st.top();
            if(node !&#x3D; nullptr)&#123; &#x2F;&#x2F;前序中序后序区别只在这里
                st.pop();&#x2F;&#x2F;固定
                
                if(node -&gt; right)  st.push(node -&gt; right);&#x2F;&#x2F;1
                
                if(node -&gt; left)  st.push(node -&gt; left);&#x2F;&#x2F;2
                
                st.push(node);&#x2F;&#x2F;3
                st.push(nullptr);
            &#125;
            else&#123;
                st.pop();
                node &#x3D; st.top();
                st.pop();
                res.push_back(node  -&gt; val);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;

&#x2F;&#x2F;中序就是 1 3 2
&#x2F;&#x2F;后序就是 3 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

&#x2F;&#x2F;迭代法
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;TreeNode*&gt; que;
        if(root !&#x3D; nullptr) que.push(root);
        while(!que.empty())&#123;
            vector&lt;int&gt; level;
            int size &#x3D; que.size();
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                level.push_back(node -&gt; val);
                if(node -&gt; left) que.push(node -&gt; left);
                if(node -&gt; right) que.push(node -&gt; right);
            &#125;
            res.push_back(level);
        &#125;
        return res;
    &#125;
&#125;;

&#x2F;&#x2F;递归法
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        int depth &#x3D; 0;
        order(root,res,0);
        return res;
    &#125;
    void order(TreeNode* cur, vector&lt;vector&lt;int&gt;&gt;&amp; res, int depth)&#123;
        if(cur &#x3D;&#x3D; nullptr) return;
        if (res.size() &#x3D;&#x3D; depth) res.push_back(vector&lt;int&gt;()); 
        &#x2F;&#x2F;当前层若无vector 塞一个进去
        res[depth].push_back(cur -&gt; val);
        order(cur -&gt; left , res , depth + 1);
        order(cur -&gt; right, res , depth + 1);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(root !&#x3D; nullptr) que.push(root);
        while(!que.empty())&#123;
            vector&lt;int&gt; level;
            int size &#x3D; que.size();
            for(int i &#x3D; 0 ; i &lt; size ; i ++)&#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                level.push_back(node -&gt; val);
                if(node -&gt; left) que.push(node -&gt; left);
                if(node -&gt; right) que.push(node -&gt; right);
            &#125;
            res.push_back(level);
        &#125;
        reverse(res.begin(),res.end());  &#x2F;&#x2F;正常层序加反转即可
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h4><p>相当于层序遍历每次只要每层最后一个</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;int&gt; res;
        if(root !&#x3D; nullptr) que.push(root);
        while(!que.empty())&#123;
            vector&lt;int&gt; level;
            int size &#x3D; que.size();
            for(int i &#x3D; 0 ; i &lt; size ; i++ )&#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                level.push_back(node -&gt; val);
                if(node -&gt; left) que.push(node -&gt; left);
                if(node -&gt; right) que.push(node -&gt; right);
            &#125;
            res.push_back(level.back()); &#x2F;&#x2F;只要层序遍历最后一个 即最右边
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;
        vector&lt;double&gt; res;
        queue&lt;TreeNode*&gt; que;
        if(root !&#x3D; nullptr) que.push(root);
        while(!que.empty())&#123;
            int size &#x3D; que.size();
            vector&lt;double&gt; level;
            double sum &#x3D; 0;
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                level.push_back(node -&gt; val);
                sum +&#x3D; node -&gt; val;
                if(node -&gt; left) que.push(node -&gt; left);
                if(node -&gt; right) que.push(node -&gt; right);
            &#125;
            sum &#x2F;&#x3D; level.size();
            res.push_back(sum);
            sum &#x3D; 0;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val &#x3D; _val;
    &#125;

    Node(int _val, vector&lt;Node*&gt; _children) &#123;
        val &#x3D; _val;
        children &#x3D; _children;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;Node*&gt; que;
        if(root) que.push(root);
        while(!que.empty())&#123;
            int size &#x3D; que.size();
            vector&lt;int&gt; level;
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                Node* node &#x3D; que.front();
                que.pop();
                level.push_back(node -&gt; val);
                
                &#x2F;&#x2F; 唯一特别
                for(int j &#x3D; 0 ; j &lt; node -&gt; children.size() ; j++)&#123;
                    que.push(node -&gt; children[j]);
                &#125;
                &#x2F;&#x2F; 唯一特别
                
            &#125;
            res.push_back(level);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

class Solution &#123;
public:
    vector&lt;int&gt; largestValues(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        queue&lt;TreeNode*&gt; que;
        if(root !&#x3D; nullptr) que.push(root);
        while(!que.empty())&#123;
            int size &#x3D; que.size();
            int maxnum &#x3D; 1&lt;&lt;31;
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                maxnum &#x3D; max(maxnum , node -&gt; val);
                if(node -&gt; left) que.push(node -&gt; left);
                if(node -&gt; right) que.push(node -&gt; right);
            &#125;
            res.push_back(maxnum);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    Node* connect(Node* root) &#123;
        queue&lt;Node*&gt; que;
        if(root !&#x3D; nullptr) que.push(root);
        while(!que.empty())&#123;
            int size &#x3D; que.size();
            vector&lt;Node*&gt; level;
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                Node* node &#x3D; que.front();
                que.pop();
                level.push_back(node);
                if(node -&gt; left) que.push(node -&gt; left);
                if(node -&gt; right) que.push(node -&gt; right);
            &#125;
            &#x2F;&#x2F;层序遍历角度看 就是每层数组一个指一个
            for(int i &#x3D; 0 ; i &lt; level.size() - 1 ; i++) &#123;
                level[i] -&gt; next &#x3D; level[i + 1];
            &#125;
        &#125;
        return root; 
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val &#x3D; _val;
    &#125;

    Node(int _val, vector&lt;Node*&gt; _children) &#123;
        val &#x3D; _val;
        children &#x3D; _children;
    &#125;
&#125;;
*&#x2F;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    int maxDepth(Node* root) &#123;
        queue&lt;Node*&gt; que;
        int res &#x3D; 0;
        if(root) que.push(root);
        while(!que.empty())&#123;
            int size &#x3D; que.size();
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                Node* node &#x3D; que.front();
                que.pop();
                for(int j &#x3D; 0 ; j &lt; node -&gt; children.size() ; j++)&#123;
                	que.push(node -&gt; children[j]);    
                &#125; 
            &#125;
            res++;
        &#125;
        return res; 
    &#125;
&#125;;

&#x2F;&#x2F;递归
class Solution &#123;
public:
    int maxDepth(TreeNode* root) &#123;
        if(root &#x3D;&#x3D; nullptr) return 0;
        return 1 + max(maxDepth(root -&gt; left) , maxDepth(root -&gt; right)); 
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        int res &#x3D; 1;
        if(root) que.push(root);
        else return 0;
        while(!que.empty())&#123;
            int size &#x3D; que.size();
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                if(node -&gt; left || node -&gt; right)&#123;
                    if(node -&gt; left) que.push(node -&gt; left);
                    if(node -&gt; right) que.push(node -&gt; right);
                &#125;
                else return res;
            &#125;
            res++;
        &#125;
        return res; 
    &#125;
&#125;;


&#x2F;&#x2F;递归
class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        if(root &#x3D;&#x3D; nullptr) return 0; 
        if(root -&gt; left &#x3D;&#x3D; nullptr &amp;&amp; root -&gt; right !&#x3D; nullptr) return 1 + minDepth(root -&gt; right);
        if(root -&gt; left !&#x3D; nullptr &amp;&amp; root -&gt; right &#x3D;&#x3D; nullptr) return 1 + minDepth(root -&gt; left);
        return 1 + min(minDepth(root -&gt; right) , minDepth(root -&gt; left));
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><blockquote>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

&#x2F;&#x2F;递归（前序）
class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
        reverseTree(root);
        return root;
    &#125;

    void reverseTree(TreeNode* node)&#123;
        if(node &#x3D;&#x3D; nullptr) return;
        swap(node -&gt; left , node -&gt; right);
        reverseTree(node -&gt; left);
        reverseTree(node -&gt; right);
    &#125;
&#125;;

&#x2F;&#x2F;迭代(中序)
class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        if(root !&#x3D; nullptr) st.push(root);
        while(!st.empty())&#123;
            TreeNode* node &#x3D; st.top();
            if(node !&#x3D; nullptr)&#123;
                st.pop();
                if(node -&gt; left) st.push(node -&gt; left);
                st.push(node);
                st.push(nullptr);
                if(node -&gt; right) st.push(node -&gt; right);
            &#125;
            else&#123;
                st.pop();
                node &#x3D; st.top();
                st.pop();
                swap(node -&gt; left, node -&gt; right); &#x2F;&#x2F;和前中后序迭代统一法的代码区别
            &#125;
        &#125;
        return root;
    &#125;
&#125;;

&#x2F;&#x2F;层序
class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        if(root !&#x3D; nullptr) que.push(root);
        while(!que.empty())&#123;
            int size &#x3D; que.size();
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                TreeNode* node &#x3D; que.front();
                que.pop();
                swap(node -&gt; left , node -&gt; right); &#x2F;&#x2F;和层序迭代法的代码区别
                if(node -&gt; left) que.push(node -&gt; left);
                if(node -&gt; right) que.push(node -&gt; right);
            &#125;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

&#x2F;&#x2F;递归
class Solution &#123;
public:
    bool isSymmetric(TreeNode* root) &#123;
        return root &#x3D;&#x3D; nullptr ? 1 : Symmetric(root -&gt; left , root -&gt; right);
    &#125;

    bool Symmetric(TreeNode* l , TreeNode* r)&#123;
        if(l &#x3D;&#x3D; nullptr &amp;&amp; r &#x3D;&#x3D; nullptr) return 1;
        if(l &#x3D;&#x3D; nullptr || r &#x3D;&#x3D; nullptr || l -&gt; val !&#x3D; r -&gt; val) return 0;
        return Symmetric(l -&gt; left , r -&gt; right) &amp;&amp; Symmetric(l -&gt; right , r -&gt; left);
    &#125;
&#125;;


&#x2F;&#x2F;迭代
class Solution &#123;
public:
    bool isSymmetric(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        if(root &#x3D;&#x3D; nullptr) return 0;
        &#x2F;&#x2F;因为镜像本质是对比子节点 根节点无需放进去了
        que.push(root -&gt; left);
        que.push(root -&gt; right);
        
        while(!que.empty())&#123;
            TreeNode* l &#x3D; que.front();
            que.pop();
            TreeNode* r &#x3D; que.front();
            que.pop();
            if(l &#x3D;&#x3D; nullptr &amp;&amp; r &#x3D;&#x3D; nullptr) continue;
            if(l &#x3D;&#x3D; nullptr || r &#x3D;&#x3D; nullptr || l -&gt; val !&#x3D; r -&gt; val) return 0;
            que.push(l -&gt; left);
            que.push(r -&gt; right);
            que.push(l -&gt; right);
            que.push(r -&gt; left);
        &#125;
        return 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h4><h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;
        if(subRoot &#x3D;&#x3D; nullptr) return 1;
        if(root &#x3D;&#x3D; nullptr) return 0;
        return traver(root, subRoot) || isSubtree(root -&gt; right , subRoot) || isSubtree(root -&gt; left , subRoot);
    &#125;

    bool traver(TreeNode* r , TreeNode* s)&#123;
        if(s &#x3D;&#x3D; nullptr &amp;&amp; r &#x3D;&#x3D; nullptr) return 1;
        if(s &#x3D;&#x3D; nullptr || r &#x3D;&#x3D; nullptr) return 0;
        return r -&gt; val &#x3D;&#x3D; s -&gt; val &amp;&amp; traver(r -&gt; left , s -&gt; left) &amp;&amp; traver(r -&gt; right , s -&gt; right);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><blockquote>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;


&#x2F;&#x2F;普通二叉树
class Solution &#123;
public:
    int countNodes(TreeNode* root) &#123;
        int res &#x3D; 0;
        queue&lt;TreeNode*&gt; que;
        if(root &#x3D;&#x3D; nullptr) return 0;
        else que.push(root);
        while(!que.empty())&#123;
            TreeNode* node &#x3D; que.front();
            que.pop();
            res++; &#x2F;&#x2F;区别
            if(node -&gt; left) que.push(node -&gt; left);
            if(node -&gt; right) que.push(node -&gt; right);
        &#125;
        return res;
    &#125;
&#125;;


&#x2F;&#x2F;完全二叉树 运用特性 分别向左右两边搜索
class Solution &#123;
public:
    int countNodes(TreeNode* root) &#123;
        if(root &#x3D;&#x3D; nullptr) return 0;
        TreeNode* l &#x3D; root -&gt; left;
        TreeNode* r &#x3D; root -&gt; right;
        int ld &#x3D; 0;
        int rd &#x3D; 0;
        while(l)&#123;
            l &#x3D; l -&gt; left;
            ld++;
        &#125;
        while(r)&#123;
            r &#x3D; r -&gt; right;
            rd++;
        &#125;
        if(ld &#x3D;&#x3D; rd) return (2 &lt;&lt; ld) - 1;
        return countNodes(root -&gt; left) + countNodes(root -&gt; right) + 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h4><blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<ul>
<li>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</li>
</ul>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

&#x2F;&#x2F;递归
class Solution &#123;
public:
    bool isBalanced(TreeNode* root)&#123;
        if(root &#x3D;&#x3D; nullptr) return 1;
        return abs(depth(root -&gt; left) - depth(root -&gt; right)) &gt; 1 ? 0 : 1 &amp;&amp; isBalanced(root -&gt; left) &amp;&amp; isBalanced(root -&gt; right);
    &#125;

    int depth(TreeNode * node)&#123;
        if(node &#x3D;&#x3D; nullptr) return 0;
        return max(depth(node -&gt; left) , depth(node -&gt; right)) + 1; 
    &#125;
&#125;;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h4><blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;

&#x2F;&#x2F;递归
class Solution &#123;
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; res;
        vector&lt;int&gt; path;
        if(root &#x3D;&#x3D; nullptr) return res;         
        travle(root , path , res);
        return res;
    &#125;

    void travle(TreeNode* node , vector&lt;int&gt;&amp; path , vector&lt;string&gt;&amp; res)&#123;
        path.push_back(node -&gt; val);
        if(node -&gt; left &#x3D;&#x3D; nullptr &amp;&amp; node -&gt; right &#x3D;&#x3D; nullptr)&#123;
            string sPath;
            for(int i &#x3D; 0 ; i &lt; path.size() - 1 ; i++)&#123;
                sPath +&#x3D; to_string(path[i]);
                sPath +&#x3D; &quot;-&gt;&quot;;
            &#125;
            sPath +&#x3D; to_string(path[path.size() - 1]);
            res.push_back(sPath);
        &#125;
        if(node -&gt; left)&#123;
            travle(node -&gt; left , path , res);
            path.pop_back();
        &#125;
        if(node -&gt; right)&#123;
            travle(node -&gt; right , path , res);
            path.pop_back();
        &#125;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; treeSt;&#x2F;&#x2F; 保存树的遍历节点
        stack&lt;string&gt; pathSt;   &#x2F;&#x2F; 保存遍历路径的节点
        vector&lt;string&gt; result;  &#x2F;&#x2F; 保存最终路径集合
        if (root &#x3D;&#x3D; NULL) return result;
        treeSt.push(root);
        pathSt.push(to_string(root-&gt;val));
        while (!treeSt.empty()) &#123;
            TreeNode* node &#x3D; treeSt.top(); treeSt.pop(); &#x2F;&#x2F; 取出节点 中
            string path &#x3D; pathSt.top();pathSt.pop();    &#x2F;&#x2F; 取出该节点对应的路径
            if (node-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;right &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F; 遇到叶子节点
                result.push_back(path);
            &#125;
            if (node-&gt;right) &#123; &#x2F;&#x2F; 右
                treeSt.push(node-&gt;right);
                pathSt.push(path + &quot;-&gt;&quot; + to_string(node-&gt;right-&gt;val));
            &#125;
            if (node-&gt;left) &#123; &#x2F;&#x2F; 左
                treeSt.push(node-&gt;left);
                pathSt.push(path + &quot;-&gt;&quot; + to_string(node-&gt;left-&gt;val));
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        int res &#x3D; 0;
        leftsum(root, res);
        return res;
    &#125;

    void leftsum(TreeNode* node, int&amp; res)&#123;
        if(node &#x3D;&#x3D; nullptr) return;
        if(node -&gt; left &amp;&amp; (node -&gt; left -&gt; left &#x3D;&#x3D; nullptr &amp;&amp; node -&gt; left -&gt; right &#x3D;&#x3D; nullptr)) &#123;
            res +&#x3D; node -&gt; left -&gt; val;
        &#125;
        leftsum(node -&gt; left, res);
        leftsum(node -&gt; right, res);
    &#125;
&#125;;

class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; NULL) return 0;
        int leftValue &#x3D; 0;
        if (root-&gt;left !&#x3D; NULL &amp;&amp; root-&gt;left-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;left-&gt;right &#x3D;&#x3D; NULL) &#123;
            leftValue &#x3D; root-&gt;left-&gt;val;
        &#125;
        return leftValue + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);
    &#125;
&#125;;

&#x2F;&#x2F;迭代法
class Solution &#123;
public:
    int sumOfLeftLeaves(TreeNode* root) &#123;
        int res &#x3D; 0;
        stack&lt;TreeNode*&gt; st;
        if(root !&#x3D; nullptr) st.push(root);
        while(!st.empty())&#123;
            TreeNode* node &#x3D; st.top();
            st.pop();
            &#x2F;&#x2F; 和统一法对比 这里将标记动作取消了 不需要压入结构集中 可以直接进行逻辑判断 所以if-else也被删除
            if (node-&gt;left !&#x3D; NULL &amp;&amp; node-&gt;left-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node-&gt;left-&gt;right &#x3D;&#x3D; NULL) &#123;
                res +&#x3D; node-&gt;left-&gt;val;
            &#125;
            if(node -&gt; right) st.push(node -&gt; right);
            if(node -&gt; left) st.push(node -&gt; left);
                    
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    int maxDepth &#x3D; INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) &#123;
        if (root-&gt;left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;right &#x3D;&#x3D; NULL) &#123;
            if (depth &gt; maxDepth) &#123;
                maxDepth &#x3D; depth;
                result &#x3D; root-&gt;val;
            &#125;
            return;
        &#125;
        if (root-&gt;left) &#123;
            traversal(root-&gt;left, depth + 1); &#x2F;&#x2F; 隐藏着回溯
        &#125;
        if (root-&gt;right) &#123;
            traversal(root-&gt;right, depth + 1); &#x2F;&#x2F; 隐藏着回溯
        &#125;
        return;
    &#125;
    int findBottomLeftValue(TreeNode* root) &#123;
        traversal(root, 0);
        return result;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    int findBottomLeftValue(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; q;
        int res &#x3D; 0 ;
        if(root !&#x3D; nullptr) q.push(root);
        while(!q.empty())&#123;
            vector&lt;int&gt; level;
            int size &#x3D; q.size();
            for(int i &#x3D; 0 ; i &lt; size ; i++)&#123;
                TreeNode* node &#x3D; q.front();
                q.pop();
                level.push_back(node -&gt; val);
                if(node -&gt; left) q.push(node -&gt; left);
                if(node -&gt; right) q.push(node -&gt; right);
            &#125;
            res &#x3D; level[0];
        &#125; 
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h4><ul>
<li>递归函数参数和返回类型</li>
<li>终止条件</li>
<li>单层递归条件</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
private:
    bool traversal(TreeNode* cur, int count) &#123;
        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count &#x3D;&#x3D; 0) return true; &#x2F;&#x2F; 遇到叶子节点，并且计数为0
        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return false; &#x2F;&#x2F; 遇到叶子节点直接返回

        &#x2F;&#x2F; 左
        if (cur-&gt;left &amp;&amp; traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)) return true;
        &#x2F;&#x2F; 右
        if (cur-&gt;right &amp;&amp; traversal(cur-&gt;right, count - cur-&gt;right-&gt;val)) return true;
     
        return false;
    &#125;

public:
    bool hasPathSum(TreeNode* root, int sum) &#123;
        if (root &#x3D;&#x3D; NULL) return false;
        return traversal(root, sum - root-&gt;val);
    &#125;
&#125;;

&#x2F;&#x2F;精简递归
class Solution &#123;
public:
    bool hasPathSum(TreeNode* root, int sum) &#123;
        if (!root) return false;
        if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum &#x3D;&#x3D; root-&gt;val) &#123;
            return true;
        &#125;
        return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    bool hasPathSum(TreeNode* root, int targetSum) &#123;
        if (root &#x3D;&#x3D; nullptr) return false;
        &#x2F;&#x2F; 此时栈里要放的是pair&lt;节点指针，路径数值&gt;
        stack&lt;pair&lt;TreeNode*, int&gt;&gt; st;
        st.push(pair&lt;TreeNode*, int&gt;(root, root-&gt;val));
        while (!st.empty()) &#123;
            pair&lt;TreeNode*, int&gt; node &#x3D; st.top();
            st.pop();
            &#x2F;&#x2F; 如果该节点是叶子节点了，同时该节点的路径数值等于targetSum，那么就返回true
            if (!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; targetSum &#x3D;&#x3D; node.second) return true;

            &#x2F;&#x2F; 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first-&gt;right) &#123;
                st.push(pair&lt;TreeNode*, int&gt;(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));
            &#125;

            &#x2F;&#x2F; 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first-&gt;left) &#123;
                st.push(pair&lt;TreeNode*, int&gt;(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val));
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    &#x2F;&#x2F; 递归函数不需要返回值，因为我们要遍历整个树
    void traversal(TreeNode* cur, int count) &#123;
        if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 遇到了叶子节点且找到了和为sum的路径
            result.push_back(path);
            return;
        &#125;

        if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return ; &#x2F;&#x2F; 遇到叶子节点而没有找到合适的边，直接返回

        if (cur-&gt;left) &#123; &#x2F;&#x2F; 左 （空节点不遍历）
            path.push_back(cur-&gt;left-&gt;val);
            traversal(cur-&gt;left, count - cur -&gt; left -&gt; val);    &#x2F;&#x2F; 递归 
            path.pop_back();                &#x2F;&#x2F; 回溯
        &#125;
        if (cur-&gt;right) &#123; &#x2F;&#x2F; 右 （空节点不遍历）
            path.push_back(cur-&gt;right-&gt;val);
            traversal(cur-&gt;right, count - cur -&gt; right -&gt; val);  &#x2F;&#x2F; 递归
            path.pop_back();                &#x2F;&#x2F; 回溯
        &#125;
        return ;
    &#125;

public:
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;
        result.clear();
        path.clear();
        if (root &#x3D;&#x3D; nullptr) return result;
        path.push_back(root-&gt;val); &#x2F;&#x2F; 把根节点放进路径
        traversal(root, targetSum - root-&gt;val);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    TreeNode* traversal (vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        if (postorder.size() &#x3D;&#x3D; 0) return NULL;

        &#x2F;&#x2F; 后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue &#x3D; postorder[postorder.size() - 1];
        TreeNode* root &#x3D; new TreeNode(rootValue);

        &#x2F;&#x2F; 叶子节点
        if (postorder.size() &#x3D;&#x3D; 1) return root;

        &#x2F;&#x2F; 找到中序遍历的切割点
        int delimiterIndex;
        for (delimiterIndex &#x3D; 0; delimiterIndex &lt; inorder.size(); delimiterIndex++) &#123;
            if (inorder[delimiterIndex] &#x3D;&#x3D; rootValue) break;
        &#125;

        &#x2F;&#x2F; 切割中序数组
        &#x2F;&#x2F; 左闭右开区间：[0, delimiterIndex)
        vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        &#x2F;&#x2F; [delimiterIndex + 1, end)
        vector&lt;int&gt; rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );

        &#x2F;&#x2F; postorder 舍弃末尾元素
        postorder.resize(postorder.size() - 1);

        &#x2F;&#x2F; 切割后序数组
        &#x2F;&#x2F; 依然左闭右开，注意这里使用了左中序数组大小作为切割点
        &#x2F;&#x2F; [0, leftInorder.size)
        vector&lt;int&gt; leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        &#x2F;&#x2F; [leftInorder.size(), end)
        vector&lt;int&gt; rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        root-&gt;left &#x3D; traversal(leftInorder, leftPostorder);
        root-&gt;right &#x3D; traversal(rightInorder, rightPostorder);

        return root;
    &#125;
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        if (inorder.size() &#x3D;&#x3D; 0 || postorder.size() &#x3D;&#x3D; 0) return NULL;
        return traversal(inorder, postorder);
    &#125;
&#125;;

&#x2F;&#x2F;优化
class Solution &#123;
private:
    &#x2F;&#x2F; 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)
    TreeNode* traversal (vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd, vector&lt;int&gt;&amp; postorder, int postorderBegin, int postorderEnd) &#123;
        if (postorderBegin &#x3D;&#x3D; postorderEnd) return NULL;

        int rootValue &#x3D; postorder[postorderEnd - 1];
        TreeNode* root &#x3D; new TreeNode(rootValue);

        if (postorderEnd - postorderBegin &#x3D;&#x3D; 1) return root;

        int delimiterIndex;
        for (delimiterIndex &#x3D; inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;
            if (inorder[delimiterIndex] &#x3D;&#x3D; rootValue) break;
        &#125;
        &#x2F;&#x2F; 切割中序数组
        &#x2F;&#x2F; 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin &#x3D; inorderBegin;
        int leftInorderEnd &#x3D; delimiterIndex;
        &#x2F;&#x2F; 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin &#x3D; delimiterIndex + 1;
        int rightInorderEnd &#x3D; inorderEnd;

        &#x2F;&#x2F; 切割后序数组
        &#x2F;&#x2F; 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin &#x3D;  postorderBegin;
        int leftPostorderEnd &#x3D; postorderBegin + delimiterIndex - inorderBegin; &#x2F;&#x2F; 终止位置是 需要加上 中序区间的大小size
        &#x2F;&#x2F; 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin &#x3D; postorderBegin + delimiterIndex - inorderBegin;
        int rightPostorderEnd &#x3D; postorderEnd - 1; &#x2F;&#x2F; 排除最后一个元素，已经作为节点了

        root-&gt;left &#x3D; traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root-&gt;right &#x3D; traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);

        return root;
    &#125;
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        if (inorder.size() &#x3D;&#x3D; 0 || postorder.size() &#x3D;&#x3D; 0) return NULL;
        &#x2F;&#x2F; 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    &#x2F;&#x2F; 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) &#123;
        if (left &gt;&#x3D; right) return nullptr;

        &#x2F;&#x2F; 分割点下标：maxValueIndex
        int maxValueIndex &#x3D; left;
        for (int i &#x3D; left + 1; i &lt; right; ++i) &#123;
            if (nums[i] &gt; nums[maxValueIndex]) maxValueIndex &#x3D; i;
        &#125;

        TreeNode* root &#x3D; new TreeNode(nums[maxValueIndex]);

        &#x2F;&#x2F; 左闭右开：[left, maxValueIndex)
        root-&gt;left &#x3D; traversal(nums, left, maxValueIndex);

        &#x2F;&#x2F; 左闭右开：[maxValueIndex + 1, right)
        root-&gt;right &#x3D; traversal(nums, maxValueIndex + 1, right);

        return root;
    &#125;
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;
        return traversal(nums, 0, nums.size());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;
        return Traver(root1, root2);
    &#125;

    TreeNode* Traver(TreeNode* node1, TreeNode* node2)&#123;
        if(node1 &#x3D;&#x3D; nullptr) return node2;
        if(node2 &#x3D;&#x3D; nullptr) return node1;
        node1 -&gt; val +&#x3D; node2 -&gt; val;
        node1 -&gt; left &#x3D; Traver(node1 -&gt; left, node2 -&gt; left);
        node1 -&gt; right &#x3D; Traver(node1 -&gt; right, node2 -&gt; right);
        return node1;
    &#125;
&#125;;

&#x2F;&#x2F;迭代法 类似 [101. 对称二叉树] 的做法 将2个节点同时入队 同时取出对比
class Solution &#123;
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
        if (t1 &#x3D;&#x3D; NULL) return t2;
        if (t2 &#x3D;&#x3D; NULL) return t1;
        queue&lt;TreeNode*&gt; que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) &#123;
            TreeNode* node1 &#x3D; que.front(); que.pop();
            TreeNode* node2 &#x3D; que.front(); que.pop();
            &#x2F;&#x2F; 此时两个节点一定不为空，val相加
            node1-&gt;val +&#x3D; node2-&gt;val;

            &#x2F;&#x2F; 如果两棵树左节点都不为空，加入队列
            if (node1-&gt;left !&#x3D; NULL &amp;&amp; node2-&gt;left !&#x3D; NULL) &#123;
                que.push(node1-&gt;left);
                que.push(node2-&gt;left);
            &#125;
            &#x2F;&#x2F; 如果两棵树右节点都不为空，加入队列
            if (node1-&gt;right !&#x3D; NULL &amp;&amp; node2-&gt;right !&#x3D; NULL) &#123;
                que.push(node1-&gt;right);
                que.push(node2-&gt;right);
            &#125;

            &#x2F;&#x2F; 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (node1-&gt;left &#x3D;&#x3D; NULL &amp;&amp; node2-&gt;left !&#x3D; NULL) &#123;
                node1-&gt;left &#x3D; node2-&gt;left;
            &#125;
            &#x2F;&#x2F; 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (node1-&gt;right &#x3D;&#x3D; NULL &amp;&amp; node2-&gt;right !&#x3D; NULL) &#123;
                node1-&gt;right &#x3D; node2-&gt;right;
            &#125;
        &#125;
        return t1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        if (root &#x3D;&#x3D; NULL || root-&gt;val &#x3D;&#x3D; val) return root;
        if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val);
        if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val);
        return NULL;
    &#125;
&#125;;

&#x2F;&#x2F;迭代法 不用像之前那样全部遍历 利用二叉树的有序性来进行遍历减少复杂度
class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        while (root !&#x3D; NULL) &#123;
            if (root-&gt;val &gt; val) root &#x3D; root-&gt;left;
            else if (root-&gt;val &lt; val) root &#x3D; root-&gt;right;
            else return root;
        &#125;
        return NULL;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>二叉搜索树中序遍历时 得到的结果必然是单调递增的</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    TreeNode* pre &#x3D; NULL; &#x2F;&#x2F; 用来记录前一个节点
    bool isValidBST(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; NULL) return true;
        bool left &#x3D; isValidBST(root-&gt;left);

        if (pre !&#x3D; NULL &amp;&amp; pre-&gt;val &gt;&#x3D; root-&gt;val) return false;
        pre &#x3D; root; &#x2F;&#x2F; 记录前一个节点

        bool right &#x3D; isValidBST(root-&gt;right);
        return left &amp;&amp; right;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    bool isValidBST(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur &#x3D; root;
        TreeNode* pre &#x3D; NULL; &#x2F;&#x2F; 记录前一个节点
        while (cur !&#x3D; NULL || !st.empty()) &#123;
            if (cur !&#x3D; NULL) &#123;
                st.push(cur);
                cur &#x3D; cur-&gt;left;                &#x2F;&#x2F; 左
            &#125; else &#123;
                cur &#x3D; st.top();                 &#x2F;&#x2F; 中
                st.pop();
                if (pre !&#x3D; NULL &amp;&amp; cur-&gt;val &lt;&#x3D; pre-&gt;val)
                return false;
                pre &#x3D; cur; &#x2F;&#x2F;保存前一个访问的结点

                cur &#x3D; cur-&gt;right;               &#x2F;&#x2F; 右
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4><p>基本和上面那题一样 都是利用二叉搜索树中序遍历的特性比较</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    int maxn &#x3D; INT_MAX;
    TreeNode* pre &#x3D; nullptr;
    int getMinimumDifference(TreeNode* root) &#123;
        if(root &#x3D;&#x3D; nullptr) return 0;

        getMinimumDifference(root -&gt; left);

        if(pre !&#x3D; nullptr &amp;&amp; abs(root -&gt; val - pre -&gt; val) &lt; maxn) maxn &#x3D; abs(root -&gt; val - pre -&gt; val);
        pre &#x3D; root;

        getMinimumDifference(root -&gt; right);

        return maxn;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    int getMinimumDifference(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur &#x3D; root;
        TreeNode* pre &#x3D; NULL;
        int result &#x3D; INT_MAX;
        while (cur !&#x3D; NULL || !st.empty()) &#123;
            if (cur !&#x3D; NULL) &#123; &#x2F;&#x2F; 指针来访问节点，访问到最底层
                st.push(cur); &#x2F;&#x2F; 将访问的节点放进栈
                cur &#x3D; cur-&gt;left;                &#x2F;&#x2F; 左
            &#125; else &#123;
                cur &#x3D; st.top();
                st.pop();
                if (pre !&#x3D; NULL) &#123;              &#x2F;&#x2F; 中
                    result &#x3D; min(result, cur-&gt;val - pre-&gt;val);
                &#125;
                pre &#x3D; cur;
                cur &#x3D; cur-&gt;right;               &#x2F;&#x2F; 右
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4><p>本质上和上题也无区别 关键在于对结果集的更新</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
private:
    int maxCount &#x3D; 0; &#x2F;&#x2F; 最大频率
    int count &#x3D; 0; &#x2F;&#x2F; 统计频率
    TreeNode* pre &#x3D; NULL;
    vector&lt;int&gt; result;
    void searchBST(TreeNode* cur) &#123;
        if (cur &#x3D;&#x3D; NULL) return ;

        searchBST(cur-&gt;left);       &#x2F;&#x2F; 左
                                    &#x2F;&#x2F; 中
        if (pre &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F; 第一个节点
            count &#x3D; 1;
        &#125; else if (pre-&gt;val &#x3D;&#x3D; cur-&gt;val) &#123; &#x2F;&#x2F; 与前一个节点数值相同
            count++;
        &#125; else &#123; &#x2F;&#x2F; 与前一个节点数值不同
            count &#x3D; 1;
        &#125;
        pre &#x3D; cur; &#x2F;&#x2F; 更新上一个节点

        if (count &#x3D;&#x3D; maxCount) &#123; &#x2F;&#x2F; 如果和最大值相同，放进result中
            result.push_back(cur-&gt;val);
        &#125;

        if (count &gt; maxCount) &#123; &#x2F;&#x2F; 如果计数大于最大值频率
            maxCount &#x3D; count;   &#x2F;&#x2F; 更新最大频率
            result.clear();     &#x2F;&#x2F; 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur-&gt;val);
        &#125;

        searchBST(cur-&gt;right);      &#x2F;&#x2F; 右
        return ;
    &#125;

public:
    vector&lt;int&gt; findMode(TreeNode* root) &#123;
        count &#x3D; 0;
        maxCount &#x3D; 0;
        TreeNode* pre &#x3D; NULL; &#x2F;&#x2F; 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    vector&lt;int&gt; findMode(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur &#x3D; root;
        TreeNode* pre &#x3D; NULL;
        int maxCount &#x3D; 0; &#x2F;&#x2F; 最大频率
        int count &#x3D; 0; &#x2F;&#x2F; 统计频率
        vector&lt;int&gt; result;
        while (cur !&#x3D; NULL || !st.empty()) &#123;
            if (cur !&#x3D; NULL) &#123; &#x2F;&#x2F; 指针来访问节点，访问到最底层
                st.push(cur); &#x2F;&#x2F; 将访问的节点放进栈
                cur &#x3D; cur-&gt;left;                &#x2F;&#x2F; 左
            &#125; else &#123;
                cur &#x3D; st.top();
                st.pop();                       &#x2F;&#x2F; 中
                if (pre &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F; 第一个节点
                    count &#x3D; 1;
                &#125; else if (pre-&gt;val &#x3D;&#x3D; cur-&gt;val) &#123; &#x2F;&#x2F; 与前一个节点数值相同
                    count++;
                &#125; else &#123; &#x2F;&#x2F; 与前一个节点数值不同
                    count &#x3D; 1;
                &#125;
                if (count &#x3D;&#x3D; maxCount) &#123; &#x2F;&#x2F; 如果和最大值相同，放进result中
                    result.push_back(cur-&gt;val);
                &#125;

                if (count &gt; maxCount) &#123; &#x2F;&#x2F; 如果计数大于最大值频率
                    maxCount &#x3D; count;   &#x2F;&#x2F; 更新最大频率
                    result.clear();     &#x2F;&#x2F; 很关键的一步，不要忘记清空result，之前result里的元素都失效了
                    result.push_back(cur-&gt;val);
                &#125;
                pre &#x3D; cur;
                cur &#x3D; cur-&gt;right;               &#x2F;&#x2F; 右
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if (root &#x3D;&#x3D; q || root &#x3D;&#x3D; p || root &#x3D;&#x3D; NULL) return root;
        TreeNode* left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);
        if (left !&#x3D; NULL &amp;&amp; right !&#x3D; NULL) return root;
        if (left &#x3D;&#x3D; NULL) return right;
        return left;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4><p>本质和上面差不多 区别在于可以通过root落不落在区间[p,q]内来减少复杂度</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 递归
class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;
            return lowestCommonAncestor(root-&gt;left, p, q);
        &#125; else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;
            return lowestCommonAncestor(root-&gt;right, p, q);
        &#125; else return root;
    &#125;
&#125;;

&#x2F;&#x2F; 迭代
class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        while(root) &#123;
            if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;
                root &#x3D; root-&gt;left;
            &#125; else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;
                root &#x3D; root-&gt;right;
            &#125; else return root;
        &#125;
        return NULL;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
        if (root &#x3D;&#x3D; NULL) &#123;
            TreeNode* node &#x3D; new TreeNode(val);
            return node;
        &#125;
        if (root-&gt;val &gt; val) root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);
        if (root-&gt;val &lt; val) root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);
        return root;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;
        if (root &#x3D;&#x3D; NULL) &#123;
            TreeNode* node &#x3D; new TreeNode(val);
            return node;
        &#125;
        TreeNode* cur &#x3D; root;
        TreeNode* parent &#x3D; root; &#x2F;&#x2F; 这个很重要，需要记录上一个节点，否则无法赋值新节点
        while (cur !&#x3D; NULL) &#123;
            parent &#x3D; cur;
            if (cur-&gt;val &gt; val) cur &#x3D; cur-&gt;left;
            else cur &#x3D; cur-&gt;right;
        &#125;
        TreeNode* node &#x3D; new TreeNode(val);
        if (val &lt; parent-&gt;val) parent-&gt;left &#x3D; node;&#x2F;&#x2F; 此时是用parent节点的进行赋值
        else parent-&gt;right &#x3D; node;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归 分情况讨论 5种
class Solution &#123;
public:
    TreeNode* deleteNode(TreeNode* root, int key) &#123;
        if (root &#x3D;&#x3D; nullptr) return root; &#x2F;&#x2F; 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root-&gt;val &#x3D;&#x3D; key) &#123;
            &#x2F;&#x2F; 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;
                &#x2F;&#x2F;&#x2F;! 内存释放
                delete root;
                return nullptr;
            &#125;
            &#x2F;&#x2F; 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root-&gt;left &#x3D;&#x3D; nullptr) &#123;
                auto retNode &#x3D; root-&gt;right;
                &#x2F;&#x2F;&#x2F;! 内存释放
                delete root;
                return retNode;
            &#125;
            &#x2F;&#x2F; 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root-&gt;right &#x3D;&#x3D; nullptr) &#123;
                auto retNode &#x3D; root-&gt;left;
                &#x2F;&#x2F;&#x2F;! 内存释放
                delete root;
                return retNode;
            &#125;
            &#x2F;&#x2F; 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            &#x2F;&#x2F; 并返回删除节点右孩子为新的根节点。
            else &#123;
                TreeNode* cur &#x3D; root-&gt;right; &#x2F;&#x2F; 找右子树最左面的节点
                while(cur-&gt;left !&#x3D; nullptr) &#123;
                    cur &#x3D; cur-&gt;left;
                &#125;
                cur-&gt;left &#x3D; root-&gt;left; &#x2F;&#x2F; 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp &#x3D; root;   &#x2F;&#x2F; 把root节点保存一下，下面来删除
                root &#x3D; root-&gt;right;     &#x2F;&#x2F; 返回旧root的右孩子作为新root
                delete tmp;             &#x2F;&#x2F; 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            &#125;
        &#125;
        if (root-&gt;val &gt; key) root-&gt;left &#x3D; deleteNode(root-&gt;left, key);
        if (root-&gt;val &lt; key) root-&gt;right &#x3D; deleteNode(root-&gt;right, key);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;
        if (root &#x3D;&#x3D; nullptr) return nullptr;
        if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);
        if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);
        root-&gt;left &#x3D; trimBST(root-&gt;left, low, high);
        root-&gt;right &#x3D; trimBST(root-&gt;right, low, high);
        return root;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) &#123;
        if (!root) return nullptr;

        &#x2F;&#x2F; 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭
        while (root !&#x3D; nullptr &amp;&amp; (root-&gt;val &lt; L || root-&gt;val &gt; R)) &#123;
            if (root-&gt;val &lt; L) root &#x3D; root-&gt;right; &#x2F;&#x2F; 小于L往右走
            else root &#x3D; root-&gt;left; &#x2F;&#x2F; 大于R往左走
        &#125;
        TreeNode *cur &#x3D; root;
        &#x2F;&#x2F; 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况
        while (cur !&#x3D; nullptr) &#123;
            while (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; L) &#123;
                cur-&gt;left &#x3D; cur-&gt;left-&gt;right;
            &#125;
            cur &#x3D; cur-&gt;left;
        &#125;
        cur &#x3D; root;

        &#x2F;&#x2F; 此时root已经在[L, R] 范围内，处理右孩子大于R的情况
        while (cur !&#x3D; nullptr) &#123;
            while (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt; R) &#123;
                cur-&gt;right &#x3D; cur-&gt;right-&gt;left;
            &#125;
            cur &#x3D; cur-&gt;right;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><p>和之前的构造二叉树一样 关键是找到分割点  平衡二叉树即为数组中点为中心即可</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
private:
    TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) &#123;
        if (left &gt; right) return nullptr;
        int mid &#x3D; left + ((right - left) &#x2F; 2);
        TreeNode* root &#x3D; new TreeNode(nums[mid]);
        root-&gt;left &#x3D; traversal(nums, left, mid - 1);
        root-&gt;right &#x3D; traversal(nums, mid + 1, right);
        return root;
    &#125;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        TreeNode* root &#x3D; traversal(nums, 0, nums.size() - 1);
        return root;
    &#125;
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &#x3D;&#x3D; 0) return nullptr;

        TreeNode* root &#x3D; new TreeNode(0);   &#x2F;&#x2F; 初始根节点
        queue&lt;TreeNode*&gt; nodeQue;           &#x2F;&#x2F; 放遍历的节点
        queue&lt;int&gt; leftQue;                 &#x2F;&#x2F; 保存左区间下标
        queue&lt;int&gt; rightQue;                &#x2F;&#x2F; 保存右区间下标
        nodeQue.push(root);                 &#x2F;&#x2F; 根节点入队列
        leftQue.push(0);                    &#x2F;&#x2F; 0为左区间下标初始位置
        rightQue.push(nums.size() - 1);     &#x2F;&#x2F; nums.size() - 1为右区间下标初始位置

        while (!nodeQue.empty()) &#123;
            TreeNode* curNode &#x3D; nodeQue.front();
            nodeQue.pop();
            int left &#x3D; leftQue.front(); leftQue.pop();
            int right &#x3D; rightQue.front(); rightQue.pop();
            int mid &#x3D; left + ((right - left) &#x2F; 2);

            curNode-&gt;val &#x3D; nums[mid];       &#x2F;&#x2F; 将mid对应的元素给中间节点

            if (left &lt;&#x3D; mid - 1) &#123;          &#x2F;&#x2F; 处理左区间
                curNode-&gt;left &#x3D; new TreeNode(0);
                nodeQue.push(curNode-&gt;left);
                leftQue.push(left);
                rightQue.push(mid - 1);
            &#125;

            if (right &gt;&#x3D; mid + 1) &#123;         &#x2F;&#x2F; 处理右区间
                curNode-&gt;right &#x3D; new TreeNode(0);
                nodeQue.push(curNode-&gt;right);
                leftQue.push(mid + 1);
                rightQue.push(right);
            &#125;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>其实和之前的 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a> 和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a> 类似 都是通过二叉树<strong>中序遍历有序递增</strong>的特性</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 递归
class Solution &#123;
private:
    int pre &#x3D; 0; &#x2F;&#x2F; 记录前一个节点的数值
    void traversal(TreeNode* cur) &#123; &#x2F;&#x2F; 右中左遍历
        if (cur &#x3D;&#x3D; NULL) return;
        traversal(cur-&gt;right);
        cur-&gt;val +&#x3D; pre;
        pre &#x3D; cur-&gt;val;
        traversal(cur-&gt;left);
    &#125;
public:
    TreeNode* convertBST(TreeNode* root) &#123;
        pre &#x3D; 0;
        traversal(root);
        return root;
    &#125;
&#125;;

&#x2F;&#x2F; 迭代
class Solution &#123;
private:
    int pre; &#x2F;&#x2F; 记录前一个节点的数值
    void traversal(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur &#x3D; root;
        while (cur !&#x3D; NULL || !st.empty()) &#123;
            if (cur !&#x3D; NULL) &#123;
                st.push(cur);
                cur &#x3D; cur-&gt;right;   &#x2F;&#x2F; 右
            &#125; else &#123;
                cur &#x3D; st.top();     &#x2F;&#x2F; 中
                st.pop();
                cur-&gt;val +&#x3D; pre;
                pre &#x3D; cur-&gt;val;
                cur &#x3D; cur-&gt;left;    &#x2F;&#x2F; 左
            &#125;
        &#125;
    &#125;
public:
    TreeNode* convertBST(TreeNode* root) &#123;
        pre &#x3D; 0;
        traversal(root);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a><strong><u>二叉树总结</u></strong></h4><ul>
<li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li>
<li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li>
<li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li>
</ul>
<p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，<a target="_blank" rel="noopener" href="https://programmercarl.com/0257.二叉树的所有路径.html">二叉树：找所有路径 (opens new window)</a>也用了前序，这是为了方便让父节点指向子节点。</p>
<p>所以求普通二叉树的属性还是要具体问题具体分析。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211030125421.png" alt="img"></p>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void backtracking(参数) &#123;
    if (终止条件) &#123;
        存放结果;
        return;
    &#125;

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;
        处理节点;
        backtracking(路径，选择列表); &#x2F;&#x2F; 递归
        回溯，撤销处理结果
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result; &#x2F;&#x2F; 存放符合条件结果的集合
    vector&lt;int&gt; path; &#x2F;&#x2F; 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) &#123;
        if (path.size() &#x3D;&#x3D; k) &#123;
            result.push_back(path);
            return;
        &#125;
        &#x2F;&#x2F;这里的  i &lt;&#x3D; n - (k - path.size()) + 1 为剪枝叶 当后续的数量不满足组合数时无需递归
        for (int i &#x3D; startIndex;  i &lt;&#x3D; n - (k - path.size()) + 1; i++) &#123;
            path.push_back(i); &#x2F;&#x2F; 处理节点 
            backtracking(n, k, i + 1); &#x2F;&#x2F; 递归
            path.pop_back(); &#x2F;&#x2F; 回溯，撤销处理的节点
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        result.clear(); &#x2F;&#x2F; 可以不写
        path.clear();   &#x2F;&#x2F; 可以不写
        backtracking(n, k, 1);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;
        res.clear();
        path.clear();
        backtracking(k, n, 1, 0);
        return res;
    &#125;
private:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    int sum;
    void backtracking(int k, int n, int startIndex, int sum)&#123;
        if(sum &#x3D;&#x3D; n &amp;&amp; path.size() &#x3D;&#x3D; k)&#123;
            res.push_back(path);
            return;
        &#125;
        if(sum &gt; k &amp;&amp; path.size() &#x3D;&#x3D; k)&#123;
            return;
        &#125;
        for(int i &#x3D; startIndex ; i &lt;&#x3D; 10 - (k - path.size()) ; i++ )&#123;
            path.push_back(i);
            sum +&#x3D; i;
            backtracking(k, n, i + 1,sum);
            sum -&#x3D; i;
            path.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;string&gt; letterCombinations(string digits) &#123;
        res.clear();
        path.clear();
        if(digits.size() &#x3D;&#x3D; 0) return res;
        backtracking(digits, 0);
        return res;
    &#125;

private:
    const string letterMap[10] &#x3D; &#123;
        &quot;&quot;, &#x2F;&#x2F; 0
        &quot;&quot;, &#x2F;&#x2F; 1
        &quot;abc&quot;, &#x2F;&#x2F; 2
        &quot;def&quot;, &#x2F;&#x2F; 3
        &quot;ghi&quot;, &#x2F;&#x2F; 4
        &quot;jkl&quot;, &#x2F;&#x2F; 5
        &quot;mno&quot;, &#x2F;&#x2F; 6
        &quot;pqrs&quot;, &#x2F;&#x2F; 7
        &quot;tuv&quot;, &#x2F;&#x2F; 8
        &quot;wxyz&quot;, &#x2F;&#x2F; 9
    &#125;;
    vector&lt;string&gt; res;
    string path;
    void backtracking(string digits, int startIndex) &#123;
        if(path.size() &#x3D;&#x3D; digits.size())&#123;
            res.push_back(path);
            return;
        &#125;
        string cur &#x3D; letterMap[digits[startIndex] - &#39;0&#39;];
        for(int i &#x3D; 0 ; i &lt; cur.size() ; i++)&#123;
            path.push_back(cur[i]);
            backtracking(digits, startIndex + 1);
            path.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
        res.clear();
        path.clear();
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return res;
    &#125;

private:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt; candidates, int target, int sum, int startIndex)&#123;
        if(sum &#x3D;&#x3D; target)&#123;
            res.push_back(path);
            return;
        &#125;
        &#x2F;&#x2F;在下一层一定为大于target直接不进入递归 
        for(int i &#x3D; startIndex ; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target ; i++)&#123;
            path.push_back(candidates[i]);
            sum +&#x3D; candidates[i];
            backtracking(candidates, target, sum, i);  &#x2F;&#x2F;不再是i + 1 代表可以重复选取
            sum -&#x3D; candidates[i];
            path.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h4><p>分清 “同一树层” 和 “同一树枝”</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 使用 used数组 来明确哪些数字在同一数层使用过 此时不能再取
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        res.clear();
        path.clear();
        vector&lt;bool&gt; used(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return res;
    &#125;

private:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt; candidates, int target, int sum, int startIndex, vector&lt;bool&gt; used)&#123;
        if(sum &#x3D;&#x3D; target)&#123;
            res.push_back(path);
            return;
        &#125;
        for(int i &#x3D; startIndex ; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target ; i++)&#123;
            if (i &gt; 0 &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;
                continue;
            &#125;
            path.push_back(candidates[i]);
            sum +&#x3D; candidates[i];
            used[i] &#x3D; true;
            backtracking(candidates, target, sum, i + 1, used);  
            used[i] &#x3D; false;
            sum -&#x3D; candidates[i];
            path.pop_back();
        &#125;
    &#125;
&#125;;
&#x2F;&#x2F; 使用 startIndex 代替 used数组
class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex) &#123;
        if (sum &#x3D;&#x3D; target) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i &#x3D; startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;&#x3D; target; i++) &#123;
            &#x2F;&#x2F; 要对同一树层使用过的元素进行跳过
            if (i &gt; startIndex &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1]) &#123;
                continue;
            &#125;
            sum +&#x3D; candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i + 1); &#x2F;&#x2F; 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            sum -&#x3D; candidates[i];
            path.pop_back();
        &#125;
    &#125;

public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        path.clear();
        result.clear();
        &#x2F;&#x2F; 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0);
        return result;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; path; &#x2F;&#x2F; 放已经回文的子串
    void backtracking (const string&amp; s, int startIndex) &#123;
        &#x2F;&#x2F; 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex &gt;&#x3D; s.size()) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i &#x3D; startIndex; i &lt; s.size(); i++) &#123;
            if (isPalindrome(s, startIndex, i)) &#123;   &#x2F;&#x2F; 是回文子串
                &#x2F;&#x2F; 获取[startIndex,i]在s中的子串
                string str &#x3D; s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            &#125; else &#123;                                &#x2F;&#x2F; 不是回文，跳过
                continue;
            &#125;
            backtracking(s, i + 1); &#x2F;&#x2F; 寻找i+1为起始位置的子串
            path.pop_back(); &#x2F;&#x2F; 回溯过程，弹出本次已经填在的子串
        &#125;
    &#125;
    bool isPalindrome(const string&amp; s, int start, int end) &#123;
        for (int i &#x3D; start, j &#x3D; end; i &lt; j; i++, j--) &#123;
            if (s[i] !&#x3D; s[j]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        result.clear();
        path.clear();
        backtracking(s, 0);
        return result;
    &#125;
&#125;;

&#x2F;&#x2F;利用动规判断回文串
class Solution &#123;
private:
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; path; &#x2F;&#x2F; 放已经回文的子串
    vector&lt;vector&lt;bool&gt;&gt; isPalindrome; &#x2F;&#x2F; 放事先计算好的是否回文子串的结果
    void backtracking (const string&amp; s, int startIndex) &#123;
        &#x2F;&#x2F; 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex &gt;&#x3D; s.size()) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i &#x3D; startIndex; i &lt; s.size(); i++) &#123;
            if (isPalindrome[startIndex][i]) &#123;   &#x2F;&#x2F; 是回文子串
                &#x2F;&#x2F; 获取[startIndex,i]在s中的子串
                string str &#x3D; s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            &#125; else &#123;                                &#x2F;&#x2F; 不是回文，跳过
                continue;
            &#125;
            backtracking(s, i + 1); &#x2F;&#x2F; 寻找i+1为起始位置的子串
            path.pop_back(); &#x2F;&#x2F; 回溯过程，弹出本次已经填在的子串
        &#125;
    &#125;
    void computePalindrome(const string&amp; s) &#123;
        &#x2F;&#x2F; isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 
        isPalindrome.resize(s.size(), vector&lt;bool&gt;(s.size(), false)); &#x2F;&#x2F; 根据字符串s, 刷新布尔矩阵的大小
        for (int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; i--) &#123; 
            &#x2F;&#x2F; 需要倒序计算, 保证在i行时, i+1行已经计算好了
            for (int j &#x3D; i; j &lt; s.size(); j++) &#123;
                if (j &#x3D;&#x3D; i) &#123;isPalindrome[i][j] &#x3D; true;&#125;
                else if (j - i &#x3D;&#x3D; 1) &#123;isPalindrome[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]);&#125;
                else &#123;isPalindrome[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j] &amp;&amp; isPalindrome[i+1][j-1]);&#125;
            &#125;
        &#125;
    &#125;
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        result.clear();
        path.clear();
        computePalindrome(s);
        backtracking(s, 0);
        return result;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    vector&lt;string&gt; result;
    void backtracking(string&amp; s, int startIndex, int pointNum) &#123;
        if (pointNum &#x3D;&#x3D; 3) &#123; &#x2F;&#x2F; 逗点数量为3时，分隔结束
            &#x2F;&#x2F; 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) &#123;
                result.push_back(s);
            &#125;
            return;
        &#125;
        for (int i &#x3D; startIndex; i &lt; s.size(); i++) &#123;
            if (isValid(s, startIndex, i)) &#123; &#x2F;&#x2F; 判断 [startIndex,i] 这个区间的子串是否合法
                s.insert(s.begin() + i + 1 , &#39;.&#39;);  &#x2F;&#x2F; 在i的后面插入一个逗点
                pointNum++;
                backtracking(s, i + 2, pointNum);   &#x2F;&#x2F; 插入逗点之后下一个子串的起始位置为i+2
                pointNum--;                         &#x2F;&#x2F; 回溯
                s.erase(s.begin() + i + 1);         &#x2F;&#x2F; 回溯删掉逗点
            &#125; else break; &#x2F;&#x2F; 不合法，直接结束本层循环
        &#125;
    &#125;
    &#x2F;&#x2F; 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
    bool isValid(const string&amp; s, int start, int end) &#123;
        if (start &gt; end) &#123;
            return false;
        &#125;
        if (s[start] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; start !&#x3D; end) &#123; &#x2F;&#x2F; 0开头的数字不合法
                return false;
        &#125;
        int num &#x3D; 0;
        for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;
            if (s[i] &gt; &#39;9&#39; || s[i] &lt; &#39;0&#39;) &#123; &#x2F;&#x2F; 遇到非数字字符不合法
                return false;
            &#125;
            num &#x3D; num * 10 + (s[i] - &#39;0&#39;);
            if (num &gt; 255) &#123; &#x2F;&#x2F; 如果大于255了不合法
                return false;
            &#125;
        &#125;
        return true;
    &#125;
public:
    vector&lt;string&gt; restoreIpAddresses(string s) &#123;
        result.clear();
        if (s.size() &lt; 4 || s.size() &gt; 12) return result; &#x2F;&#x2F; 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;
        result.push_back(path); &#x2F;&#x2F; 收集子集，要放在终止添加的上面，否则会漏掉自己
        if (startIndex &gt;&#x3D; nums.size()) &#123; &#x2F;&#x2F; 终止条件可以不加
            return;
        &#125;
        for (int i &#x3D; startIndex; i &lt; nums.size(); i++) &#123;
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;
        res.clear();
        path.clear();
        vector&lt;bool&gt; used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, 0, used);
        return res;
    &#125;

private:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex, vector&lt;bool&gt;&amp; used)&#123;
        res.push_back(path);
        for(int i &#x3D; startIndex ; i &lt; nums.size() ; i++)&#123;
            if(i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false)&#123;
                continue;
            &#125;
            path.push_back(nums[i]);
            used[i] &#x3D; true;
            backtracking(nums, i + 1, used);
            used[i] &#x3D; false;
            path.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;
        if (path.size() &gt; 1) &#123;
            result.push_back(path);
            &#x2F;&#x2F; 注意这里不要加return，要取树上的节点
        &#125;
        unordered_set&lt;int&gt; uset; &#x2F;&#x2F; 使用set对本层元素进行去重
        for (int i &#x3D; startIndex; i &lt; nums.size(); i++) &#123;
            if ((!path.empty() &amp;&amp; nums[i] &lt; path.back())
                    || uset.find(nums[i]) !&#x3D; uset.end()) &#123;
                    continue;
            &#125;
            uset.insert(nums[i]); &#x2F;&#x2F; 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    &#125;
&#125;;

&#x2F;&#x2F;数组做哈希
class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;
        if (path.size() &gt; 1) &#123;
            result.push_back(path);
        &#125;
        int used[201] &#x3D; &#123;0&#125;; &#x2F;&#x2F; 这里使用数组来进行去重操作，题目说数值范围[-100, 100]
        for (int i &#x3D; startIndex; i &lt; nums.size(); i++) &#123;
            if ((!path.empty() &amp;&amp; nums[i] &lt; path.back())
                    || used[nums[i] + 100] &#x3D;&#x3D; 1) &#123;
                    continue;
            &#125;
            used[nums[i] + 100] &#x3D; 1; &#x2F;&#x2F; 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h4><p>排列问题的特殊：</p>
<ul>
<li>每层都是从0开始搜索而不是startIndex</li>
<li>需要used数组记录path里都放了哪些元素了</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) &#123;
        &#x2F;&#x2F; 此时说明找到了一组
        if (path.size() &#x3D;&#x3D; nums.size()) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            if (used[i] &#x3D;&#x3D; true) continue; &#x2F;&#x2F; path里已经收录的元素，直接跳过
            used[i] &#x3D; true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] &#x3D; false;
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        vector&lt;bool&gt; used(nums.size(), false);
        backtracking(nums, used);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) &#123;
        &#x2F;&#x2F; 此时说明找到了一组
        if (path.size() &#x3D;&#x3D; nums.size()) &#123;
            result.push_back(path);
            return;
        &#125;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; true，说明同一树枝nums[i - 1]使用过
            &#x2F;&#x2F; used[i - 1] &#x3D;&#x3D; false，说明同一树层nums[i - 1]使用过 
            &#x2F;&#x2F; 如果同一树层nums[i - 1]使用过则直接跳过
            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;
                continue;
            &#125;
            if (used[i] &#x3D;&#x3D; false) &#123;
                used[i] &#x3D; true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] &#x3D; false;
            &#125;
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); &#x2F;&#x2F; 排序
        vector&lt;bool&gt; used(nums.size(), false);
        backtracking(nums, used);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></h4><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html#%E5%9B%9E%E6%BA%AF%E6%B3%95">代码随想录</a></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
&#x2F;&#x2F; unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets
unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;
bool backtracking(int ticketNum, vector&lt;string&gt;&amp; result) &#123;
    if (result.size() &#x3D;&#x3D; ticketNum + 1) &#123;
        return true;
    &#125;
    for (pair&lt;const string, int&gt;&amp; target : targets[result[result.size() - 1]]) &#123;
        if (target.second &gt; 0 ) &#123; &#x2F;&#x2F; 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            if (backtracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
        &#125;
    &#125;
    return false;
&#125;
public:
    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;
        targets.clear();
        vector&lt;string&gt; result;
        for (const vector&lt;string&gt;&amp; vec : tickets) &#123;
            targets[vec[0]][vec[1]]++; &#x2F;&#x2F; 记录映射关系
        &#125;
        result.push_back(&quot;JFK&quot;); &#x2F;&#x2F; 起始机场
        backtracking(tickets.size(), result);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h4><p><strong>棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
vector&lt;vector&lt;string&gt;&gt; result;
&#x2F;&#x2F; n 为输入的棋盘大小
&#x2F;&#x2F; row 是当前递归到棋盘的第几行了
void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;
    if (row &#x3D;&#x3D; n) &#123;
        result.push_back(chessboard);
        return;
    &#125;
    for (int col &#x3D; 0; col &lt; n; col++) &#123;
        if (isValid(row, col, chessboard, n)) &#123; &#x2F;&#x2F; 验证合法就可以放
            chessboard[row][col] &#x3D; &#39;Q&#39;; &#x2F;&#x2F; 放置皇后
            backtracking(n, row + 1, chessboard);
            chessboard[row][col] &#x3D; &#39;.&#39;; &#x2F;&#x2F; 回溯，撤销皇后
        &#125;
    &#125;
&#125;
bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;
    &#x2F;&#x2F; 检查列
    for (int i &#x3D; 0; i &lt; row; i++) &#123; &#x2F;&#x2F; 这是一个剪枝
        if (chessboard[i][col] &#x3D;&#x3D; &#39;Q&#39;) &#123;
            return false;
        &#125;
    &#125;
    &#x2F;&#x2F; 检查 45度角是否有皇后
    for (int i &#x3D; row - 1, j &#x3D; col - 1; i &gt;&#x3D;0 &amp;&amp; j &gt;&#x3D; 0; i--, j--) &#123;
        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;
            return false;
        &#125;
    &#125;
    &#x2F;&#x2F; 检查 135度角是否有皇后
    for(int i &#x3D; row - 1, j &#x3D; col + 1; i &gt;&#x3D; 0 &amp;&amp; j &lt; n; i--, j++) &#123;
        if (chessboard[i][j] &#x3D;&#x3D; &#39;Q&#39;) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;
        result.clear();
        std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));
        backtracking(n, 0, chessboard);
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h4><p>二维递归</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html">代码随想录</a></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
bool backtracking(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
    for (int i &#x3D; 0; i &lt; board.size(); i++) &#123;        &#x2F;&#x2F; 遍历行
        for (int j &#x3D; 0; j &lt; board[0].size(); j++) &#123; &#x2F;&#x2F; 遍历列
            if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;
                for (char k &#x3D; &#39;1&#39;; k &lt;&#x3D; &#39;9&#39;; k++) &#123;     &#x2F;&#x2F; (i, j) 这个位置放k是否合适
                    if (isValid(i, j, k, board)) &#123;
                        board[i][j] &#x3D; k;                &#x2F;&#x2F; 放置k
                        if (backtracking(board)) return true; &#x2F;&#x2F; 如果找到合适一组立刻返回
                        board[i][j] &#x3D; &#39;.&#39;;              &#x2F;&#x2F; 回溯，撤销k
                    &#125;
                &#125;
                return false;  &#x2F;&#x2F; 9个数都试完了，都不行，那么就返回false 
            &#125;                
        &#125;
    &#125;
    return true; &#x2F;&#x2F; 遍历完没有返回false，说明找到了合适棋盘位置了
&#125;
bool isValid(int row, int col, char val, vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
    for (int i &#x3D; 0; i &lt; 9; i++) &#123; &#x2F;&#x2F; 判断行里是否重复
        if (board[row][i] &#x3D;&#x3D; val) &#123;
            return false;
        &#125;
    &#125;
    for (int j &#x3D; 0; j &lt; 9; j++) &#123; &#x2F;&#x2F; 判断列里是否重复
        if (board[j][col] &#x3D;&#x3D; val) &#123;
            return false;
        &#125;
    &#125;
    int startRow &#x3D; (row &#x2F; 3) * 3;
    int startCol &#x3D; (col &#x2F; 3) * 3;
    for (int i &#x3D; startRow; i &lt; startRow + 3; i++) &#123; &#x2F;&#x2F; 判断9方格里是否重复
        for (int j &#x3D; startCol; j &lt; startCol + 3; j++) &#123;
            if (board[i][j] &#x3D;&#x3D; val ) &#123;
                return false;
            &#125;
        &#125;
    &#125;
    return true;
&#125;
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        backtracking(board);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="回溯总结"><a href="#回溯总结" class="headerlink" title="回溯总结"></a><strong><u>回溯总结</u></strong></h4><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211030124742.png" alt="img"></p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"></p>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p>这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。</p>
<p>做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。</p>
<h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int index &#x3D; 0;
        for(int i &#x3D; 0; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 饼干
            if(index &lt; g.size() &amp;&amp; g[index] &lt;&#x3D; s[i])&#123; &#x2F;&#x2F; 胃口
                index++;
            &#125;
        &#125;
        return index;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &lt;&#x3D; 1) return nums.size();
        int curDiff &#x3D; 0; &#x2F;&#x2F; 当前一对差值
        int preDiff &#x3D; 0; &#x2F;&#x2F; 前一对差值
        int result &#x3D; 1;  &#x2F;&#x2F; 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i &#x3D; 0; i &lt; nums.size() - 1; i++) &#123;
            curDiff &#x3D; nums[i + 1] - nums[i];
            &#x2F;&#x2F; 出现峰值
            if ((preDiff &lt;&#x3D; 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;&#x3D; 0 &amp;&amp; curDiff &lt; 0)) &#123;
                result++;
                preDiff &#x3D; curDiff; &#x2F;&#x2F; 注意这里，只在摆动变化的时候更新prediff 
            &#125;
        &#125;
        return result;
    &#125;
&#125;;
&#x2F;&#x2F; X
&#x2F;&#x2F;dp
class Solution &#123;
public:
    int dp[1005][2];
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;
        memset(dp, 0, sizeof dp);
        dp[0][0] &#x3D; dp[0][1] &#x3D; 1;
        for (int i &#x3D; 1; i &lt; nums.size(); ++i) &#123;
            dp[i][0] &#x3D; dp[i][1] &#x3D; 1;
            for (int j &#x3D; 0; j &lt; i; ++j) &#123;
                if (nums[j] &gt; nums[i]) dp[i][1] &#x3D; max(dp[i][1], dp[j][0] + 1);
            &#125;
            for (int j &#x3D; 0; j &lt; i; ++j) &#123;
                if (nums[j] &lt; nums[i]) dp[i][0] &#x3D; max(dp[i][0], dp[j][1] + 1);
            &#125;
        &#125;
        return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int result &#x3D; INT32_MIN;
        int count &#x3D; 0;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            count +&#x3D; nums[i];
            if (count &gt; result) &#123; &#x2F;&#x2F; 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result &#x3D; count;
            &#125;
            if (count &lt;&#x3D; 0) count &#x3D; 0; &#x2F;&#x2F; 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><p>局部利润最大推全局利润最大</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int result &#x3D; 0;
        for (int i &#x3D; 1; i &lt; prices.size(); i++) &#123;
            result +&#x3D; max(prices[i] - prices[i - 1], 0);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool canJump(vector&lt;int&gt;&amp; nums) &#123;
        int cover &#x3D; 0;
        if (nums.size() &#x3D;&#x3D; 1) return true; &#x2F;&#x2F; 只有一个元素，就是能达到
        for (int i &#x3D; 0; i &lt;&#x3D; cover; i++) &#123; &#x2F;&#x2F; 注意这里是小于等于cover
            cover &#x3D; max(i + nums[i], cover);
            if (cover &gt;&#x3D; nums.size() - 1) return true; &#x2F;&#x2F; 说明可以覆盖到终点了
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int jump(vector&lt;int&gt;&amp; nums) &#123;
        int curDistance &#x3D; 0;    &#x2F;&#x2F; 当前覆盖的最远距离下标
        int ans &#x3D; 0;            &#x2F;&#x2F; 记录走的最大步数
        int nextDistance &#x3D; 0;   &#x2F;&#x2F; 下一步覆盖的最远距离下标
        for (int i &#x3D; 0; i &lt; nums.size() - 1; i++) &#123; &#x2F;&#x2F; 注意这里是小于nums.size() - 1，这是关键所在
            nextDistance &#x3D; max(nums[i] + i, nextDistance); &#x2F;&#x2F; 更新下一步覆盖的最远距离下标
            if (i &#x3D;&#x3D; curDistance) &#123;                 &#x2F;&#x2F; 遇到当前覆盖的最远距离下标
                curDistance &#x3D; nextDistance;         &#x2F;&#x2F; 更新当前覆盖的最远距离下标
                ans++;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
static bool cmp(int a, int b) &#123;
    return abs(a) &gt; abs(b);
&#125;
public:
    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;
        sort(A.begin(), A.end(), cmp);       &#x2F;&#x2F; 第一步
        for (int i &#x3D; 0; i &lt; A.size(); i++) &#123; &#x2F;&#x2F; 第二步
            if (A[i] &lt; 0 &amp;&amp; K &gt; 0) &#123;
                A[i] *&#x3D; -1;
                K--;
            &#125;
        &#125;
        if (K % 2 &#x3D;&#x3D; 1) A[A.size() - 1] *&#x3D; -1; &#x2F;&#x2F; 第三步
        int result &#x3D; 0;
        for (int a : A) result +&#x3D; a;        &#x2F;&#x2F; 第四步
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h4><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%96%B9%E6%B3%95%E4%BA%8C">代码随想录</a></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int curSum &#x3D; 0;
        int totalSum &#x3D; 0;
        int start &#x3D; 0;
        for (int i &#x3D; 0; i &lt; gas.size(); i++) &#123;
            curSum +&#x3D; gas[i] - cost[i];
            totalSum +&#x3D; gas[i] - cost[i];
            if (curSum &lt; 0) &#123;   &#x2F;&#x2F; 当前累加rest[i]和 curSum一旦小于0
                start &#x3D; i + 1;  &#x2F;&#x2F; 起始位置更新为i+1
                curSum &#x3D; 0;     &#x2F;&#x2F; curSum从0开始
            &#125;
        &#125;
        if (totalSum &lt; 0) return -1; &#x2F;&#x2F; 说明怎么走都不可能跑一圈了
        return start;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int candy(vector&lt;int&gt;&amp; ratings) &#123;
        vector&lt;int&gt; candyVec(ratings.size(), 1);
        &#x2F;&#x2F; 从前向后
        for (int i &#x3D; 1; i &lt; ratings.size(); i++) &#123;
            if (ratings[i] &gt; ratings[i - 1]) candyVec[i] &#x3D; candyVec[i - 1] + 1;
        &#125;
        &#x2F;&#x2F; 从后向前
        for (int i &#x3D; ratings.size() - 2; i &gt;&#x3D; 0; i--) &#123;
            if (ratings[i] &gt; ratings[i + 1] ) &#123;
                candyVec[i] &#x3D; max(candyVec[i], candyVec[i + 1] + 1);
            &#125;
        &#125;
        &#x2F;&#x2F; 统计结果
        int result &#x3D; 0;
        for (int i &#x3D; 0; i &lt; candyVec.size(); i++) result +&#x3D; candyVec[i];
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;
        int five &#x3D; 0, ten &#x3D; 0, twenty &#x3D; 0;
        for (int bill : bills) &#123;
            &#x2F;&#x2F; 情况一
            if (bill &#x3D;&#x3D; 5) five++;
            &#x2F;&#x2F; 情况二
            if (bill &#x3D;&#x3D; 10) &#123;
                if (five &lt;&#x3D; 0) return false;
                ten++;
                five--;
            &#125;
            &#x2F;&#x2F; 情况三
            if (bill &#x3D;&#x3D; 20) &#123;
                &#x2F;&#x2F; 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
                if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123;
                    five--;
                    ten--;
                    twenty++; &#x2F;&#x2F; 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零
                &#125; else if (five &gt;&#x3D; 3) &#123;
                    five -&#x3D; 3;
                    twenty++; &#x2F;&#x2F; 同理，这行代码也可以删了
                &#125; else return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;数组
class Solution &#123;
public:
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        if (a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];
        return a[0] &gt; b[0];
    &#125;
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;
        sort (people.begin(), people.end(), cmp);
        vector&lt;vector&lt;int&gt;&gt; que;
        for (int i &#x3D; 0; i &lt; people.size(); i++) &#123;
            int position &#x3D; people[i][1];
            que.insert(que.begin() + position, people[i]);
        &#125;
        return que;
    &#125;
&#125;;

&#x2F;&#x2F;链表
class Solution &#123;
public:
    &#x2F;&#x2F; 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        if (a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];
        return a[0] &gt; b[0];
    &#125;
    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;
        sort (people.begin(), people.end(), cmp);
        list&lt;vector&lt;int&gt;&gt; que; &#x2F;&#x2F; list底层是链表实现，插入效率比vector高的多
        for (int i &#x3D; 0; i &lt; people.size(); i++) &#123;
            int position &#x3D; people[i][1]; &#x2F;&#x2F; 插入到下标为position的位置
            std::list&lt;vector&lt;int&gt;&gt;::iterator it &#x3D; que.begin();
            while (position--) &#123; &#x2F;&#x2F; 寻找在插入位置
                it++;
            &#125;
            que.insert(it, people[i]);
        &#125;
        return vector&lt;vector&lt;int&gt;&gt;(que.begin(), que.end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        return a[0] &lt; b[0];
    &#125;
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;
        if (points.size() &#x3D;&#x3D; 0) return 0;
        sort(points.begin(), points.end(), cmp);

        int result &#x3D; 1; &#x2F;&#x2F; points 不为空至少需要一支箭
        for (int i &#x3D; 1; i &lt; points.size(); i++) &#123;
            if (points[i][0] &gt; points[i - 1][1]) &#123;  &#x2F;&#x2F; 气球i和气球i-1不挨着，注意这里不是&gt;&#x3D;
                result++; &#x2F;&#x2F; 需要一支箭
            &#125;
            else &#123;  &#x2F;&#x2F; 气球i和气球i-1挨着
                points[i][1] &#x3D; min(points[i - 1][1], points[i][1]); &#x2F;&#x2F; 更新重叠气球最小右边界
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    static bool cmp (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;
        return a[0] &lt; b[0]; &#x2F;&#x2F; 改为左边界排序
    &#125;
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        if (intervals.size() &#x3D;&#x3D; 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int count &#x3D; 0; &#x2F;&#x2F; 注意这里从0开始，因为是记录重叠区间
        for (int i &#x3D; 1; i &lt; intervals.size(); i++) &#123;
            if (intervals[i][0] &lt; intervals[i - 1][1]) &#123; &#x2F;&#x2F;重叠情况
                intervals[i][1] &#x3D; min(intervals[i - 1][1], intervals[i][1]);
                count++;
            &#125;
        &#125;
        return count;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; partitionLabels(string S) &#123;
        int hash[27] &#x3D; &#123;0&#125;; &#x2F;&#x2F; i为字符，hash[i]为字符出现的最后位置
        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123; &#x2F;&#x2F; 统计每一个字符最后出现的位置
            hash[S[i] - &#39;a&#39;] &#x3D; i;
        &#125;
        vector&lt;int&gt; result;
        int left &#x3D; 0;
        int right &#x3D; 0;
        for (int i &#x3D; 0; i &lt; S.size(); i++) &#123;
            right &#x3D; max(right, hash[S[i] - &#39;a&#39;]); &#x2F;&#x2F; 找到字符出现的最远边界
            if (i &#x3D;&#x3D; right) &#123;
                result.push_back(right - left + 1);
                left &#x3D; i + 1;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        vector&lt;vector&lt;int&gt;&gt; result;
        if (intervals.size() &#x3D;&#x3D; 0) return result; &#x2F;&#x2F; 区间集合为空直接返回
        &#x2F;&#x2F; 排序的参数使用了lambda表达式
        sort(intervals.begin(), intervals.end(), [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b)&#123;return a[0] &lt; b[0];&#125;);

        &#x2F;&#x2F; 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并
        result.push_back(intervals[0]); 

        for (int i &#x3D; 1; i &lt; intervals.size(); i++) &#123;
            if (result.back()[1] &gt;&#x3D; intervals[i][0]) &#123; &#x2F;&#x2F; 发现重叠区间
                &#x2F;&#x2F; 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的
                result.back()[1] &#x3D; max(result.back()[1], intervals[i][1]); 
            &#125; else &#123;
                result.push_back(intervals[i]); &#x2F;&#x2F; 区间不重叠 
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int monotoneIncreasingDigits(int N) &#123;
        string strNum &#x3D; to_string(N);
        &#x2F;&#x2F; flag用来标记赋值9从哪里开始
        &#x2F;&#x2F; 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag &#x3D; strNum.size();
        for (int i &#x3D; strNum.size() - 1; i &gt; 0; i--) &#123;
            if (strNum[i - 1] &gt; strNum[i] ) &#123;
                flag &#x3D; i;
                strNum[i - 1]--;
            &#125;
        &#125;
        for (int i &#x3D; flag; i &lt; strNum.size(); i++) &#123;
            strNum[i] &#x3D; &#39;9&#39;;
        &#125;
        return stoi(strNum);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 0：该节点无覆盖
&#x2F;&#x2F; 1：本节点有摄像头
&#x2F;&#x2F; 2：本节点有覆盖
class Solution &#123;
private:
    int result;
    int traversal(TreeNode* cur) &#123;

        &#x2F;&#x2F; 空节点，该节点有覆盖
        if (cur &#x3D;&#x3D; NULL) return 2;

        int left &#x3D; traversal(cur-&gt;left);    &#x2F;&#x2F; 左
        int right &#x3D; traversal(cur-&gt;right);  &#x2F;&#x2F; 右

        &#x2F;&#x2F; 情况1
        &#x2F;&#x2F; 左右节点都有覆盖
        if (left &#x3D;&#x3D; 2 &amp;&amp; right &#x3D;&#x3D; 2) return 0;

        &#x2F;&#x2F; 情况2
        &#x2F;&#x2F; left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0 左右节点无覆盖
        &#x2F;&#x2F; left &#x3D;&#x3D; 1 &amp;&amp; right &#x3D;&#x3D; 0 左节点有摄像头，右节点无覆盖
        &#x2F;&#x2F; left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 1 左节点有无覆盖，右节点摄像头
        &#x2F;&#x2F; left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 2 左节点无覆盖，右节点覆盖
        &#x2F;&#x2F; left &#x3D;&#x3D; 2 &amp;&amp; right &#x3D;&#x3D; 0 左节点覆盖，右节点无覆盖
        if (left &#x3D;&#x3D; 0 || right &#x3D;&#x3D; 0) &#123;
            result++;
            return 1;
        &#125;

        &#x2F;&#x2F; 情况3
        &#x2F;&#x2F; left &#x3D;&#x3D; 1 &amp;&amp; right &#x3D;&#x3D; 2 左节点有摄像头，右节点有覆盖
        &#x2F;&#x2F; left &#x3D;&#x3D; 2 &amp;&amp; right &#x3D;&#x3D; 1 左节点有覆盖，右节点有摄像头
        &#x2F;&#x2F; left &#x3D;&#x3D; 1 &amp;&amp; right &#x3D;&#x3D; 1 左右节点都有摄像头
        &#x2F;&#x2F; 其他情况前段代码均已覆盖
        if (left &#x3D;&#x3D; 1 || right &#x3D;&#x3D; 1) return 2;

        &#x2F;&#x2F; 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解
        &#x2F;&#x2F; 这个 return -1 逻辑不会走到这里。
        return -1;
    &#125;

public:
    int minCameraCover(TreeNode* root) &#123;
        result &#x3D; 0;
        &#x2F;&#x2F; 情况4
        if (traversal(root) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; root 无覆盖
            result++;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="贪心总结"><a href="#贪心总结" class="headerlink" title="贪心总结"></a><strong><u>贪心总结</u></strong></h4><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%B4%AA%E5%BF%83%E6%80%BB%E7%BB%93water.png" alt="img"></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>解题步骤：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    int fib(int n) &#123;
        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return n;
        return fib(n - 1) + fib(n - 2);
    &#125;
&#125;;

&#x2F;&#x2F;dp
class Solution &#123;
public:
    int fib(int n) &#123;
        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return n;
        int a[n+1];
        a[0] &#x3D; 0;
        a[1] &#x3D; 1;
        for( int i &#x3D; 2 ; i &lt;&#x3D; n ; i++)&#123;
            a[i] &#x3D; a[i - 2] + a[i - 1];
        &#125;
        return a[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int climbStairs(int n) &#123;
        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return 1;
        int a[n+1];
        a[0] &#x3D; 1;
        a[1] &#x3D; 1;
        for( int i &#x3D; 2 ; i &lt;&#x3D; n ; i++)&#123;
            a[i] &#x3D; a[i - 2] + a[i - 1];
        &#125;
        return a[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4><p>递推公式不要被前面几道带偏了</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;
        int n &#x3D; cost.size();
        if(n &#x3D;&#x3D; 1) return cost[0];
        if(n &#x3D;&#x3D; 2) return min(cost[0], cost[1]);
        int a[n + 1];
        a[0] &#x3D; 0;
        a[1] &#x3D; 0;
        for(int i &#x3D; 2 ; i &lt;&#x3D; n; i++)&#123;
            a[i] &#x3D; min(a[i - 1] + cost[i - 1], a[i - 2] + cost[i - 2]);
        &#125; 
        return a[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><p>注意初始化</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution  
public:
    int uniquePaths(int m, int n) &#123;
        int dp[m][n];
        for(int i &#x3D; 0 ; i &lt; m ; ++i) dp[i][0] &#x3D; 1;
        for(int i &#x3D; 0 ; i &lt; n ; ++i) dp[0][i] &#x3D; 1;
        for(int i &#x3D; 1 ; i &lt; m ; ++i)&#123;
            for(int j &#x3D; 1 ; j &lt; n ; ++j)&#123;
                dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];
            &#125;
        &#125;
        return dp[m - 1][n - 1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h4><p>用vector申请可以更简洁</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
        int m &#x3D; obstacleGrid.size();
        int n &#x3D; obstacleGrid[0].size();
        if(obstacleGrid[m - 1][n - 1]) return 0;
        int dp[m][n];

        bool flag &#x3D; 0;
        for (int i &#x3D; 0 ; i &lt; m ; ++i) &#123;
            if(obstacleGrid[i][0]) &#123;
                dp[i][0] &#x3D; 0;
                flag &#x3D; 1;
            &#125;
            else if(flag &#x3D;&#x3D; 1) dp[i][0] &#x3D; 0;
            else dp[i][0] &#x3D; 1; 
        &#125;

        flag &#x3D; 0;
        for (int i &#x3D; 0 ; i &lt; n ; ++i) &#123;
            if(obstacleGrid[0][i]) &#123;
                dp[0][i] &#x3D; 0;
                flag &#x3D; 1;
            &#125;
            else if(flag &#x3D;&#x3D; 1) dp[0][i] &#x3D; 0;
            else dp[0][i] &#x3D; 1; 
        &#125;

        for(int i &#x3D; 1 ; i &lt; m ; ++i)&#123;
            for(int j &#x3D; 1 ; j &lt; n ; ++j)&#123;
                if(obstacleGrid[i][j]) dp[i][j] &#x3D; 0;
                else dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];
            &#125;
        &#125;
        return dp[m - 1][n - 1];
    &#125;
&#125;;

&#x2F;&#x2F;vector
class Solution &#123;
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
      	int m &#x3D; obstacleGrid.size();
        int n &#x3D; obstacleGrid[0].size();
	 	if(obstacleGrid[m - 1][n - 1] &#x3D;&#x3D; 1 || obstacleGrid[0][0] &#x3D;&#x3D; 1)  return 0;           
        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
        for (int i &#x3D; 0; i &lt; m &amp;&amp; obstacleGrid[i][0] &#x3D;&#x3D; 0; i++) dp[i][0] &#x3D; 1;
        for (int j &#x3D; 0; j &lt; n &amp;&amp; obstacleGrid[0][j] &#x3D;&#x3D; 0; j++) dp[0][j] &#x3D; 1;
        for (int i &#x3D; 1; i &lt; m; i++) &#123;
            for (int j &#x3D; 1; j &lt; n; j++) &#123;
                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) continue;
                dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];
            &#125;
        &#125;
        return dp[m - 1][n - 1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="X343-整数拆分"><a href="#X343-整数拆分" class="headerlink" title="X343. 整数拆分"></a>X<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h4><p>推导公式的理解很重要</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int integerBreak(int n) &#123;
        vector&lt;int&gt; dp(n + 1);
        dp[2] &#x3D; 1;
        for (int i &#x3D; 3; i &lt;&#x3D; n ; i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j++) &#123;
                dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));
            &#125;
        &#125;
        return dp[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="X96-不同的二叉搜索树"><a href="#X96-不同的二叉搜索树" class="headerlink" title="X96. 不同的二叉搜索树"></a>X<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int numTrees(int n) &#123;
        vector&lt;int&gt; dp(n + 1);
        dp[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;
                dp[i] +&#x3D; dp[j - 1] * dp[i - j];
            &#125;
        &#125;
        return dp[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h4><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p>
<h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01<u>背包</u></h4><h5 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a><strong>二维dp</strong></h5><p><strong>1.定义</strong>: dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p><strong>2.递推:</strong> dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] +value[i])</p>
<p><strong>3.初始化</strong>:  </p>
<ul>
<li>背包容量为0时， 最大价值肯定为 0：dp[i][0] = 0 </li>
<li>当背包容量为j时：进行判断，若j &lt; weight[0] 则dp[0][j] = 0 否则 dp[0][j] = value[0];</li>
</ul>
<p><strong>4.遍历顺序推导</strong>  先遍历物品还是先遍历背包重量都可以,但是先遍历物品更好理解。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; weight数组的大小 就是物品个数
for(int j &#x3D; 0; j &lt;&#x3D; bagweight; j++) &#123; &#x2F;&#x2F; 遍历背包容量
    for(int i &#x3D; 1; i &lt; weight.size(); i++) &#123; &#x2F;&#x2F; 遍历物品
        if (j &lt; weight[i]) dp[i][j] &#x3D; dp[i - 1][j];
        else dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="一维dp-滚动数组"><a href="#一维dp-滚动数组" class="headerlink" title="一维dp 滚动数组"></a><strong>一维dp 滚动数组</strong></h5><p><strong>1.定义</strong>：dp[j]为 容量为j的背包所背的最大价值</p>
<p><strong>2.递推</strong>：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</p>
<p><strong>3.初始化</strong>：</p>
<ul>
<li><p>dp[0] = 0</p>
</li>
<li><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。dp[j] = 0</p>
</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(int i &#x3D; 0; i &lt; weight.size(); i++) &#123; &#x2F;&#x2F; 遍历物品
    for(int j &#x3D; bagWeight; j &gt;&#x3D; weight[i]; j--) &#123; &#x2F;&#x2F; 遍历背包容量
        dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p>
<p>如果正序遍历</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
</blockquote>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h4><p>能凑到一半就代表可以分割</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; dp(10001, 0);
        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 &#x3D;&#x3D; 1) return false;
        int target &#x3D; sum &#x2F; 2;

        for(int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            for(int j &#x3D; target; j &gt;&#x3D; nums[i]; j--) &#123; 
                dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);
            &#125;
        &#125;
    
        if (dp[target] &#x3D;&#x3D; target) return true;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;
        vector&lt;int&gt; dp(1501,0);
        int sum &#x3D; accumulate(stones.begin(),stones.end(),0);
        int target &#x3D; sum&#x2F;2;
        for(int i &#x3D; 0 ; i &lt; stones.size() ; i++)&#123;
            for(int j &#x3D; target ; j &gt;&#x3D; stones[i] ; j--)&#123;
                dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);
            &#125;
        &#125;
        return sum - dp[target] - dp[target];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h4><blockquote>
<p>本题要如何使表达式结果为target，</p>
<p>设前面是+的总和为left -的总和为right（abs）</p>
<p>既然为target，那么就一定有 left组合 - right组合 = target。</p>
<p>left + right = sum，而sum是固定的。right = sum - left</p>
<p>公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。</p>
<p>target是固定的，sum是固定的，left就可以求出来。</p>
<p>此时问题就是在集合nums中找出和为left的组合</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p>
</blockquote>
<p>则对应题目为 bagsize = （target + sum）/ 2  ; 当target + sum % 2 == 1 时，无方案；当abs（s） &gt; sum 时候，也无方案</p>
<p> <strong>1.定义：</strong> dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p>
<p><strong>2.递推公式：</strong> 组合类公式：<strong>dp[j] += dp[j - nums[i]]</strong></p>
<p><strong>3.初始化：</strong>dp[0] = 1 dp[j] = 0</p>
<p><strong>4.遍历顺序：</strong>nums放在外循环，target在内循环，且内循环倒序。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;
        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);
        if(abs(target) &gt; sum || (target + sum) % 2 &#x3D;&#x3D; 1) return 0;
        int bagsize &#x3D; (target + sum) &#x2F; 2 ;
        vector&lt;int&gt; dp(bagsize + 1, 0);
        dp[0] &#x3D; 1;
        for(int i &#x3D; 0 ; i &lt; nums.size() ; i++)&#123;
            for(int j &#x3D; bagsize ; j &gt;&#x3D; nums[i] ; j--)&#123;
                dp[j] +&#x3D; dp[j - nums[i]];
            &#125;
        &#125;
        return dp[bagsize];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h4><p><strong>1.定义：</strong> dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</p>
<p><strong>2.递推公式：</strong> dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)</p>
<p><strong>3.初始化：</strong> dp[i][j] = 0</p>
<p><strong>4.遍历顺序：</strong> 先遍历集合每个元素 然后再进入dp遍历，内外可以交换</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
        for(string x : strs)&#123;
            int zeroNum &#x3D; 0;
            int oneNum &#x3D; 0;
            for(char y : x)&#123;
                if(y &#x3D;&#x3D; &#39;0&#39;) zeroNum++;
                if(y &#x3D;&#x3D; &#39;1&#39;) oneNum++;
            &#125;
            for(int i &#x3D; m ; i &gt;&#x3D; zeroNum ; --i)&#123;
                for(int j &#x3D; n ; j &gt;&#x3D; oneNum ; --j)&#123;
                    dp[i][j] &#x3D; max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                &#125;
            &#125;
        &#125;
        return dp[m][n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="01背包总结"><a href="#01背包总结" class="headerlink" title="01背包总结"></a>01<strong>背包总结</strong></h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">纯 0 - 1 背包 (opens new window)</a>是求 给定背包容量 装满背包 的最大价值是多少。</li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">416. 分割等和子集</a>是求 给定背包容量，能不能装满这个背包。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a>是求 给定背包容量，尽可能装，最多能装多少</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494. 目标和</a>是求 给定背包容量，装满背包有多少种方法。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a>是求 给定背包容量，装满背包最多有多少个物品。</li>
</ul>
</blockquote>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><u>完全背包</u></h4><p>首先在回顾一下01背包的核心代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> bagWeight<span class="token punctuation">;</span> j <span class="token operator">>=</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>
        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 先遍历物品，再遍历背包</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> bagWeight <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>
        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</strong></p>
<p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p>
</blockquote>
<h4 id="518-零钱兑换-II—组合"><a href="#518-零钱兑换-II—组合" class="headerlink" title="518. 零钱兑换 II—组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a>—组合</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;
        vector&lt;int&gt; dp(amount + 1, 0);
        dp[0] &#x3D; 1;
        for(int i &#x3D; 0 ; i &lt; coins.size() ; ++i)&#123;   &#x2F;&#x2F;物品
            for(int j &#x3D; coins[i] ; j &lt;&#x3D; amount ; ++j)&#123; &#x2F;&#x2F;背包
                dp[j] +&#x3D; dp[j - coins[i]];
            &#125;
        &#125;
        return dp[amount];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="377-组合总和-Ⅳ-—排列"><a href="#377-组合总和-Ⅳ-—排列" class="headerlink" title="377. 组合总和 Ⅳ —排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a> —排列</h4><p>只要搞到nums[i] ，凑成dp[j]就有dp[i - nums[j]] 种方法。</p>
<blockquote>
<p>即：如何让容量为i的背包装满？答案是在当前物品为nums[j]重时，容量还剩下i - nums[j]的背包</p>
<p>那么对应让i背包装满的方法就是每个物品对应的i - nums[j]的方法数量之和</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;int&gt; dp(target + 1, 0);
        dp[0] &#x3D; 1;
        for (int i &#x3D; 0; i &lt;&#x3D; target; i++) &#123; &#x2F;&#x2F; 背包
            for (int j &#x3D; 0; j &lt; nums.size(); j++) &#123; &#x2F;&#x2F; 物品
                &#x2F;&#x2F;C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] &lt; INT_MAX - dp[i - num]
                if (i - nums[j] &gt;&#x3D; 0 &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123; 
                    dp[i] +&#x3D; dp[i - nums[j]];
                &#125;
            &#125;
        &#125;
        return dp[target];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>{1, 3} == {3, 1}:  如果求<strong>组合</strong>数就是<strong>外层</strong>for循环遍历<strong>物品</strong>，<strong>内层</strong>for遍历<strong>背包</strong>。内层的 j = nums[i]</p>
<p>{1, 3} != {3, 1}:  如果求<strong>排列</strong>数就是<strong>外层</strong>for遍历<strong>背包</strong>，<strong>内层</strong>for循环遍历<strong>物品</strong>。内层的 j = 0</p>
</blockquote>
<h4 id="70-爬楼梯—完全背包写法—排列"><a href="#70-爬楼梯—完全背包写法—排列" class="headerlink" title="70. 爬楼梯—完全背包写法—排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a>—完全背包写法—排列</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int climbStairs(int n) &#123;
        vector&lt;int&gt; dp(n + 1, 0);
        dp[0] &#x3D; 1;
        for(int i &#x3D; 0 ; i &lt;&#x3D; n; ++i)&#123;  &#x2F;&#x2F;背包
            for(int j &#x3D; 1 ; j &lt;&#x3D; 2 ; ++j)&#123;    &#x2F;&#x2F;物品
                if (i - j &gt;&#x3D; 0) dp[i] +&#x3D; dp[i - j]; 
            &#125;
        &#125;
        return dp[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>内层循环的2可以改成m m为一次能踏多少个阶梯 </p>
</blockquote>
<h4 id="322-零钱兑换—求最小值"><a href="#322-零钱兑换—求最小值" class="headerlink" title="322. 零钱兑换—求最小值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>—求最小值</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;
        vector&lt;int&gt; dp(amount + 1, INT_MAX);
        dp[0] &#x3D; 0;
        for(int i &#x3D; 0 ; i &lt; coins.size() ; i++)&#123;
            for(int j &#x3D; coins[i] ; j &lt;&#x3D; amount ; j++)&#123;
                if(dp[j - coins[i]] &#x3D;&#x3D; INT_MAX) continue;  &#x2F;&#x2F; 证明根本凑不到j - coins[i]这个数字的金额 直接跳过
                dp[j] &#x3D; min(dp[j], dp[j - coins[i]] + 1);
            &#125;
        &#125;
        return dp[amount] &#x3D;&#x3D; INT_MAX ? -1 : dp[amount];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>内外循环可交换</p>
</blockquote>
<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int numSquares(int n) &#123;
        vector&lt;int&gt; dp(n + 1, INT_MAX);
        dp[0] &#x3D; 0;
        for(int i &#x3D; 0 ; i &lt;&#x3D; n ; i++)&#123;
            for(int j &#x3D; 1 ; j*j &lt;&#x3D; i ; j++)&#123;
                &#x2F;&#x2F;if(dp[i - j*j] &#x3D;&#x3D; INT_MAX) continue;
                dp[i] &#x3D; min(dp[i], dp[i - j*j] + 1);
            &#125;
        &#125;
        return dp[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>内外循环可交换</p>
</blockquote>
<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h4><p><strong>1.定义：</strong> dp[i] 代表i以前的字符串是否都可以用字典里面的单词拼接出来</p>
<p><strong>2.递推公式：</strong> if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j] == true) dp[i] = true</p>
<p><strong>3.初始化：</strong> dp[0] = true 其他为false</p>
<p><strong>4.遍历顺序:</strong> 如上方总结，此为 <strong>排列</strong> 有顺序要求 所以<strong>先物品再背包</strong> </p>
<p>其中内层比较特殊 他是类似双指针的右指针，和i一起指定一段长度的字符串</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;
        vector&lt;bool&gt; dp(s.size() + 1, false);
        dp[0] &#x3D; true;
        unordered_set set(wordDict.begin(), wordDict.end());
        for(int i &#x3D; 1 ; i &lt;&#x3D; s.size() ; i++)&#123;
            for(int j &#x3D; 0 ; j &lt; i ; j++)&#123;
                string word &#x3D; s.substr(j, i - j);
                if(set.find(word) !&#x3D; set.end() &amp;&amp; dp[j] &#x3D;&#x3D; true) dp[i] &#x3D; true;
            &#125;
        &#125;
        return dp[s.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="完全背包总结"><a href="#完全背包总结" class="headerlink" title="完全背包总结"></a><strong>完全背包总结</strong></h4><blockquote>
<p>求组合数：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a> </p>
<p>求排列数：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a> 、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></p>
<p>求最小数：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></p>
</blockquote>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><strong><u>多重背包</u></strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">test_multi_pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> weight <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> value <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> bagWeight <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>bagWeight <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> bagWeight<span class="token punctuation">;</span> j <span class="token operator">>=</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>
            <span class="token comment">// 以上为01背包，然后加一个遍历个数</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> k <span class="token operator">*</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历个数</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> k <span class="token operator">*</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> k <span class="token operator">*</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 打印一下dp数组</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> bagWeight<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>bagWeight<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">test_multi_pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<ul>
<li>时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</li>
</ul>
<p>从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。</p>
<p>当然还有那种二进制优化的方法，其实就是把每种物品的数量，打包成一个个独立的包。</p>
<p>和以上在循环遍历上有所不同，因为是分拆为各个包最后可以组成一个完整背包，具体原理我就不做过多解释了，大家了解一下就行，面试的话基本不会考完这个深度了，感兴趣可以自己深入研究一波。</p>
<p>多重背包在面试中基本不会出现，力扣上也没有对应的题目，大家对多重背包的掌握程度知道它是一种01背包，并能在01背包的基础上写出对应代码就可以了。</p>
</blockquote>
<h4 id="背包总结"><a href="#背包总结" class="headerlink" title="背包总结"></a><strong><u>背包总结</u></strong></h4><h5 id="①背包递推公式"><a href="#①背包递推公式" class="headerlink" title="①背包递推公式"></a><strong>①背包递推公式</strong></h5><p>问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">动态规划：416.分割等和子集(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.最后一块石头的重量II.html">动态规划：1049.最后一块石头的重量 II(opens new window)</a></li>
</ul>
<p>问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.目标和.html">动态规划：494.目标和(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518. 零钱兑换 II(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0377.组合总和Ⅳ.html">动态规划：377.组合总和Ⅳ(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li>
</ul>
<p>问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0474.一和零.html">动态规划：474.一和零(opens new window)</a></li>
</ul>
<p>问装满背包所有物品的最小个数：dp[j] = min(dp[j],dp[j - coins[i]] + 1); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0322.零钱兑换.html">动态规划：322.零钱兑换(opens new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0279.完全平方数.html">动态规划：279.完全平方数</a></li>
</ul>
<h5 id="②遍历顺序"><a href="#②遍历顺序" class="headerlink" title="②遍历顺序"></a><strong>②遍历顺序</strong></h5><p><strong>01背包</strong></p>
<ul>
<li><p>二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
</li>
<li><p>一维dp数组01背包只能<strong>先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历</strong>。</p>
</li>
</ul>
<p><strong>完全背包</strong></p>
<p>完全背包的一维dp数组实现，先遍历物品还是先遍历背包<strong>都是可以的，且第二层for循环是从小到大遍历</strong></p>
<p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p>
<ul>
<li><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
</li>
<li><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
</li>
</ul>
<blockquote>
<p>相关题目如下：</p>
<ul>
<li>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.零钱兑换II(opens new window)</a></li>
<li>求排列数：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA">动态规划：377. 组合总和 Ⅳ (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li>
</ul>
<p>如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：</p>
<ul>
<li>求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.零钱兑换.html">动态规划：322. 零钱兑换 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.完全平方数.html">动态规划：279.完全平方数(opens new window)</a></li>
</ul>
<p><strong>对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了</strong></p>
</blockquote>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981.jpeg" alt="img"></p>
<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int rob(vector&lt;int&gt;&amp; nums) &#123;
        if(nums.size() &#x3D;&#x3D; 1) return nums[0];
        vector&lt;int&gt; dp(nums.size() + 1, 0);
        dp[0] &#x3D; nums[0];
        dp[1] &#x3D; max(nums[0], nums[1]);

        for(int i &#x3D; 2 ; i &lt; nums.size() ; i++)&#123;
            dp[i] &#x3D; max(nums[i] + dp[i - 2], dp[i -1]);
        &#125;
        return dp[nums.size() - 1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h4><p>情况①  </p>
<p><img src="https://img-blog.csdnimg.cn/20210129160821374.jpg" alt="213.打家劫舍II1"></p>
<p>情况②</p>
<p><img src="https://img-blog.csdnimg.cn/20210129160842491.jpg" alt="213.打家劫舍II2"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int rob(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &#x3D;&#x3D; 0) return 0;
        if (nums.size() &#x3D;&#x3D; 1) return nums[0];
        int result1 &#x3D; robRange(nums, 0, nums.size() - 2); &#x2F;&#x2F; 情况一
        int result2 &#x3D; robRange(nums, 1, nums.size() - 1); &#x2F;&#x2F; 情况二
        return max(result1, result2);
    &#125;
    &#x2F;&#x2F; 198.打家劫舍的逻辑
    int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123;
        if (end &#x3D;&#x3D; start) return nums[start];
        vector&lt;int&gt; dp(nums.size());
        dp[start] &#x3D; nums[start];
        dp[start + 1] &#x3D; max(nums[start], nums[start + 1]);
        for (int i &#x3D; start + 2; i &lt;&#x3D; end; i++) &#123;
            dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);
        &#125;
        return dp[end];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="337-打家劫舍-III—树型dp"><a href="#337-打家劫舍-III—树型dp" class="headerlink" title="337. 打家劫舍 III—树型dp"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a>—树型dp</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
     int rob(TreeNode* root) &#123;
        vector&lt;int&gt; result &#x3D; robTree(root);
        return max(result[0], result[1]);
    &#125;
    &#x2F;&#x2F; 长度为2的数组，0：不偷，1：偷
    vector&lt;int&gt; robTree(TreeNode* cur) &#123;
        if(cur &#x3D;&#x3D; nullptr) return vector&lt;int&gt; &#123;0, 0&#125;;
        vector&lt;int&gt; left &#x3D; robTree(cur -&gt; left);
        vector&lt;int&gt; right &#x3D; robTree(cur -&gt; right);
        &#x2F;&#x2F; 偷cur
        int val1 &#x3D; cur-&gt;val + left[0] + right[0];
        &#x2F;&#x2F; 不偷cur
        int val2 &#x3D; max(left[0], left[1]) + max(right[0], right[1]);
        return vector&lt;int&gt; &#123;val2, val1&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><p>暴力 贪心都可以写 这里用dp</p>
<p><strong>1.定义：</strong> d[i][0] 表示第i天持有股票所得最多现金， d[i][1]表示第i天不持有股票所得最多现金</p>
<p><strong>2.递推公式：</strong></p>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li>
</ul>
<p>那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]);</p>
<p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li>
</ul>
<p>同样dp[i][1]取最大的，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</p>
<p><strong>3.初始化：</strong> dp[0][0] = -prices[0]     dp[0][1] = 0</p>
<p><strong>4.遍历顺序：</strong> 从前往后</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;贪心 时间复杂度： O(n) 空间复杂度：O(1) 
class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int low &#x3D; INT_MAX;
        int result &#x3D; 0;
        for (int i &#x3D; 0; i &lt; prices.size(); i++) &#123;
            low &#x3D; min(low, prices[i]);  &#x2F;&#x2F; 取最左最小价格
            result &#x3D; max(result, prices[i] - low); &#x2F;&#x2F; 直接取最大区间利润
        &#125;
        return result;
    &#125;
&#125;;
&#x2F;&#x2F; 时间复杂度： O(n) 空间复杂度：O(n) 
class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2, 0));
        dp[0][0] &#x3D; -prices[0];
        dp[0][1] &#x3D; 0;
        for(int i &#x3D; 1 ; i &lt; prices.size() ; i++)&#123;
            dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]);
            dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        &#125;
        return max(dp[prices.size() - 1][0], dp[prices.size() - 1][1]); 
        &#x2F;&#x2F; 本题中不持有股票状态所得金钱一定比持有股票状态得到的多
    &#125;
&#125;;

&#x2F;&#x2F;优化为滚动数组 时间复杂度： O(n) 空间复杂度：O(1) 
class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int len &#x3D; prices.size();
        vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(2)); &#x2F;&#x2F; 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -&#x3D; prices[0];
        dp[0][1] &#x3D; 0;
        for (int i &#x3D; 1; i &lt; len; i++) &#123;
            dp[i % 2][0] &#x3D; max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] &#x3D; max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        &#125;
        return dp[(len - 1) % 2][1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="122-买卖股票的最佳时机-II-1"><a href="#122-买卖股票的最佳时机-II-1" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><p>唯一区别在于由于可以多次买卖 dp[i][0]  除了取决于dp[i - 1][0] 外 还取决于 dp[i - 1][1] - prices[i] 而不是单纯的 -prices[i]</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int len &#x3D; prices.size();
        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2, 0));
        dp[0][0] -&#x3D; prices[0];
        dp[0][1] &#x3D; 0;
        for (int i &#x3D; 1; i &lt; len; i++) &#123;
            dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][1] - prices[i]); &#x2F;&#x2F; 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        &#125;
        return dp[len - 1][1];
    &#125;
&#125;;


class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int len &#x3D; prices.size();
        vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(2)); &#x2F;&#x2F; 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -&#x3D; prices[0];
        dp[0][1] &#x3D; 0;
        for (int i &#x3D; 1; i &lt; len; i++) &#123;
            dp[i % 2][0] &#x3D; max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]);
            dp[i % 2][1] &#x3D; max(dp[(i - 1) % 2][1], dp[(i - 1) % 2][0] + prices[i]);
        &#125;
        return dp[(len - 1) % 2][1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><p>无非是 dp[i][0] dp[i][1] 扩增为  dp[i][0] dp[i][1] dp[i][2] dp[i][3] dp[i][4] 来代表五个状态：</p>
<ul>
<li><p>无买无卖  //可以不设置</p>
</li>
<li><p>第一次买入 </p>
</li>
<li>第一次卖出 </li>
<li>第二次买入 </li>
<li>第二次卖出 </li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int len &#x3D; prices.size();
        vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(5, 0));
        dp[0][1] &#x3D; -prices[0];
        dp[0][3] &#x3D; -prices[0];
        for(int i &#x3D; 1 ; i &lt; len ; i++)&#123;
            dp[i][0] &#x3D; dp[i - 1][0]; &#x2F;&#x2F;可以不设置
            dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] &#x3D; max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] &#x3D; max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] &#x3D; max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        &#125;
        return dp[len - 1][4];
    &#125;
&#125;;

&#x2F;&#x2F;同样优化为滚动一维数组
class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int len &#x3D; prices.size();
        vector&lt;int&gt; dp(5, 0);
        dp[1] &#x3D; -prices[0];
        dp[3] &#x3D; -prices[0];
        for(int i &#x3D; 1 ; i &lt; len ; i++)&#123;
            dp[1] &#x3D; max(dp[1], dp[0] - prices[i]);
            dp[2] &#x3D; max(dp[2], dp[1] + prices[i]);
            dp[3] &#x3D; max(dp[3], dp[2] - prices[i]);
            dp[4] &#x3D; max(dp[4], dp[3] + prices[i]);
        &#125;
        return dp[4];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4><p>其实就是上面那道mid的推广 就变成hard了</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;
        if(prices.size() &#x3D;&#x3D; 1 || k &#x3D;&#x3D; 0) return 0;
        int len &#x3D; prices.size(); 
        vector&lt;int&gt; dp(2 * k + 1, 0);
        for(int i &#x3D; 1 ; i &lt; 2 * k + 1 ; i +&#x3D; 2)&#123;
            dp[i] &#x3D; -prices[0];
        &#125;
        for(int i &#x3D; 1 ; i &lt; len ; i++)&#123;
            for(int j &#x3D; 1 ; j &lt; 2 * k + 1 ; j++)&#123;
               if(j % 2 &#x3D;&#x3D; 1) dp[j] &#x3D; max(dp[j], dp[j - 1] - prices[i]);
               if(j % 2 &#x3D;&#x3D; 0) dp[j] &#x3D; max(dp[j], dp[j - 1] + prices[i]);
            &#125;
        &#125;
        return dp[2 * k];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4><p>这种类型题就是先提取出不同的状态：</p>
<ul>
<li>持有股票</li>
<li>未持有股票且未冻结</li>
<li>未持有股票且冻结</li>
</ul>
<p>然后通过题干获得状态转移 也就是递推公式/方程</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230217013029058.png" alt="image-20230217013029058"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        if(prices.size() &#x3D;&#x3D; 1) return 0;
        vector&lt;int&gt; dp(3, 0);
        dp[0] &#x3D; -prices[0];
        for(int i &#x3D; 1 ; i &lt; prices.size() ; i++)&#123;
           dp[0] &#x3D; max(dp[0], dp[1] - prices[i]);  &#x2F;&#x2F; 持有股票：1.之前就持有 2.刚买
           dp[1] &#x3D; max(dp[1], dp[2]);			  &#x2F;&#x2F; 未持有股票且未冻结： 1.之前就未持有且未冻结 2.刚过冻结期
           dp[2] &#x3D; dp[0] + prices[i];			  &#x2F;&#x2F; 未持有股票且冻结： 刚卖出去
        &#125;
        return max(dp[1], dp[2]);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;
        if(prices.size() &#x3D;&#x3D; 1) return 0;
        vector&lt;int&gt; dp(2, 0);
        dp[1] &#x3D; -prices[0];
        for(int i &#x3D; 1 ; i &lt; prices.size() ; i++)&#123;
            dp[0] &#x3D; max(dp[0], dp[1] + prices[i] - fee);
            dp[1] &#x3D; max(dp[1], dp[0] - prices[i]);
        &#125;
        return dp[0];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="股票问题总结"><a href="#股票问题总结" class="headerlink" title="股票问题总结"></a><strong>股票问题总结</strong></h4><p>基本上都是n个状态转换 理清转换状态定义 转换条件 基本就能解题 通常使用滚动数组将二维压缩为一维</p>
<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4><p>1.dp[i]的定义</p>
<blockquote>
<p>本题中，正确定义dp数组的含义十分重要。</p>
<p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p>
<p>为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。</p>
</blockquote>
<p>2.状态转移方程</p>
<blockquote>
<p>位置i的最长升序子序列等于j从0到i-1<strong>各个位置的最长升序子序列 + 1 的最大值</strong>。</p>
<p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p>
<p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &lt;&#x3D; 1) return nums.size();
        vector&lt;int&gt; dp(nums.size(), 1);
        int result &#x3D; 0;
        for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;
            for (int j &#x3D; 0; j &lt; i; j++) &#123;
                if (nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1);
            &#125;
            if (dp[i] &gt; result) result &#x3D; dp[i]; &#x2F;&#x2F; 取长的子序列
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h4><p><strong>注意和<a target="_blank" rel="noopener" href="https://programmercarl.com/0300.最长上升子序列.html">动态规划：300.最长递增子序列 (opens new window)</a>的区别！</strong></p>
<p>因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。</p>
<p>既然不用j了，那么也不用两层for循环，本题一层for循环就行，比较nums[i] 和 nums[i - 1]。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &#x3D;&#x3D; 0) return 0;
        int result &#x3D; 1;
        vector&lt;int&gt; dp(nums.size() ,1);
        for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;
            if (nums[i] &gt; nums[i - 1]) dp[i] &#x3D; dp[i - 1] + 1;
            if (dp[i] &gt; result) result &#x3D; dp[i];
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><p><strong>1.定义：</strong> d[i][j] 是指 以A[i - 1] 和 B[j - 1] 为结尾的两个字符串最长公共子数组长度</p>
<p><strong>2.递推公式：</strong> if (nums1[i - 1] == nums2[j - 1])  dp[i][j] = dp[i - 1][j - 1] + 1;</p>
<p><strong>3.初始化：</strong>  dp[0][0] = 0              </p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp (nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1, 0));
        int result &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; nums1.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; nums2.size(); j++) &#123;
                if (nums1[i - 1] &#x3D;&#x3D; nums2[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;
                if (dp[i][j] &gt; result) result &#x3D; dp[i][j];
            &#125;
        &#125;
        return result;
    &#125;
&#125;;


&#x2F;&#x2F;滚动数组压缩
class Solution &#123;
public:
    int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;
        vector&lt;int&gt; dp(vector&lt;int&gt;(B.size() + 1, 0));
        int result &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; A.size(); i++) &#123;
            for (int j &#x3D; B.size(); j &gt; 0; j--) &#123;
                if (A[i - 1] &#x3D;&#x3D; B[j - 1]) &#123;
                    dp[j] &#x3D; dp[j - 1] + 1;
                &#125; else dp[j] &#x3D; 0; &#x2F;&#x2F; 注意这里不相等的时候要有赋0的操作
                if (dp[j] &gt; result) result &#x3D; dp[j];
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><p><strong>定义：</strong> dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</p>
<p><img src="https://img-blog.csdnimg.cn/20210204115139616.jpg" alt="1143.最长公共子序列"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int longestCommonSubsequence(string text1, string text2) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(text1.size() + 1, vector&lt;int&gt;(text2.size() + 1, 0));
        for (int i &#x3D; 1; i &lt;&#x3D; text1.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; text2.size(); j++) &#123;
                if (text1[i - 1] &#x3D;&#x3D; text2[j - 1]) &#123;  &#x2F;&#x2F; 如果相等 则在之前基础上+1，否则取两种偏差的最大值
                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;
                &#125; else &#123;
                    dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);
                &#125;
            &#125;
        &#125;
        return dp[text1.size()][text2.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h4><p><strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(A.size() + 1, vector&lt;int&gt;(B.size() + 1, 0));
        for (int i &#x3D; 1; i &lt;&#x3D; A.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; B.size(); j++) &#123;
                if (A[i - 1] &#x3D;&#x3D; B[j - 1]) &#123;
                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;
                &#125; else &#123;
                    dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);
                &#125;
            &#125;
        &#125;
        return dp[A.size()][B.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="53-最大子数组和-1"><a href="#53-最大子数组和-1" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &#x3D;&#x3D; 0) return 0;
        vector&lt;int&gt; dp(nums.size());
        dp[0] &#x3D; nums[0];
        int result &#x3D; dp[0];
        for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;
            dp[i] &#x3D; max(dp[i - 1] + nums[i], nums[i]); &#x2F;&#x2F; 状态转移公式
            if (dp[i] &gt; result) result &#x3D; dp[i]; &#x2F;&#x2F; result 保存dp[i]的最大值
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h4><p>与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a>类似</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isSubsequence(string s, string t) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(s.size() + 1, vector&lt;int&gt;(t.size() + 1, 0));
        for (int i &#x3D; 1; i &lt;&#x3D; s.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; t.size(); j++) &#123;
                if (s[i - 1] &#x3D;&#x3D; t[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;
                else dp[i][j] &#x3D; dp[i][j - 1];
            &#125;
        &#125;
        if (dp[s.size()][t.size()] &#x3D;&#x3D; s.size()) return true;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h4><p><strong>1.当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。</strong></p>
<p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。</p>
<p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]</p>
<p>则 当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</p>
<p><strong>2.当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素）</strong></p>
<p>所以递推公式为：dp[i][j] = dp[i - 1][j];</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221222165412.png" alt="img"></p>
<p><strong>3.初始化：</strong> </p>
<ul>
<li>dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。 dp[i][0] = 1;</li>
<li>dp[0][j]表示: 空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数. dp[0][j] = 0;</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int numDistinct(string s, string t) &#123;
        vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size() + 1, vector&lt;uint64_t&gt;(t.size() + 1));
        for (int i &#x3D; 0; i &lt; s.size(); i++) dp[i][0] &#x3D; 1;
        for (int j &#x3D; 1; j &lt; t.size(); j++) dp[0][j] &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; s.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; t.size(); j++) &#123;
                if (s[i - 1] &#x3D;&#x3D; t[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];
                else dp[i][j] &#x3D; dp[i - 1][j];
            &#125;
        &#125;
        return dp[s.size()][t.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h4><p><strong>1.定义：</strong></p>
<ul>
<li>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</li>
</ul>
<p><strong>2.递推公式：</strong></p>
<ul>
<li>当word1[i - 1] 与 word2[j - 1]相同的时候: dp[i][j] = dp[i - 1][j - 1];</li>
<li>当word1[i - 1] 与 word2[j - 1]不相同的时候: dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</li>
</ul>
<p><strong>3.初始化：</strong></p>
<p>从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。</p>
<p>dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。</p>
<p>dp[0][j]的话同理，所以代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>4.遍历顺序：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210714101750205.png" alt="583.两个字符串的删除操作1"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minDistance(string word1, string word2) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1));
        for (int i &#x3D; 0; i &lt;&#x3D; word1.size(); i++) dp[i][0] &#x3D; i;
        for (int j &#x3D; 0; j &lt;&#x3D; word2.size(); j++) dp[0][j] &#x3D; j;
        for (int i &#x3D; 1; i &lt;&#x3D; word1.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; word2.size(); j++) &#123;
                if (word1[i - 1] &#x3D;&#x3D; word2[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1];
                else dp[i][j] &#x3D; min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
            &#125;
        &#125;
        return dp[word1.size()][word2.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然 这题和 <strong>1143. 最长公共子序列</strong> 类似，只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>string word1<span class="token punctuation">,</span> string word2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>word1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> word2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minDistance(string word1, string word2) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1));
        for (int i &#x3D; 0; i &lt;&#x3D; word1.size(); i++) dp[i][0] &#x3D; i;
        for (int j &#x3D; 0; j &lt;&#x3D; word2.size(); j++) dp[0][j] &#x3D; j;
        for (int i &#x3D; 1; i &lt;&#x3D; word1.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; word2.size(); j++) &#123;
                if (word1[i - 1] &#x3D;&#x3D; word2[j - 1]) dp[i][j] &#x3D; dp[i - 1][j - 1];
                else dp[i][j] &#x3D; min(&#123;dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]&#125;) + 1;
                &#x2F;&#x2F;只在这里与上一题不同 需要注意的是 增加和删除本质上是一样的 实际上只有 更新 和 替换
            &#125;
        &#125;
        return dp[word1.size()][word2.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4><p><strong>1.定义：</strong> 布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串</p>
<p><strong>2.递归公式：</strong> </p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li>
</ul>
<p>以上三种情况分析完了，那么递归公式如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 情况一 和 情况二</span>
        result<span class="token operator">++</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 情况三</span>
        result<span class="token operator">++</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3.初始化：</strong> dp[i][j] = false</p>
<p><strong>4.遍历顺序：</strong></p>
<p>一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的</p>
<p><img src="https://img-blog.csdnimg.cn/20210121171032473.jpg" alt="647.回文子串"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int countSubstrings(string s) &#123;
        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));
        int result &#x3D; 0;
        for (int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; i--) &#123;  &#x2F;&#x2F; 注意遍历顺序
            for (int j &#x3D; i; j &lt; s.size(); j++) &#123;
                if (s[i] &#x3D;&#x3D; s[j]) &#123;
                    if (j - i &lt;&#x3D; 1) &#123; &#x2F;&#x2F; 情况一 和 情况二
                        result++;
                        dp[i][j] &#x3D; true;
                    &#125; else if (dp[i + 1][j - 1]) &#123; &#x2F;&#x2F; 情况三
                        result++;
                        dp[i][j] &#x3D; true;
                    &#125;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><p><strong>1.定义：</strong> dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]</p>
<p><strong>2.递归公式：</strong> if(s[i] == s[j]) dp[i][j] =  dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p>
<p><img src="https://img-blog.csdnimg.cn/20210127151420476.jpg" alt="516.最长回文子序列1"></p>
<p><strong>3.初始化：</strong> </p>
<p>当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。其他情况dp[i][j]初始为0就行</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));
for (int i &#x3D; 0; i &lt; s.size(); i++) dp[i][i] &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>4.遍历顺序：</strong></p>
<p>可以发现，顺序应该是<strong>从下到上，从左往右遍历</strong></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230102172155.png" alt="img"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int longestPalindromeSubseq(string s) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0));
        for (int i &#x3D; 0; i &lt; s.size(); i++) dp[i][i] &#x3D; 1;
        for (int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; i--) &#123;
            for (int j &#x3D; i + 1; j &lt; s.size(); j++) &#123;
                if (s[i] &#x3D;&#x3D; s[j]) &#123;
                    dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;
                &#125; else &#123;
                    dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);
                &#125;
            &#125;
        &#125;
        return dp[0][s.size() - 1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="动规总结"><a href="#动规总结" class="headerlink" title="动规总结"></a><strong><u>动规总结</u></strong></h4><p><img src="https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwenpdf/_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE_%E9%9D%92.png" alt="img"></p>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a><strong>单调栈</strong></h3><h4 id="剑指-Offer-II-038-每日温度"><a href="#剑指-Offer-II-038-每日温度" class="headerlink" title="剑指 Offer II 038. 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/iIQa4I/">剑指 Offer II 038. 每日温度</a></h4><p>请根据每日 气温 列表 temperatures ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322110613674.png" alt="image-20230322110613674"></p>
<blockquote>
<p><strong>单调递减栈</strong></p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;
        stack&lt;int&gt; st; &#x2F;&#x2F; 递减栈
        vector&lt;int&gt; result(T.size(), 0);
        st.push(0);
        for (int i &#x3D; 1; i &lt; T.size(); i++) &#123;
            while (!st.empty() &amp;&amp; T[i] &gt; T[st.top()]) &#123; &#x2F;&#x2F; 注意栈不能为空
                result[st.top()] &#x3D; i - st.top();
                st.pop();
            &#125;
            st.push(i);

        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int trap(vector&lt;int&gt;&amp; height) &#123;
        stack&lt;int&gt; st;
        st.push(0);
        int sum &#x3D; 0;
        for (int i &#x3D; 1; i &lt; height.size(); i++) &#123;
            while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;
                int mid &#x3D; st.top();
                st.pop();
                if (!st.empty()) &#123;
                    int h &#x3D; min(height[st.top()], height[i]) - height[mid];
                    int w &#x3D; i - st.top() - 1;
                    sum +&#x3D; h * w;
                &#125;
            &#125;
            st.push(i);
        &#125;
        return sum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322123113881.png" alt="image-20230322123113881"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        stack&lt;int&gt; st;
        vector&lt;int&gt; res(nums1.size(),-1);
        st.push(0);
        unordered_map&lt;int,int&gt; m;
        for(int i &#x3D; 0 ; i &lt; nums1.size() ; i++) m[nums1[i]] &#x3D; i;

        for(int i &#x3D; 1 ; i &lt; nums2.size() ; i++)&#123;
            if(nums2[i] &lt;&#x3D; nums2[st.top()]) st.push(i);
            else &#123;
                while(!st.empty() &amp;&amp; nums2[i] &gt; nums2[st.top()])&#123;
                    if(m.count(nums2[st.top()]) &gt; 0)&#123;
                        res[m[nums2[st.top()]]] &#x3D; nums2[i];
                    &#125;
                    st.pop();
                &#125;
                st.push(i);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322123843258.png" alt="image-20230322123843258"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; res(nums.size(), -1);
        stack&lt;int&gt; st;
        st.push(0);
        for(int i &#x3D; 0 ; i &lt; nums.size() * 2 ; i++)&#123;
            while(!st.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[st.top()])&#123;
                res[st.top()] &#x3D; nums[i % nums.size()];
                st.pop();
            &#125;
            st.push(i % nums.size());
        &#125; 
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322124746593.png" alt="image-20230322124746593"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;
        int res &#x3D; 0;
        stack&lt;int&gt; st;
        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        st.push(0);
        for(int i &#x3D; 1 ; i &lt; heights.size() ; i++)&#123;
            while(!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()])&#123;
                int mid &#x3D; st.top();
                st.pop();
                int h &#x3D; heights[mid];
                int w &#x3D; i - st.top() - 1;
                res &#x3D; max(res, h*w);
            &#125;
            st.push(i);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-040-矩阵中最大的矩形"><a href="#剑指-Offer-II-040-矩阵中最大的矩形" class="headerlink" title="剑指 Offer II 040. 矩阵中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/PLYXKQ/">剑指 Offer II 040. 矩阵中最大的矩形</a></h4><blockquote>
<p>因为最大矩阵一定是以矩阵的某一行为底边的，所以可以遍历各行寻找答案。以矩阵第一行为底的最大矩阵面积，等效于前一题中的直方图数组为 [1, 0, 1, 0, 0]；以第二行等效为 [2, 0, 2, 1, 1]；以第三行等效为 [3, 1, 3, 2, 2]；以第四行等效为 [4, 0, 0, 3, 0]；遍历完所有行，就能得到最大矩形的面积。注意一点，原矩阵内存的是字符。</p>
</blockquote>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230323123206697.png" alt="image-20230323123206697"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maximalRectangle(vector&lt;string&gt;&amp; matrix) &#123;
        if (matrix.size() &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        vector&lt;int&gt; heights(matrix[0].size(), 0);
        int maxArea &#x3D; 0;
        for (int i &#x3D; 0; i &lt; matrix.size(); ++i) &#123;
            for (int j &#x3D; 0; j &lt; matrix[0].size(); ++j) &#123;
                if (matrix[i][j] &#x3D;&#x3D; &#39;0&#39;) &#123;
                    heights[j] &#x3D; 0;
                &#125;
                else &#123;
                    heights[j] +&#x3D; matrix[i][j] - &#39;0&#39;;
                &#125;
            &#125;
            maxArea &#x3D; max(maxArea, largestRectangleArea(heights));
        &#125;
        return maxArea;
    &#125;

    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;
        stack&lt;int&gt; sta;
        sta.push(-1);
        int maxArea &#x3D; 0;
        for (int i &#x3D; 0; i &lt; heights.size(); ++i) &#123;
            while (sta.top() !&#x3D; -1 &amp;&amp; heights[sta.top()] &gt;&#x3D; heights[i]) &#123;
                int height &#x3D; heights[sta.top()];
                sta.pop();
                int width &#x3D; i - sta.top() - 1;
                maxArea &#x3D; max(maxArea, height * width);
            &#125;
            sta.push(i);
        &#125;

        while (sta.top() !&#x3D; -1) &#123;
            int height &#x3D; heights[sta.top()];
            sta.pop();
            int width &#x3D; heights.size() - sta.top() - 1;
            maxArea &#x3D; max(maxArea, height * width);
        &#125;
        return maxArea;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a>797. 所有可能的路径</h4><blockquote>
<p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p><code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int x) &#123;
        if(x &#x3D;&#x3D; graph.size() - 1) &#123;
            res.push_back(path);
            return;
        &#125;
        for (int i &#x3D; 0 ; i &lt; graph[x].size() ; i++) &#123;
            path.push_back(graph[x][i]);
            dfs(graph, graph[x][i]);
            path.pop_back();
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;
        path.push_back(0);
        dfs(graph, 0);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="200-岛山数量"><a href="#200-岛山数量" class="headerlink" title="200 . 岛山数量"></a>200 . 岛山数量</h4><blockquote>
<p>给你一个由 <code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的二维网络格式，请你计算网络格式中岛的数量。</p>
<p>岛岛总被水包围，并且每个座岛岛只能由水平面方向和/或立方向上相接的陆地连接形成。</p>
<p>另外，你可以假装网格的四边均被水包围。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    int dir[4][2] &#x3D; &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;
    
    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;
        queue&lt;pair&lt;int,int&gt;&gt; q;
        q.push(&#123;x, y&#125;);
        visited[x][y] &#x3D; 1;
        while(!q.empty()) &#123;
            pair&lt;int,int&gt; cur &#x3D; q.front();
            q.pop();
            int curx &#x3D; cur.first;
            int cury &#x3D; cur.second;
            for(int i &#x3D; 0 ; i &lt; 4 ; i++) &#123;
                int nextx &#x3D; curx + dir[i][0];
                int nexty &#x3D; cury + dir[i][1];
                if(nextx &lt; 0 || nexty &lt; 0 || nextx &gt;&#x3D; grid.size() || nexty &gt;&#x3D; grid[0].size()) continue;
                if(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] &#x3D;&#x3D; &#39;1&#39;) &#123;
                    q.push(&#123;nextx, nexty&#125;);
                    visited[nextx][nexty] &#x3D; 1;
                &#125;
            &#125;
        &#125;
    &#125; 
    
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;
        for (int i &#x3D; 0; i &lt; 4; i++) &#123;
            int nextx &#x3D; x + dir[i][0];
            int nexty &#x3D; y + dir[i][1];
            if (nextx &lt; 0 || nextx &gt;&#x3D; grid.size() || nexty &lt; 0 || nexty &gt;&#x3D; grid[0].size()) continue;  
            if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] &#x3D;&#x3D; &#39;1&#39;) &#123; 
                visited[nextx][nexty] &#x3D; true; 
                dfs(grid, visited, nextx, nexty);
            &#125; 
        &#125;
    &#125;
    
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;
        int res &#x3D; 0;
        vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt;(grid[0].size(),0));
        for(int i &#x3D; 0 ; i &lt; grid.size() ; i++ ) &#123;
            for(int j &#x3D; 0 ; j &lt; grid[0].size() ; j++) &#123;
                if(!visited[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;
                    res++;
                    bfs(grid, visited, i, j);
                    &#x2F;&#x2F; dfs(grid, visited, i, j);
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;


class Solution &#123;
private:
    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;
        if(x &lt; 0 || y &lt; 0 || x &gt;&#x3D; grid.size() || y &gt;&#x3D; grid[0].size() || visited[x][y] || grid[x][y] &#x3D;&#x3D; &#39;0&#39;) return;
        visited[x][y] &#x3D; 1;
        bfs(grid, visited, x+1, y);
        bfs(grid, visited, x-1, y);
        bfs(grid, visited, x, y-1);
        bfs(grid, visited, x, y+1);
    &#125; 
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;
        int res &#x3D; 0;
        vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt;(grid[0].size(),0));
        for(int i &#x3D; 0 ; i &lt; grid.size() ; i++ ) &#123;
            for(int j &#x3D; 0 ; j &lt; grid[0].size() ; j++) &#123;
                if(!visited[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;
                    bfs(grid, visited, i, j);
                    res++;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;

&#x2F;&#x2F; 便捷版（dfs）
class Solution &#123;
public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;
        int res &#x3D; 0;
        for(int i &#x3D; 0 ; i &lt; grid.size() ; i++)&#123;
            for(int j &#x3D; 0 ; j &lt; grid[0].size() ; j++)&#123;
                if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;
                    caul(grid,i,j);
                    res++;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;

    void caul(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123;
        if(i &gt;&#x3D; grid.size() || i &lt; 0) return;
        if(j &gt;&#x3D; grid[0].size() || j &lt; 0) return;
        if(grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;
            grid[i][j] &#x3D; &#39;0&#39;;
            caul(grid, i+1, j);
            caul(grid, i-1, j);
            caul(grid, i, j+1);
            caul(grid, i, j-1);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h4><blockquote>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    int now_area;
    int dir[4][2] &#x3D; &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;
        for(int i &#x3D; 0 ; i &lt; 4 ; i++) &#123;
            int nextx &#x3D; x + dir[i][0];
            int nexty &#x3D; y + dir[i][1];
            if(nextx &lt; 0 || nexty &lt; 0 || nextx &gt;&#x3D; grid.size() || nexty &gt;&#x3D; grid[0].size()) continue;
            if(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] &#x3D;&#x3D; 1)&#123;
                now_area++;
                visited[nextx][nexty] &#x3D; 1;
                dfs(grid,visited,nextx, nexty);
            &#125;
        &#125;
    &#125;

    void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;
        queue&lt;pair&lt;int,int&gt;&gt; q;
        q.push(&#123;x,y&#125;);
        while(!q.empty()) &#123;
            pair&lt;int,int&gt; cur &#x3D; q.front();
            q.pop();
            int curx &#x3D; cur.first;
            int cury &#x3D; cur.second;
            for(int i &#x3D; 0 ; i &lt; 4 ; i++) &#123;
                int nextx &#x3D; curx + dir[i][0];
                int nexty &#x3D; cury + dir[i][1];
                if(nextx &lt; 0 || nexty &lt; 0 || nextx &gt;&#x3D; grid.size() || nexty &gt;&#x3D; grid[0].size()) continue;
                if(!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] &#x3D;&#x3D; 1)&#123;
                now_area++;
                visited[nextx][nexty] &#x3D; 1;
                q.push(&#123;nextx, nexty&#125;);
                &#125;
            &#125;
        &#125;
    &#125;

public:
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int res &#x3D; 0;
        vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt;(grid[0].size(), 0));
        for(int i &#x3D; 0 ; i &lt; grid.size() ; i++) &#123;
            for(int j &#x3D; 0 ; j &lt; grid[0].size() ; j++) &#123;
                if(!visited[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; 1) &#123;
                    now_area &#x3D; 1;
                    visited[i][j] &#x3D; 1;
                    &#x2F;&#x2F;dfs(grid,visited,i,j);
                    bfs(grid,visited,i,j);
                    res &#x3D; max(res, now_area);
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;

&#x2F;&#x2F; 便捷版（dfs）
class Solution &#123;
public:
    int getArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123;
        if(i &gt;&#x3D; grid.size()) return 0;
        if(j &gt;&#x3D; grid[0].size()) return 0;
        if(grid[i][j] &#x3D;&#x3D; 1)&#123;
            grid[i][j] &#x3D; 0;
            return 1 + getArea(grid, i + 1, j) + getArea(grid, i - 1, j) + getArea(grid, i, j + 1) + getArea(grid, i, j - 1);
        &#125;
        return 0;
    &#125;

    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int area &#x3D; 0;
        int res &#x3D; 0;
        for(int i &#x3D; 0 ; i &lt; grid.size() ; i++)&#123;
            for(int j &#x3D; 0 ; j &lt; grid[0].size() ; j++)&#123;
                area &#x3D; getArea(grid, i, j);
                res &#x3D; max(res, area);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020. 飞地的数量"></a>1020. 飞地的数量</h4><blockquote>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，其中 <code>0</code> 表示一个海洋单元格、<code>1</code> 表示一个陆地单元格。</p>
<p>一次 <strong>移动</strong> 是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过 <code>grid</code> 的边界。</p>
<p>返回网格中 <strong>无法</strong> 在任意次数的移动中离开网格边界的陆地单元格的数量。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    int dir[4][2] &#x3D; &#123;0,1,1,0,-1,0,0,-1&#125;;
    int count;
    
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123;
        grid[x][y] &#x3D; 0;
        count++;
        for (int i &#x3D; 0; i &lt; 4; i++) &#123;
            int nextx &#x3D; x + dir[i][0];
            int nexty &#x3D; y + dir[i][1];
            if (nextx &lt; 0 || nextx &gt;&#x3D; grid.size() || nexty &lt; 0 || nexty &gt;&#x3D; grid[0].size()) continue;
            if (grid[nextx][nexty] &#x3D;&#x3D; 0) continue;
            dfs (grid, nextx, nexty);
        &#125;
        return;
    &#125;

    void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push(&#123;x,y&#125;);
        count++;
        grid[x][y] &#x3D; 0;
        while(!q.empty()) &#123;
            pair&lt;int,int&gt; cur &#x3D; q.front();
            q.pop();
            int curx &#x3D; cur.first;
            int cury &#x3D; cur.second;
            for (int i &#x3D; 0; i &lt; 4; i++) &#123;
                int nextx &#x3D; curx + dir[i][0];
                int nexty &#x3D; cury + dir[i][1];
                if (nextx &lt; 0 || nextx &gt;&#x3D; grid.size() || nexty &lt; 0 || nexty &gt;&#x3D; grid[0].size()) continue;
                if (grid[nextx][nexty] &#x3D;&#x3D; 1) &#123;
                    q.push(&#123;nextx, nexty&#125;);
                    count++;
                    grid[nextx][nexty] &#x3D; 0;
                &#125;
            &#125;
        &#125;
    &#125;

public:
    int numEnclaves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int n &#x3D; grid.size();
        int m &#x3D; grid[0].size();
        for (int i &#x3D; 0 ; i &lt; n ; i++) &#123;
            if(grid[i][0] &#x3D;&#x3D; 1) bfs(grid, i, 0); &#x2F;&#x2F;dfs(grid, i, 0); 
            if(grid[i][m-1] &#x3D;&#x3D; 1) bfs(grid, i, m-1); &#x2F;&#x2F;dfs(grid, i, m-1); 
        &#125;
        for (int j &#x3D; 0 ; j &lt; m ; j++) &#123;
            if(grid[0][j] &#x3D;&#x3D; 1) bfs(grid, 0, j);&#x2F;&#x2F;dfs(grid, 0, j);
            if(grid[n-1][j] &#x3D;&#x3D; 1) bfs(grid, n-1, j);&#x2F;&#x2F;dfs(grid, n-1, j);
        &#125;
        count &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            for (int j &#x3D; 0; j &lt; m; j++) &#123;
                if (grid[i][j] &#x3D;&#x3D; 1) bfs(grid, i, j);&#x2F;&#x2F;dfs(grid, i, j);
            &#125;
        &#125;
        return count;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h4><blockquote>
<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    int divs[4][2] &#x3D; &#123;0,1,1,0,-1,0,0,-1&#125;;

    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;
        board[x][y] &#x3D; &#39;A&#39;;
        for (auto div : divs) &#123;
            int nextx &#x3D; x + div[0];
            int nexty &#x3D; y + div[1];
            if(!(nextx &lt; 0 || nexty &lt; 0 || nextx &gt;&#x3D; board.size() || nexty &gt;&#x3D; board[0].size()) &amp;&amp; board[nextx][nexty] &#x3D;&#x3D; &#39;O&#39;) &#123;
                dfs(board, nextx, nexty);
            &#125;
        &#125;
    &#125;

    void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push(&#123;x,y&#125;);
        board[x][y] &#x3D; &#39;A&#39;;
        while(!q.empty())&#123;
            pair&lt;int,int&gt; cur &#x3D; q.front(); q.pop();
            int curx &#x3D; cur.first;
            int cury &#x3D; cur.second;
            for(auto div : divs) &#123;
                int nextx &#x3D; curx + div[0];
                int nexty &#x3D; cury + div[1];
                if(!(nextx &lt; 0 || nexty &lt; 0 || nextx &gt;&#x3D; board.size() || nexty &gt;&#x3D; board[0].size()) &amp;&amp; board[nextx][nexty] &#x3D;&#x3D; &#39;O&#39;) &#123;
                    q.push(&#123;nextx,nexty&#125;);
                    board[nextx][nexty] &#x3D; &#39;A&#39;;
                &#125;
            &#125;
        &#125;
    &#125;
    
public:
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        int n &#x3D; board.size();
        int m &#x3D; board[0].size();
        for (int i &#x3D; 0 ; i &lt; n ; i++) &#123;
            if(board[i][0] &#x3D;&#x3D; &#39;O&#39;) dfs(board,i,0); &#x2F;&#x2F;bfs(board,i,0);
            if(board[i][m - 1] &#x3D;&#x3D; &#39;O&#39;) dfs(board,i,m-1); &#x2F;&#x2F;bfs(board,i,m-1);
        &#125;
        for (int j &#x3D; 0 ; j &lt; m ; j++) &#123;
            if(board[0][j] &#x3D;&#x3D; &#39;O&#39;) dfs(board,0,j);&#x2F;&#x2F;bfs(board,0,j);
            if(board[n-1][j] &#x3D;&#x3D; &#39;O&#39;) dfs(board,n-1,j);&#x2F;&#x2F;bfs(board,n-1,j);
        &#125; 
        for (int i &#x3D; 0 ; i &lt; n ; i++) &#123;
            for (int j &#x3D; 0 ; j &lt; m ; j++) &#123;
                if (board[i][j] &#x3D;&#x3D; &#39;O&#39;) board[i][j] &#x3D; &#39;X&#39;;
                if (board[i][j] &#x3D;&#x3D; &#39;A&#39;) board[i][j] &#x3D; &#39;O&#39;;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a>417. 太平洋大西洋水流问题</h4><blockquote>
<p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和 <strong>大西洋</strong> 相邻。 <strong>“太平洋”</strong> 处于大陆的左边界和上边界，而 <strong>“大西洋”</strong> 处于大陆的右边界和下边界。</p>
<p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵 <code>heights</code> ， <code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格 <strong>高于海平面的高度</strong> 。</p>
<p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p>
<p>返回网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中 <code>result[i] = [ri, ci]</code> 表示雨水从单元格 <code>(ri, ci)</code> 流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;dfs
class Solution &#123;
public:
    int divs[4][2] &#x3D; &#123;0,1,1,0,-1,0,0,-1&#125;;

    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; heights, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123;
        if (visited[x][y]) return;
        visited[x][y] &#x3D; true;
        for (auto div : divs) &#123; &#x2F;&#x2F; 向四个方向遍历
            int nextx &#x3D; x + div[0];
            int nexty &#x3D; y + div[1];
            &#x2F;&#x2F; 超过边界
            if (nextx &lt; 0 || nextx &gt;&#x3D; heights.size() || nexty &lt; 0 || nexty &gt;&#x3D; heights[0].size()) continue;
            &#x2F;&#x2F; 高度不合适，注意这里是从低向高判断
            if (heights[x][y] &gt; heights[nextx][nexty]) continue;

            dfs (heights, visited, nextx, nexty);
        &#125;
        return;
    &#125;

    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123;
        int n &#x3D; heights.size();
        int m &#x3D; heights[0].size();
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;vector&lt;bool&gt;&gt; pacific(n, vector&lt;bool&gt;(m, 0));
        vector&lt;vector&lt;bool&gt;&gt; atlantic(n, vector&lt;bool&gt;(m, 0));
        for (int i &#x3D; 0 ; i &lt; n ; i++) &#123;
            dfs (heights, pacific, i, 0); 
            dfs (heights, atlantic, i, m - 1); 
        &#125;
        for (int j &#x3D; 0 ; j &lt; m ; j++) &#123;
            dfs (heights, pacific, 0, j); 
            dfs (heights, atlantic, n - 1, j); 
        &#125;
        for (int i &#x3D; 0 ; i &lt; n ; i++) &#123;
            for (int j &#x3D; 0 ; j &lt; m ; j++) &#123;
                if(pacific[i][j] &amp;&amp; atlantic[i][j]) res.push_back(&#123;i,j&#125;);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="827-最大人工岛"><a href="#827-最大人工岛" class="headerlink" title="827. 最大人工岛"></a>827. 最大人工岛</h4><blockquote>
<p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>
<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>
<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    int count;
    int dir[4][2] &#x3D; &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; &#x2F;&#x2F; 四个方向
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y, int mark) &#123;
        if (visited[x][y] || grid[x][y] &#x3D;&#x3D; 0) return; &#x2F;&#x2F; 终止条件：访问过的节点 或者 遇到海水
        visited[x][y] &#x3D; true; &#x2F;&#x2F; 标记访问过
        grid[x][y] &#x3D; mark; &#x2F;&#x2F; 给陆地标记新标签
        count++;
        for (int i &#x3D; 0; i &lt; 4; i++) &#123;
            int nextx &#x3D; x + dir[i][0];
            int nexty &#x3D; y + dir[i][1];
            if (nextx &lt; 0 || nextx &gt;&#x3D; grid.size() || nexty &lt; 0 || nexty &gt;&#x3D; grid[0].size()) continue;  &#x2F;&#x2F; 越界了，直接跳过
            dfs(grid, visited, nextx, nexty, mark);
        &#125;
    &#125;

public:
    int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int n &#x3D; grid.size(), m &#x3D; grid[0].size();
        vector&lt;vector&lt;bool&gt;&gt; visited &#x3D; vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(m, false)); &#x2F;&#x2F; 标记访问过的点
        unordered_map&lt;int ,int&gt; gridNum;
        int mark &#x3D; 2; &#x2F;&#x2F; 记录每个岛屿的编号
        bool isAllGrid &#x3D; true; &#x2F;&#x2F; 标记是否整个地图都是陆地
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            for (int j &#x3D; 0; j &lt; m; j++) &#123;
                if (grid[i][j] &#x3D;&#x3D; 0) isAllGrid &#x3D; false;
                if (!visited[i][j] &amp;&amp; grid[i][j] &#x3D;&#x3D; 1) &#123;
                    count &#x3D; 0;
                    dfs(grid, visited, i, j, mark); &#x2F;&#x2F; 将与其链接的陆地都标记上 true
                    gridNum[mark] &#x3D; count; &#x2F;&#x2F; 记录每一个岛屿的面积
                    mark++; &#x2F;&#x2F; 记录下一个岛屿编号
                &#125;
            &#125;
        &#125;
        if (isAllGrid) return n * m; &#x2F;&#x2F; 如果都是陆地，返回全面积

        &#x2F;&#x2F; 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和
        int result &#x3D; 0; &#x2F;&#x2F; 记录最后结果
        unordered_set&lt;int&gt; visitedGrid; &#x2F;&#x2F; 标记访问过的岛屿
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            for (int j &#x3D; 0; j &lt; m; j++) &#123;
                int count &#x3D; 1; &#x2F;&#x2F; 记录连接之后的岛屿数量
                visitedGrid.clear(); &#x2F;&#x2F; 每次使用时，清空
                if (grid[i][j] &#x3D;&#x3D; 0) &#123;
                    for (int k &#x3D; 0; k &lt; 4; k++) &#123;
                        int neari &#x3D; i + dir[k][1]; &#x2F;&#x2F; 计算相邻坐标
                        int nearj &#x3D; j + dir[k][0];
                        if (neari &lt; 0 || neari &gt;&#x3D; grid.size() || nearj &lt; 0 || nearj &gt;&#x3D; grid[0].size()) continue;
                        if (visitedGrid.count(grid[neari][nearj])) continue; &#x2F;&#x2F; 添加过的岛屿不要重复添加
                        &#x2F;&#x2F; 把相邻四面的岛屿数量加起来
                        count +&#x3D; gridNum[grid[neari][nearj]];
                        visitedGrid.insert(grid[neari][nearj]); &#x2F;&#x2F; 标记该岛屿已经添加过
                    &#125;
                &#125;
                result &#x3D; max(result, count);
            &#125;
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a>127. 单词接龙</h4><blockquote>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;
        unordered_set&lt;string&gt; dir(wordList.begin(), wordList.end());
        if(dir.find(endWord) &#x3D;&#x3D; dir.end()) return 0;
        unordered_map&lt;string, int&gt; visit;
        visit[beginWord] &#x3D; 1;
        queue&lt;string&gt; q;
        q.push(beginWord);
        while(!q.empty()) &#123;
            string cur &#x3D; q.front(); q.pop();
            int path &#x3D; visit[cur];
            for(int i &#x3D; 0 ; i &lt; cur.size() ; i++) &#123;
                string newWord &#x3D; cur;
                for(int j &#x3D; 0 ; j &lt; 26 ; j++) &#123;
                    newWord[i] &#x3D; j + &#39;a&#39;;
                    if(newWord &#x3D;&#x3D; endWord) return path + 1;
                    if(dir.find(newWord) !&#x3D; dir.end() &amp;&amp; visit.find(newWord) &#x3D;&#x3D; visit.end())&#123;
                        q.push(newWord);
                        visit[newWord] &#x3D; path + 1;
                    &#125;
                &#125;
            &#125;
        &#125;
        return 0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a>841. 钥匙和房间</h4><blockquote>
<p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到 <code>n - 1</code> 编号。最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>
<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>
<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入 <code>i</code> 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 <code>true</code>，否则返回 <code>false</code>。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
private:
    void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; rooms, int key, vector&lt;bool&gt;&amp; visited) &#123;
        if (visited[key]) &#123;
            return;
        &#125;
        visited[key] &#x3D; true;
        vector&lt;int&gt; keys &#x3D; rooms[key];
        for (int key : keys) &#123;
            &#x2F;&#x2F; 深度优先搜索遍历
            dfs(rooms, key, visited);
        &#125;
    &#125;
public:
    bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123;
        vector&lt;bool&gt; visited(rooms.size(), false);
        dfs(rooms, 0, visited);
        &#x2F;&#x2F;检查是否都访问到了
        for (int i : visited) &#123;
            if (i &#x3D;&#x3D; false) return false;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a>463. 岛屿的周长</h4><blockquote>
<p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>
<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 解法一
&#x2F;&#x2F; 遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，就可以计算边了
class Solution &#123;
public:
    int direction[4][2] &#x3D; &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int result &#x3D; 0;
        for (int i &#x3D; 0; i &lt; grid.size(); i++) &#123;
            for (int j &#x3D; 0; j &lt; grid[0].size(); j++) &#123;
                if (grid[i][j] &#x3D;&#x3D; 1) &#123;
                    for (int k &#x3D; 0; k &lt; 4; k++) &#123;       &#x2F;&#x2F; 上下左右四个方向
                        int x &#x3D; i + direction[k][0];
                        int y &#x3D; j + direction[k][1];    &#x2F;&#x2F; 计算周边坐标x,y
                        if (x &lt; 0                       &#x2F;&#x2F; i在边界上
                                || x &gt;&#x3D; grid.size()     &#x2F;&#x2F; i在边界上
                                || y &lt; 0                &#x2F;&#x2F; j在边界上
                                || y &gt;&#x3D; grid[0].size()  &#x2F;&#x2F; j在边界上
                                || grid[x][y] &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F; x,y位置是水域
                            result++;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;;

&#x2F;&#x2F; 解法二
&#x2F;&#x2F; 计算出总的岛屿数量，因为有一对相邻两个陆地，边的总数就减2，那么在计算出相邻岛屿的数量就可以了。
&#x2F;&#x2F; result &#x3D; 岛屿数量 * 4 - cover * 2;
class Solution &#123;
public:
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int sum &#x3D; 0;    &#x2F;&#x2F; 陆地数量
        int cover &#x3D; 0;  &#x2F;&#x2F; 相邻数量
        for (int i &#x3D; 0; i &lt; grid.size(); i++) &#123;
            for (int j &#x3D; 0; j &lt; grid[0].size(); j++) &#123;
                if (grid[i][j] &#x3D;&#x3D; 1) &#123;
                    sum++;
                    &#x2F;&#x2F; 统计上边相邻陆地
                    if(i - 1 &gt;&#x3D; 0 &amp;&amp; grid[i - 1][j] &#x3D;&#x3D; 1) cover++;
                    &#x2F;&#x2F; 统计左边相邻陆地
                    if(j - 1 &gt;&#x3D; 0 &amp;&amp; grid[i][j - 1] &#x3D;&#x3D; 1) cover++;
                    &#x2F;&#x2F; 为什么没统计下边和右边？ 因为避免重复计算
                &#125;
            &#125;
        &#125;
        return sum * 4 - cover * 2;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Smile Slight</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://smileslight.github.io/2023/06/21/coding/">https://smileslight.github.io/2023/06/21/coding/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Smile Slight</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C/">
                                    <span class="chip bg-color">C++</span>
                                </a>
                            
                                <a href="/tags/%E5%88%B7%E9%A2%98/">
                                    <span class="chip bg-color">刷题</span>
                                </a>
                            
                                <a href="/tags/OJ/">
                                    <span class="chip bg-color">OJ</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/07/31/daily/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="daily">
                        
                        <span class="card-title">daily</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            每日补充
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-07-31
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Smile Slight
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                    <a href="/tags/%E5%88%B7%E9%A2%98/">
                        <span class="chip bg-color">刷题</span>
                    </a>
                    
                    <a href="/tags/Daily/">
                        <span class="chip bg-color">Daily</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/10/31/LC75/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="LC75">
                        
                        <span class="card-title">LC75</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            LC75
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-10-31
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Smile Slight
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                    <a href="/tags/%E5%88%B7%E9%A2%98/">
                        <span class="chip bg-color">刷题</span>
                    </a>
                    
                    <a href="/tags/LeetCode75/">
                        <span class="chip bg-color">LeetCode75</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="632021463"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">Smile Slight</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/SmileSlight" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1585118039@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1585118039" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1585118039" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
