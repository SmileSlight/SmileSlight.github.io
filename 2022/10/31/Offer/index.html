<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Offer, Welcome">
    <meta name="description" content="剑指补充">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Offer | Welcome</title>
    <link rel="icon" type="image/png" href="/1.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.0.0"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size: 100% 100%;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Welcome</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
      <li>
        <a href="/movies">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Movies</span>
        </a>
      </li>
      
      <li>
        <a href="/books">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Books</span>
        </a>
      </li>
      
      <li>
        <a href="/galleries">
          
          <i class="fas fa-image" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Galleries</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Welcome</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
                <li>

                  <a href="/movies " style="margin-left:75px">
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>Movies</span>
                  </a>
                </li>
              
                <li>

                  <a href="/books " style="margin-left:75px">
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Books</span>
                  </a>
                </li>
              
                <li>

                  <a href="/galleries " style="margin-left:75px">
				  
				   <i class="fa fas fa-image" style="position: absolute;left:50px" ></i>
			      
		          <span>Galleries</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/SmileSlight/SmileSlight.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Look Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/SmileSlight/SmileSlight.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Look Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Offer</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 400px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: scroll;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C/">
                                <span class="chip bg-color">C++</span>
                            </a>
                        
                            <a href="/tags/%E5%89%91%E6%8C%87/">
                                <span class="chip bg-color">剑指</span>
                            </a>
                        
                            <a href="/tags/%E5%88%B7%E9%A2%98/">
                                <span class="chip bg-color">刷题</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-10-31
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class CQueue &#123;

    LinkedList&lt;Integer&gt; A,B;

    public CQueue() &#123;
        A &#x3D; new LinkedList();
        B &#x3D; new LinkedList();
    &#125;
    
    public void appendTail(int value) &#123;
        A.addLast(value);
    &#125;
    
    public int deleteHead() &#123;
        if(!B.isEmpty()) return B.pollLast();
        if(A.isEmpty()) return -1;
        while(!A.isEmpty())&#123;
            B.addLast(A.pollLast());
        &#125;
        return B.pollLast();
    &#125;
&#125;

&#x2F;**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj &#x3D; new CQueue();
 * obj.appendTail(value);
 * int param_2 &#x3D; obj.deleteHead();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">/** initialize your data structure here. */</span>
    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        a<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> b<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> b<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> b<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//由于 LinkedList 中存储的是 int 的包装类 Integer ，因此需要使用 equals() 代替 == 来比较值是否相等。</span>
        a<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int[] reversePrint(ListNode head) &#123;
        LinkedList&lt;Integer&gt; stack &#x3D; new LinkedList&lt;Integer&gt;();
        while(head !&#x3D; null) &#123;
            stack.addLast(head.val);
            head &#x3D; head.next;
        &#125;
        int[] res &#x3D; new int[stack.size()];
        for(int i &#x3D; 0; i &lt; res.length; i++) res[i] &#x3D; stack.removeLast();
        return res;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;迭代法：
&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        ListNode pre &#x3D; null;
        ListNode cur &#x3D; head;
        while(cur !&#x3D; null)&#123;
            ListNode tmp &#x3D; cur.next;
            cur.next &#x3D; pre;
            pre &#x3D; cur;
            cur &#x3D; tmp;
        &#125;
        return pre;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;递归法：
&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;
        ListNode node &#x3D; reverseList(head.next);
        head.next.next &#x3D; head;
        head.next &#x3D; null;
        return node;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<pre class="line-numbers language-jAVA" data-language="jAVA"><code class="language-jAVA">&#x2F;&#x2F;哈希表法
&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
    int val;
    Node next;
    Node random;

    public Node(int val) &#123;
        this.val &#x3D; val;
        this.next &#x3D; null;
        this.random &#x3D; null;
    &#125;
&#125;
*&#x2F;
class Solution &#123;
    public Node copyRandomList(Node head) &#123;
        if(head &#x3D;&#x3D; null) return null;
        Node cur &#x3D; head;
        Map&lt;Node,Node&gt; map &#x3D; new HashMap&lt;&gt;();;
        while(cur !&#x3D; null)&#123;
            map.put(cur,new Node(cur.val));
            cur &#x3D; cur.next;
        &#125;
        cur &#x3D; head;
        while(cur !&#x3D; null)&#123;
            map.get(cur).next &#x3D; map.get(cur.next);
            map.get(cur).random &#x3D; map.get(cur.random);
            cur &#x3D; cur.next;
        &#125;
        return map.get(head);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;拼接法
class Solution &#123;
    public Node copyRandomList(Node head) &#123;
        if(head &#x3D;&#x3D; null) return null;
        Node cur &#x3D; head;
        &#x2F;&#x2F; 1. 复制各节点，并构建拼接链表
        while(cur !&#x3D; null) &#123;
            Node tmp &#x3D; new Node(cur.val);
            tmp.next &#x3D; cur.next;
            cur.next &#x3D; tmp;
            cur &#x3D; tmp.next;
        &#125;
        &#x2F;&#x2F; 2. 构建各新节点的 random 指向
        cur &#x3D; head;
        while(cur !&#x3D; null) &#123;
            if(cur.random !&#x3D; null)
                cur.next.random &#x3D; cur.random.next;
            cur &#x3D; cur.next.next;
        &#125;
        &#x2F;&#x2F; 3. 拆分两链表
        cur &#x3D; head.next;
        Node pre &#x3D; head, res &#x3D; head.next;
        while(cur.next !&#x3D; null) &#123;
            pre.next &#x3D; pre.next.next;
            cur.next &#x3D; cur.next.next;
            pre &#x3D; pre.next;
            cur &#x3D; cur.next;
        &#125;
        pre.next &#x3D; null; &#x2F;&#x2F; 单独处理原链表尾节点
        return res;      &#x2F;&#x2F; 返回新链表头节点
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public String replaceSpace(String s) &#123;
        StringBuilder res &#x3D; new StringBuilder();
        for(Character c : s.toCharArray())
        &#123;
            if(c &#x3D;&#x3D; &#39; &#39;) res.append(&quot;%20&quot;);
            else res.append(c);
        &#125;
        return res.toString();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;遍历
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        StringBuilder res &#x3D; new StringBuilder();
        for(int i &#x3D; n ; i &lt; s.length() ; i++)&#123;
            res.append(s.charAt(i));
        &#125;
        for(int i &#x3D; 0 ; i &lt; n ; i++)&#123;
            res.append(s.charAt(i));
        &#125;
        return res.toString();
    &#125;
&#125;

&#x2F;&#x2F;拼接
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        return s.substring(n, s.length()) + s.substring(0, n);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int findRepeatNumber(int[] nums) &#123;
        Set&lt;Integer&gt; dic &#x3D; new HashSet&lt;&gt;();
        for(int num : nums) &#123;
            if(dic.contains(num)) return num;
            dic.add(num);
        &#125;
        return -1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><p>统计一个数字在排序数组中出现的次数。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int search(int[] nums, int t) &#123;
        int a &#x3D; 0, b &#x3D; 0, n &#x3D; nums.length;
        if (n &#x3D;&#x3D; 0) return 0;
        int l &#x3D; 0, r &#x3D; n - 1;
        while (l &lt; r) &#123;
            int mid &#x3D; l + r &gt;&gt; 1;
            if (nums[mid] &gt;&#x3D; t) r &#x3D; mid;
            else l &#x3D; mid + 1;
        &#125;
        if (nums[r] !&#x3D; t) return 0;
        a &#x3D; r;
        l &#x3D; 0; r &#x3D; n - 1;
        while (l &lt; r) &#123;
            int mid &#x3D; l + r + 1 &gt;&gt; 1;
            if (nums[mid] &lt;&#x3D; t) l &#x3D; mid;
            else r &#x3D; mid - 1;
        &#125;
        b &#x3D; r;
        return b - a + 1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int missingNumber(int[] nums) &#123;
        int i &#x3D; 0, j &#x3D; nums.length - 1;
        while(i &lt;&#x3D; j) &#123;
            int m &#x3D; (i + j) &#x2F; 2;
            if(nums[m] &#x3D;&#x3D; m) i &#x3D; m + 1;
            else j &#x3D; m - 1;
        &#125;
        return i;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;
        int n &#x3D; matrix.length;
        if(n &#x3D;&#x3D; 0) return false;
        int m &#x3D; matrix[0].length;
        int i &#x3D; 0;
        int j &#x3D; m - 1;
        while(i &lt; n &amp;&amp; j &gt;&#x3D; 0)&#123;
            if(matrix[i][j] &#x3D;&#x3D; target) return true;
            else if(matrix[i][j] &lt; target) i++;
            else if(matrix[i][j] &gt; target) j--;
        &#125;
        return false;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> numbers<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> numbers<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span>
            <span class="token keyword">else</span> j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h4><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public char firstUniqChar(String s) &#123;
        Map&lt;Character, Boolean&gt; dic &#x3D; new LinkedHashMap&lt;&gt;();
        char[] sc &#x3D; s.toCharArray();
        for(char c : sc)
            dic.put(c, !dic.containsKey(c));
        for(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;
           if(d.getValue()) return d.getKey();
        &#125;
        return &#39; &#39;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val = x; &#125;
 * &#125;
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> deque<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token class-name">TreeNode</span> node  <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> deque<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> deque<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();
        LinkedList&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;&gt;(); 
        if(root !&#x3D; null) que.addLast(root);
        while(!que.isEmpty())&#123;
            List&lt;Integer&gt; level &#x3D; new ArrayList&lt;&gt;();
            int n &#x3D; que.size();
            for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i++)&#123;
                TreeNode node &#x3D; que.removeFirst();
                level.add(node.val);
                if(node.left !&#x3D; null) que.addLast(node.left);
                if(node.right !&#x3D; null) que.addLast(node.right);
            &#125;
            res.add(level); 
        &#125;
        return res;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();
        LinkedList&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;&gt;(); 
        int bool &#x3D; 1;
        if(root !&#x3D; null) que.addLast(root);
        while(!que.isEmpty())&#123;
            List&lt;Integer&gt; level &#x3D; new ArrayList&lt;&gt;();
            int n &#x3D; que.size();
            for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i++)&#123;
                TreeNode node &#x3D; que.removeFirst();
                level.add(node.val);
                if(node.left !&#x3D; null) que.addLast(node.left);
                if(node.right !&#x3D; null) que.addLast(node.right);
            &#125;
            if(bool &#x3D;&#x3D; 1)&#123;
                res.add(level); 
                bool &#x3D; 0;
            &#125;else&#123;
                Collections.reverse(level);
                res.add(level); 
                bool &#x3D; 1;
            &#125;
        &#125;
        return res;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;
        return (A !&#x3D; null &amp;&amp; B !&#x3D; null) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    &#125;
    boolean recur(TreeNode A, TreeNode B) &#123;
        if(B &#x3D;&#x3D; null) return true;
        if(A &#x3D;&#x3D; null || A.val !&#x3D; B.val) return false;
        return recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;

&#x2F;&#x2F;递推法
public TreeNode mirrorTree(TreeNode root) &#123;
        if (root &#x3D;&#x3D; null) &#123;
            return null;
        &#125;
        TreeNode leftRoot &#x3D; mirrorTree(root.right);
        TreeNode rightRoot &#x3D; mirrorTree(root.left);
        root.left &#x3D; leftRoot;
        root.right &#x3D; rightRoot;
        return root;
&#125;


&#x2F;&#x2F;辅助栈法
class Solution &#123;
    public TreeNode mirrorTree(TreeNode root) &#123;
        if(root &#x3D;&#x3D; null) return null;
        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!stack.isEmpty()) &#123;
            TreeNode node &#x3D; stack.pop();
            if(node.left !&#x3D; null) stack.add(node.left);
            if(node.right !&#x3D; null) stack.add(node.right);
            TreeNode tmp &#x3D; node.left;
            node.left &#x3D; node.right;
            node.right &#x3D; tmp;
        &#125;
        return root;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public boolean isSymmetric(TreeNode root) &#123;
        return root &#x3D;&#x3D; null ? true : recur(root.left, root.right);
    &#125;
    boolean recur(TreeNode L, TreeNode R) &#123;
        if(L &#x3D;&#x3D; null &amp;&amp; R &#x3D;&#x3D; null) return true;
        if(L &#x3D;&#x3D; null || R &#x3D;&#x3D; null || L.val !&#x3D; R.val) return false;
        return recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int fib(int n) &#123;
        int[] dp &#x3D; new int[101];
        dp[0] &#x3D; 0;
        dp[1] &#x3D; 1;
        for(int i &#x3D; 2;i &lt;&#x3D; n ; i++)&#123;
            dp[i] &#x3D; (dp[i - 1] + dp[i - 2]) % 1000000007;
        &#125;
        return dp[n] ;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int numWays(int n) &#123;
        int[] dp &#x3D; new int[101];
        dp[0] &#x3D; 1;
        dp[1] &#x3D; 1;
        dp[2] &#x3D; 1;
        for(int i &#x3D; 2;i &lt;&#x3D; n ; i++)&#123;
            dp[i] &#x3D; (dp[i - 1] + dp[i - 2]) % 1000000007;
        &#125;
        return dp[n] ;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int maxProfit(int[] prices) &#123;
        int n &#x3D; prices.length;
        if(n &#x3D;&#x3D; 0 ) return 0;
        int[] dp &#x3D; new int[prices.length];
        dp[0] &#x3D; 0;
        int min &#x3D; prices[0];
        for(int i &#x3D; 1 ; i &lt; prices.length ; i++ )&#123;
            if(prices[i] &lt; min) min &#x3D; prices[i];
            dp[i] &#x3D; Math.max(dp[i-1],prices[i]-min);
        &#125;
        return dp[prices.length-1];
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public int translateNum(int num) &#123;
        int x;
        int y &#x3D; num % 10;
        int i1 &#x3D; 1;
        int i2 &#x3D; 1;
        while(num !&#x3D; 0)&#123;
            num &#x2F;&#x3D; 10;
            x &#x3D; num % 10;
            int tmp &#x3D; 10 * x + y;
            int c &#x3D; (tmp &gt;&#x3D; 10 &amp;&amp; tmp &lt;&#x3D; 25) ? i1 + i2 : i2;
            i1 &#x3D; i2;
            i2 &#x3D; c;
            y &#x3D; x;
        &#125;
        return i2;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;哈希 + 动规
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character, Integer&gt; dic &#x3D; new HashMap&lt;&gt;();
        int res &#x3D; 0, tmp &#x3D; 0;
        for(int j &#x3D; 0; j &lt; s.length(); j++) &#123;
            int i &#x3D; dic.getOrDefault(s.charAt(j), -1); &#x2F;&#x2F; 获取索引 i
            dic.put(s.charAt(j), j); &#x2F;&#x2F; 更新哈希表
            tmp &#x3D; tmp &lt; j - i ? tmp + 1 : j - i; &#x2F;&#x2F; dp[j - 1] -&gt; dp[j]
            res &#x3D; Math.max(res, tmp); &#x2F;&#x2F; max(dp[j - 1], dp[j])
        &#125;
        return res;
    &#125;
&#125;

&#x2F;&#x2F;双指针 + 动规
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character,Integer&gt; dic &#x3D; new HashMap&lt;&gt;();
        int n &#x3D; s.length();
        if( n &#x3D;&#x3D; 0) return 0;
        int i &#x3D; -1, j &#x3D; 0;
        int max &#x3D; 0;
        while(j &lt; n)&#123;
            if(!dic.containsKey(s.charAt(j)))&#123;
                dic.put(s.charAt(j),j);
            &#125;else&#123;
                i &#x3D; Math.max(i, dic.get(s.charAt(j)));
                dic.replace(s.charAt(j),j);
            &#125;
            max &#x3D; Math.max(max,j-i);
            j++;
        &#125;
        return max;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class Solution &#123;
    public ListNode deleteNode(ListNode head, int val) &#123;
        if(head.val &#x3D;&#x3D; val) return head.next;
        ListNode pre &#x3D; head, cur &#x3D; head.next;
        while(cur !&#x3D; null &amp;&amp; cur.val !&#x3D; val) &#123;
            pre &#x3D; cur;
            cur &#x3D; cur.next;
        &#125;
        if(cur !&#x3D; null) pre.next &#x3D; cur.next;
        return head;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode getKthFromEnd(ListNode head, int k) &#123;
        int num &#x3D; 0;
        ListNode tmp&#x3D;head;
        ListNode cur&#x3D;head;
        while(cur.next !&#x3D; null)&#123;
            cur &#x3D; cur.next;
            num++;
        &#125;
        cur.next &#x3D; tmp;
        tmp &#x3D; cur;
        for(int i &#x3D; 0 ; i &lt;&#x3D; num - k + 1 ; i++)&#123;
            cur &#x3D; cur.next;
        &#125;
        tmp.next &#x3D; null;
        return cur;
    &#125;
&#125;

&#x2F;&#x2F;双指针
class Solution &#123;
    public ListNode getKthFromEnd(ListNode head, int k) &#123;
        ListNode former &#x3D; head, latter &#x3D; head;
        for(int i &#x3D; 0; i &lt; k; i++)
            former &#x3D; former.next;
        while(former !&#x3D; null) &#123;
            former &#x3D; former.next;
            latter &#x3D; latter.next;
        &#125;
        return latter;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
        if( l1 &#x3D;&#x3D; null || l2 &#x3D;&#x3D; null) return l1 &#x3D;&#x3D; null ? l2 : l1;
        if(l1.val &lt;&#x3D; l2.val) &#123;
            l1.next &#x3D; mergeTwoLists(l1.next, l2);
            return l1;
        &#125; else &#123;
            l2.next &#x3D; mergeTwoLists(l1, l2.next);
            return l2;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>输入两个链表，找出它们的第一个公共节点。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123;
 *         val = x;
 *         next = null;
 *     &#125;
 * &#125;
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ListNode</span> <span class="token class-name">A</span> <span class="token operator">=</span> headA<span class="token punctuation">,</span> <span class="token class-name">B</span> <span class="token operator">=</span> headB<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">A</span> <span class="token operator">!=</span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token class-name">A</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token class-name">A</span><span class="token punctuation">.</span>next <span class="token operator">:</span> headB<span class="token punctuation">;</span>
            <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token class-name">B</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token class-name">B</span><span class="token punctuation">.</span>next <span class="token operator">:</span> headA<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-005-单词长度的最大乘积"><a href="#剑指-Offer-II-005-单词长度的最大乘积" class="headerlink" title="剑指 Offer II 005. 单词长度的最大乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/aseY1I/">剑指 Offer II 005. 单词长度的最大乘积</a></h4><p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>
<blockquote>
<p>位运算</p>
<p>两个字符串转换成26位二进制 int bitMask</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(char&amp; c : s)  t |&#x3D; 1 &lt;&lt; (c - &#39;a&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>判断是否相同用 &amp; 即可</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maxProduct(vector&lt;string&gt;&amp; words) &#123;
        int res &#x3D; 0, n &#x3D; words.size();
        vector&lt;int&gt; wbit;
        wbit.reserve(n);
        for(string &amp;s : words)&#123;
            int t &#x3D; 0;
            for(char&amp; c : s)&#123;
                t |&#x3D; 1 &lt;&lt; (c - &#39;a&#39;);   
            &#125;
            wbit.emplace_back(t);
        &#125;
        for(int i &#x3D; 1; i &lt; n; i ++)&#123;
            for(int j &#x3D; 0; j &lt; i; j ++)&#123;
                if(wbit[i] &amp; wbit[j]) continue;
                res &#x3D; max(res, int(words[i].size() * words[j].size()));
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-009-乘积小于-K-的子数组"><a href="#剑指-Offer-II-009-乘积小于-K-的子数组" class="headerlink" title="剑指 Offer II 009. 乘积小于 K 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ZVAVXX/">剑指 Offer II 009. 乘积小于 K 的子数组</a></h4><p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">输入</span><span class="token punctuation">:</span> nums <span class="token operator">=</span> [10,5,2,6], k <span class="token operator">=</span> 100
<span class="token target symbol">输出</span><span class="token punctuation">:</span> 8
<span class="token target symbol">解释</span><span class="token punctuation">:</span> 8 个乘积小于 100 的子数组分别为<span class="token punctuation">:</span> [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123;
        if(k &lt;&#x3D; 1) return 0;
        int res &#x3D; 0;
        int i &#x3D; 0;
        int tmp &#x3D; 1;
        for(int j &#x3D; 0 ; j &lt; nums.size() ; j++)&#123;
            tmp *&#x3D; nums[j];
            while(tmp &gt;&#x3D; k)&#123;
                tmp &#x2F;&#x3D; nums[i++];
            &#125;
            res +&#x3D; j - i + 1;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-010-和为-k-的子数组"><a href="#剑指-Offer-II-010-和为-k-的子数组" class="headerlink" title="剑指 Offer II 010. 和为 k 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/QTMn0o/">剑指 Offer II 010. 和为 k 的子数组</a></h4><p>和 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/2VG8Kg/">剑指 Offer II 008. 和大于等于 target 的最短子数组</a> 区分开</p>
<p>给定一个整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">输入</span><span class="token punctuation">:</span>nums <span class="token operator">=</span> [1,1,1], k <span class="token operator">=</span> 2
<span class="token target symbol">输出</span><span class="token punctuation">:</span> 2
<span class="token target symbol">解释</span><span class="token punctuation">:</span> 此题 [1,1] 与 [1,1] 为两种不同的情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;
        &#x2F;&#x2F;前缀和 + Hash
        &#x2F;&#x2F;前缀和： 前i项的总和
        &#x2F;&#x2F;当遍历至i时，我们可以计算从0到i项的和iSum，同时执行检查
        &#x2F;&#x2F;检查当前hash中与当前iSum的差为k的前缀和数量(这就是从前面到第i项的所有和为k的连续数组的数量了)
        &#x2F;&#x2F;并且在res中添加相应数量
        &#x2F;&#x2F;然后将iSum放入map中(若已经存在，则增加相应数量)即可
        int res &#x3D; 0;
        unordered_map&lt;int, int&gt; map;
        &#x2F;&#x2F;为什么这里要多声明1步map[0] &#x3D; 1？ 这样是因为，最一开始的时候(0个元素)，和为0
        &#x2F;&#x2F;这样，当我们首次从左到右一直累加出k时，才能得出正确的结果
        map[0] &#x3D; 1;
        int sum &#x3D; 0;
        for (auto num : nums)
        &#123;
            sum +&#x3D; num;
            &#x2F;&#x2F;检查前缀和中与该sum差距为k的和的数量
            res +&#x3D; map[sum - k];
            &#x2F;&#x2F;将当前sum放入hash中
            ++map[sum];
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-011-0-和-1-个数相同的子数组"><a href="#剑指-Offer-II-011-0-和-1-个数相同的子数组" class="headerlink" title="剑指 Offer II 011. 0 和 1 个数相同的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/A1NYOS/">剑指 Offer II 011. 0 和 1 个数相同的子数组</a></h4><p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    &#x2F;&#x2F; 1. 将0替换为-1，遍历求前缀和
    &#x2F;&#x2F; 2. 在遍历过程中，把前缀和和下标进行映射（多个相同前缀和时只记录最小的下标）
    &#x2F;&#x2F; 3. 每遍历一个元素，就用「当前前缀和」去前面已经统计的前缀和中找到一个使得两者之间区间为0的，并计算这个区间长度
    int findMaxLength(vector&lt;int&gt;&amp; nums) &#123;
        unordered_map&lt;int, int&gt; m;   &#x2F;&#x2F; 此时 value为下标 所以下面用count判断是否存在 而不是单纯map[sum]
        m[0] &#x3D; -1;
        int sum &#x3D; 0, ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            sum +&#x3D; (nums[i] ? 1 : -1);
            if (m.count(sum)) ans &#x3D; max(ans, i - m[sum]);
            else m[sum] &#x3D; i;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-013-二维子矩阵的和"><a href="#剑指-Offer-II-013-二维子矩阵的和" class="headerlink" title="剑指 Offer II 013. 二维子矩阵的和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/O4NDxx/">剑指 Offer II 013. 二维子矩阵的和</a></h4><p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>
<ul>
<li><p>计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。<br>实现 NumMatrix 类：</p>
</li>
<li><p>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化</p>
</li>
<li>int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png" alt="img"></p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: 
["NumMatrix","sumRegion","sumRegion","sumRegion"]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://pic.leetcode-cn.com/1633223209-XPUpHh-juzhen.png" alt="juzhen.png"></p>
<blockquote>
<p><strong>红色框框的值等于 28 - 8 - 9 + 3 = 14</strong></p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class NumMatrix &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; sumMatrix;
    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        int m &#x3D; matrix.size(), n &#x3D; matrix[0].size();
        &#x2F;&#x2F; 前缀数组比原数组多一行多一列，为了代码结构简单一些，不然需要加入边界判断。
        sumMatrix &#x3D; vector&lt;vector&lt;int&gt;&gt;(m+1, vector&lt;int&gt;(n+1, 0)); 
        for(int i &#x3D; 1; i &lt; m+1; ++i)&#123;
            for(int j &#x3D; 1; j &lt; n+1; ++j)&#123;
                &#x2F;&#x2F; 动态规划的思想，当前的位置作为以它为最右下角，上边和左边均至边界的矩阵                 
                &#x2F;&#x2F; 元素之和（包括自身的值）
                sumMatrix[i][j] &#x3D; matrix[i-1][j-1] + sumMatrix[i][j-1] + sumMatrix[i-1][j] - sumMatrix[i-1][j-1];
            &#125;
        &#125; 
    &#125;
    
    int sumRegion(int row1, int col1, int row2, int col2) &#123;
        return sumMatrix[row2+1][col2+1] - sumMatrix[row1][col2+1] - sumMatrix[row2+1][col1] + sumMatrix[row1][col1];
    &#125;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-014-字符串中的变位词"><a href="#剑指-Offer-II-014-字符串中的变位词" class="headerlink" title="剑指 Offer II 014. 字符串中的变位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/MPnaiL/">剑指 Offer II 014. 字符串中的变位词</a></h4><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool checkInclusion(string s1, string s2) &#123;
        if(s1.size() &gt; s2.size()) return false;
        int n &#x3D; s1.size();
        int l &#x3D; 0;
        int r &#x3D; 0;
        unordered_map&lt;int, int&gt; map;
        for(auto x : s1) map[x]++;
        while(r &lt; s2.size())&#123;
            map[s2[r]]--;
            while(map[s2[r]] &lt; 0)&#123;
                map[s2[l]]++;
                l++;
            &#125; 
            if(r - l + 1 &#x3D;&#x3D; n) return true;
            r++;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-015-字符串中的所有变位词"><a href="#剑指-Offer-II-015-字符串中的所有变位词" class="headerlink" title="剑指 Offer II 015. 字符串中的所有变位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/VabMRr/">剑指 Offer II 015. 字符串中的所有变位词</a></h4><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>变位词 指字母相同，但排列不同的字符串。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; findAnagrams(string s, string p) &#123;
        vector&lt;int&gt; res;
        if(s.size() &lt; p.size()) return res;
        int n &#x3D; p.size();
        unordered_map&lt;char, int&gt; map;
        for (auto x : p) map[x]++;
        int l &#x3D; 0;
        int r &#x3D; 0;
        while (r &lt; s.size())&#123;
            if(map[s[r]] &gt; 0) &#123;
                n--;
                map[s[r]]--;
            &#125;
            else map[s[r]]--;

            if(n &#x3D;&#x3D; 0)&#123;
                res.push_back(l);
            &#125;
            
            if(r - l + 1 &#x3D;&#x3D; p.size())&#123;
                if(map[s[l]] &gt;&#x3D; 0) &#123;  &#x2F;&#x2F; 如果左边界的字符确实是p中的字符 才需要把n+1
                    n++;
                    map[s[l]]++;
                &#125;
                else map[s[l]]++;
                l++;
            &#125;
            r++;
        &#125;
        return res;
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-016-不含重复字符的最长子字符串"><a href="#剑指-Offer-II-016-不含重复字符的最长子字符串" class="headerlink" title="剑指 Offer II 016. 不含重复字符的最长子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wtcaE1/">剑指 Offer II 016. 不含重复字符的最长子字符串</a></h4><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长连续子字符串</strong> 的长度。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) &#123;
        unordered_map&lt;char, int&gt; map;
        int res &#x3D; 0;
        for(int i &#x3D; 0 ,j &#x3D; 0; j &lt; s.size(); j++)&#123;
            while(map[s[j]] &#x3D;&#x3D; 1) &#123;
                map[s[i++]]--;
            &#125;
            map[s[j]] &#x3D; 1;
            res &#x3D; max(j - i + 1, res);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-017-含有所有字符的最短字符串"><a href="#剑指-Offer-II-017-含有所有字符的最短字符串" class="headerlink" title="剑指 Offer II 017. 含有所有字符的最短字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串</a></h4><p>给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。</p>
<p>如果 s 中存在多个符合条件的子字符串，返回任意一个。</p>
<p>注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC" 
解释：最短子字符串 "BANC" 包含了字符串 t 的所有字符 'A'、'B'、'C'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    string minWindow(string s, string t) &#123;
        unordered_map&lt;int, int&gt; map;
        for(auto x : t) map[x]++;
        int n &#x3D; t.size();
        int l &#x3D; 0;
        int r &#x3D; 0;
        int res &#x3D; INT_MAX;
        int start &#x3D; 0;
        while (r &lt; s.size())&#123;
            if(map[s[r]] &gt; 0)&#123;
                map[s[r]]--;
                n--;
            &#125;
            else map[s[r]]--;
            if(n &#x3D;&#x3D; 0)&#123;
                while(map[s[l]] &lt; 0)&#123;
                    map[s[l++]]++;
                &#125;
                if(res &gt; r - l + 1)&#123;
                    start &#x3D; l;
                    res &#x3D; r - l + 1;
                &#125;
                map[s[l++]]++;
                n++;
            &#125;
            r++;
        &#125;
        return res &#x3D;&#x3D; INT_MAX ? &quot;&quot; : s.substr(start, res);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-018-有效的回文"><a href="#剑指-Offer-II-018-有效的回文" class="headerlink" title="剑指 Offer II 018. 有效的回文"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/XltzEq/">剑指 Offer II 018. 有效的回文</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isPalindrome(string s) &#123;
        int left &#x3D; 0, right &#x3D; s.size()-1;
        while(left&lt;right)&#123;
            while(left&lt;s.size() &amp;&amp; !isValid(s[left]))&#123;
                left++;
            &#125;
            while(right&gt;&#x3D;0 &amp;&amp; !isValid(s[right]))&#123;
                right--;
            &#125;
            &#x2F;&#x2F;越界 为空 直接返回1
            if(left&gt;&#x3D;s.size()|| right&lt;0) return 1;
            if(tolower(s[left]) !&#x3D; tolower(s[right]))
                return 0;
            left++;
            right--;
        &#125;
        return 1;
    &#125;
    bool isValid(char&amp; ch)&#123;
        if(tolower(ch)&gt;&#x3D;&#39;a&#39; &amp;&amp; tolower(ch)&lt;&#x3D;&#39;z&#39;  ||(ch&gt;&#x3D;&#39;0&#39; &amp;&amp;ch&lt;&#x3D;&#39;9&#39;))
            return 1;
        return 0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-019-最多删除一个字符得到回文"><a href="#剑指-Offer-II-019-最多删除一个字符得到回文" class="headerlink" title="剑指 Offer II 019. 最多删除一个字符得到回文"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/RQku0D/">剑指 Offer II 019. 最多删除一个字符得到回文</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool validPalindrome(string s) &#123;
        int l&#x3D;0,r&#x3D;s.size()-1;
        while(l&lt;&#x3D;r &amp;&amp; s[l]&#x3D;&#x3D;s[r] )&#123;
            l++;
            r--;
        &#125;
        return reverse(l+1,r,s)||reverse(l,r-1,s);
    &#125;
    bool reverse(int l,int r,string s)&#123;
        while(l &lt;&#x3D; r &amp;&amp; s[l] &#x3D;&#x3D; s[r])&#123;
            l++;
            r--;
        &#125;
        return r &lt;&#x3D; l;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-048-序列化与反序列化二叉树"><a href="#剑指-Offer-II-048-序列化与反序列化二叉树" class="headerlink" title="剑指 Offer II 048. 序列化与反序列化二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/h54YBf/">剑指 Offer II 048. 序列化与反序列化二叉树</a></h4><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Codec &#123;
public:

    &#x2F;&#x2F; Encodes a tree to a single string.
    string serialize(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; q;
        string s;
        if (root !&#x3D; nullptr) q.push(root);
        while (!q.empty())&#123;
            TreeNode* node &#x3D; q.front();
            q.pop();
            if (node !&#x3D; nullptr) &#123;
                s +&#x3D; to_string(node-&gt;val);
                s +&#x3D; &quot;_&quot;;
                if(node -&gt; left !&#x3D; nullptr) q.push(node-&gt;left);
                else q.push(nullptr);
                if(node -&gt; right !&#x3D; nullptr) q.push(node-&gt;right);
                else q.push(nullptr);
            &#125; 
            else s +&#x3D; &quot;#_&quot;;
        &#125;
        return s;
    &#125;

    &#x2F;&#x2F; Decodes your encoded data to tree.
    TreeNode* deserialize(string data) &#123;
        int n &#x3D; data.size();
        queue&lt;TreeNode*&gt; q;
        if (data &#x3D;&#x3D; &quot;&quot;) return nullptr;
        pair&lt;int,int&gt; res &#x3D; judge(data, 0);
        TreeNode* root &#x3D; new TreeNode(res.first);
        q.push(root);
        int i &#x3D; res.second + 1;
        while(!q.empty() &amp;&amp; i &lt; data.size())&#123;
            TreeNode* node &#x3D; q.front();
            q.pop();

            res &#x3D; judge(data, i);
            i &#x3D; res.second + 1;
            if(res.first !&#x3D; -1001) &#123;
                TreeNode* left_ &#x3D; new TreeNode(res.first);
                node -&gt; left &#x3D; left_;
                q.push(left_);
            &#125;
            
            res &#x3D; judge(data, i);
            i &#x3D; res.second + 1;
            if(res.first !&#x3D; -1001) &#123;
                TreeNode* right_ &#x3D; new TreeNode(res.first);
                node -&gt; right &#x3D; right_;
                q.push(right_);
            &#125;
        &#125;
        return root;
    &#125;

    pair&lt;int,int&gt; judge(string data , int start)&#123;
        int x &#x3D; 0;
        for(int i &#x3D; start, flag &#x3D; 0; i &lt; data.size() ; i++)&#123;
            if(data[i] &#x3D;&#x3D; &#39;-&#39;) flag &#x3D; 1;
            else if (data[i] &#x3D;&#x3D; &#39;#&#39;)&#123;
                return &#123;-1001, i+1&#125;;
            &#125;
            else if (data[i] !&#x3D; &#39;_&#39;)&#123;
                x *&#x3D; 10;
                x +&#x3D; data[i] - &#39;0&#39;;
            &#125;
            else &#123;
                if(flag &#x3D;&#x3D; 1) x *&#x3D; -1;
                return &#123;x, i&#125;;
            &#125;
        &#125;
        return &#123;-1001,-1&#125;;
    &#125;
&#125;;


&#x2F;&#x2F; Your Codec object will be instantiated and called as such:
&#x2F;&#x2F; Codec ser, deser;
&#x2F;&#x2F; TreeNode* ans &#x3D; deser.deserialize(ser.serialize(root));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-024-反转链表"><a href="#剑指-Offer-II-024-反转链表" class="headerlink" title="剑指 Offer II 024. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/UHnkqh/">剑指 Offer II 024. 反转链表</a></h4><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;递归
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        return reverse(nullptr,head); 
    &#125;

    ListNode* reverse(ListNode* pre, ListNode* cur)&#123;
        if(cur &#x3D;&#x3D; nullptr) return pre;
        ListNode* tmp &#x3D; cur -&gt; next;
        cur -&gt; next &#x3D; pre;
        pre &#x3D; cur;
        cur &#x3D; tmp;
        return reverse(pre,cur);
    &#125;   
&#125;;

&#x2F;&#x2F;迭代
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        if (head &#x3D;&#x3D; nullptr) return head;
        ListNode* pre &#x3D; nullptr;
        ListNode* cur &#x3D; head;
        while (cur !&#x3D; nullptr)&#123;
            ListNode* temp &#x3D; cur-&gt;next;
            cur-&gt;next &#x3D; pre;
            pre &#x3D; cur;
            cur &#x3D; temp;
        &#125;
        return pre;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-026-重排链表"><a href="#剑指-Offer-II-026-重排链表" class="headerlink" title="剑指 Offer II 026. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/LGjMqU/">剑指 Offer II 026. 重排链表</a></h4><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p><code>L0 → L1 → … → Ln-1 → Ln</code><br>请将其重新排列后变为：</p>
<p><code>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</code></p>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230318231605479.png" alt="image-20230318231605479"></p>
<blockquote>
<p><strong>三合一</strong>： <strong>①找中间节点-快慢指针（倒数第n个/中间）  ②递归/迭代反转链表   ③链表交叉合体</strong></p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    void reorderList(ListNode* head) &#123;
        if (head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) return;
        ListNode* mid &#x3D; FindMiddleNode(head);   &#x2F;&#x2F; 找到中间节点
        ListNode* l1 &#x3D; head;
        ListNode* l2 &#x3D; mid-&gt;next;
        mid-&gt;next &#x3D; nullptr;
        l2 &#x3D; ReverseList(l2);   &#x2F;&#x2F; 反转后半段的链表节点
        mergeList(l1, l2);      &#x2F;&#x2F; 合并两端长度相差不超过1的链表
    &#125;

    &#x2F;&#x2F; 快慢指针找到中间节点
    ListNode* FindMiddleNode(ListNode* head) &#123;
        ListNode* slow &#x3D; head;
        ListNode* fast &#x3D; head;
        while (fast-&gt;next !&#x3D; nullptr &amp;&amp; fast-&gt;next-&gt;next !&#x3D; nullptr) &#123;
            slow &#x3D; slow-&gt;next;
            fast &#x3D; fast-&gt;next-&gt;next;
        &#125;
        return slow;
    &#125;

    &#x2F;&#x2F; 反转链表
    ListNode* ReverseList(ListNode* head) &#123;
        ListNode* pre &#x3D; nullptr;
        ListNode* cur &#x3D; head;
        ListNode* next;
        while (cur !&#x3D; nullptr) &#123;
            next &#x3D; cur-&gt;next;
            cur-&gt;next &#x3D; pre; &#x2F;&#x2F; 反转
            pre &#x3D; cur;       &#x2F;&#x2F; 向后移动
            cur &#x3D; next;
        &#125;
        return pre;
    &#125;

    &#x2F;&#x2F; 合并链表
    void mergeList(ListNode* l1, ListNode* l2) &#123;
        ListNode* temp1;
        ListNode* temp2;
        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;
            temp1 &#x3D; l1-&gt;next;
            temp2 &#x3D; l2-&gt;next;
            
            l1-&gt;next &#x3D; l2;
            l1 &#x3D; temp1;

            l2-&gt;next &#x3D; l1;
            l2 &#x3D; temp2;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-027-回文链表"><a href="#剑指-Offer-II-027-回文链表" class="headerlink" title="剑指 Offer II 027. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/aMhZSa/">剑指 Offer II 027. 回文链表</a></h4><blockquote>
<p>一样的套路 <strong>快慢指针找中点</strong> + <strong>反转链表</strong> + <strong>链表对比/计算</strong></p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isPalindrome(ListNode* head) &#123;
        if(head &#x3D;&#x3D; nullptr || head -&gt; next &#x3D;&#x3D; nullptr) return true;
        ListNode* mid &#x3D; find(head);
        ListNode* rhead &#x3D; reverse(mid -&gt; next);
        return judge(head,rhead);
    &#125;

    ListNode* find(ListNode* head)&#123;
        if(head &#x3D;&#x3D; nullptr) return nullptr;
        ListNode* sp &#x3D; head;
        ListNode* fp &#x3D; head;
        while(fp -&gt; next !&#x3D; nullptr &amp;&amp; fp -&gt; next -&gt; next !&#x3D; nullptr)&#123;
            sp &#x3D; sp -&gt; next;
            fp &#x3D; fp -&gt; next -&gt; next;
        &#125;
        return sp;
    &#125;

    ListNode* reverse(ListNode* head) &#123;
        if(head &#x3D;&#x3D; nullptr) return nullptr;
        ListNode* pre &#x3D; nullptr;
        ListNode* cur &#x3D; head;
        while(cur !&#x3D; nullptr)&#123;
            ListNode* tmp &#x3D; cur -&gt; next;
            cur -&gt; next &#x3D; pre;
            pre &#x3D; cur;
            cur &#x3D; tmp;
        &#125;
        return pre;
    &#125;

    bool judge(ListNode* head, ListNode* rhead)&#123;
        if(head &#x3D;&#x3D; nullptr || rhead &#x3D;&#x3D; nullptr) return false;
        while(rhead !&#x3D; nullptr)&#123;
            if(head -&gt; val !&#x3D; rhead -&gt; val) return false;
            head &#x3D; head -&gt; next;
            rhead &#x3D; rhead -&gt; next;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-028-展平多级双向链表"><a href="#剑指-Offer-II-028-展平多级双向链表" class="headerlink" title="剑指 Offer II 028. 展平多级双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/Qv1Da2/">剑指 Offer II 028. 展平多级双向链表</a></h4><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230319141732320.png" alt="image-20230319141732320"></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png" alt="img" style="zoom: 67%;" /></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png" alt="img" style="zoom:150%;" /></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    Node* flatten(Node* head) &#123;
        if(head &#x3D;&#x3D; nullptr) return head;
        stack&lt;Node*&gt; st;
        st.push(head);
        Node* pre &#x3D; nullptr;
        while(!st.empty())&#123;
            Node* node &#x3D; st.top();
            st.pop();
            if(pre)&#123;
                pre -&gt; next &#x3D; node;
                node -&gt; prev &#x3D; pre;
            &#125;
            if(node -&gt; next) st.push(node -&gt; next);
            if(node -&gt; child) st.push(node -&gt; child);
            node -&gt; child &#x3D; nullptr;
            pre &#x3D; node;
        &#125;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-029-排序的循环链表"><a href="#剑指-Offer-II-029-排序的循环链表" class="headerlink" title="剑指 Offer II 029. 排序的循环链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4ueAj6/">剑指 Offer II 029. 排序的循环链表</a></h4><p>给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。</p>
<p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p>
<p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p>
<p>如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230319141714467.png" alt="image-20230319141714467"></p>
<blockquote>
<p>先对链表进行一次完成遍历，遍历过程中维护节点最值 max 和 min，由于链表是循环的，我们需要使用 he.next != ans 作为我们循环的结束条件，含义为回到链表开头。</p>
<p>此时根据最大值和最小值是否相等（即整段链表值是否一致）来进行分情况讨论：</p>
<ul>
<li>若满足 <code>max = min</code>，此时目标节点 t 插入在哪个位置都满足条件，我们直接将其与 <code>ans</code>关联即可；</li>
<li>若不满足<code>max = min</code>，此时我们先对链表进行一次遍历，找到有序列表的结束点（结束点的定义为：当前节点值为最大值，下一节点值为最小值。即为有序链表分割位置的左端点），在根据「插入值 <code>insertVal</code> 是否为新链表的最值」进行分情况讨论：<ul>
<li>若满足<code>insertVal &gt;= max  或 insertVal &lt;= min</code>，说明目标节点 <code>t</code> 插入分割位置即可；</li>
<li>若不满足上述两条件，需要从分割位置出发，找到目标插入位置，即满足 <code>head-&gt;val &lt;= insertVal &amp;&amp; insertVal &lt;= head-&gt;next-&gt;val</code> 的位置。</li>
</ul>
</li>
</ul>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    Node* next;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val &#x3D; _val;
        next &#x3D; NULL;
    &#125;

    Node(int _val, Node* _next) &#123;
        val &#x3D; _val;
        next &#x3D; _next;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    Node* insert(Node* head, int insertVal) &#123;
        Node* t &#x3D; new Node(insertVal);
        t -&gt; next &#x3D; t;
        if (head &#x3D;&#x3D; nullptr) return t;
        Node* ans &#x3D; head;
        int minum &#x3D; head-&gt;val, maxum &#x3D; head-&gt;val;
        while (head -&gt; next !&#x3D; ans)&#123;
            head &#x3D; head -&gt; next;
            minum &#x3D; min(minum, head-&gt;val);
            maxum &#x3D; max(maxum, head-&gt;val);
        &#125;
        if (minum &#x3D;&#x3D; maxum)&#123;
            t-&gt;next &#x3D; ans-&gt;next;
            ans-&gt;next &#x3D; t;
        &#125; 
        else &#123;
            while(!(head-&gt;val &#x3D;&#x3D; maxum &amp;&amp; head-&gt;next-&gt;val &#x3D;&#x3D; minum)) head &#x3D; head-&gt;next;
            while(!(insertVal &lt;&#x3D; minum || insertVal &gt;&#x3D; maxum) &amp;&amp; !(head-&gt;val &lt;&#x3D; insertVal &amp;&amp; insertVal &lt;&#x3D; head-&gt;next-&gt;val)) head &#x3D; head-&gt;next;
            t-&gt;next &#x3D; head-&gt;next;
            head-&gt;next &#x3D; t;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-033-变位词组"><a href="#剑指-Offer-II-033-变位词组" class="headerlink" title="剑指 Offer II 033. 变位词组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sfvd7V/">剑指 Offer II 033. 变位词组</a></h4><blockquote>
<p>给定一个字符串数组 <code>strs</code> ，将 <strong>变位词</strong> 组合在一起。 可以按任意顺序返回结果列表。</p>
<p><strong>注意：</strong>若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。</p>
</blockquote>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230321201858947.png" alt="image-20230321201858947"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string,vector&lt;string&gt;&gt; map;
        vector&lt;vector&lt;string&gt;&gt; res;
        for(string x : strs)&#123;
            string y &#x3D; x;
            sort(x.begin(),x.end());
            map[x].push_back(y);
        &#125;
        for(auto it &#x3D; map.begin(); it !&#x3D; map.end() ; it++) res.push_back(it -&gt; second);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-035-最小时间差"><a href="#剑指-Offer-II-035-最小时间差" class="headerlink" title="剑指 Offer II 035. 最小时间差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/569nqc/">剑指 Offer II 035. 最小时间差</a></h4><p>给定一个 24 小时制（小时:分钟 <strong>“HH:MM”</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>
<blockquote>
<p>将此列表的最小时间 <code>mins[0]</code> 加上 <code>24 * 60</code> 追加至列表尾部，用于处理最大值、最小值的差值这种特殊情况。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findMinDifference(vector&lt;string&gt;&amp; timePoints) &#123;
        if (timePoints.size() &gt; 24 * 60) return 0;
        vector&lt;int&gt; mins;
        for (auto t : timePoints) mins.push_back(stoi(t.substr(0, 2)) * 60 + stoi(t.substr(3)));
        sort(mins.begin(), mins.end());
        mins.push_back(mins[0] + 24 * 60);
        int res &#x3D; 24 * 60;
        for (int i &#x3D; 1; i &lt; mins.size(); ++i)
            res &#x3D; min(res, mins[i] - mins[i - 1]);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-034-外星语言是否排序"><a href="#剑指-Offer-II-034-外星语言是否排序" class="headerlink" title="剑指 Offer II 034. 外星语言是否排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lwyVBB/">剑指 Offer II 034. 外星语言是否排序</a></h4><p>某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。</p>
<p>给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    unordered_map&lt;char, int&gt; dict;
    bool comp(string &amp;a, string &amp;b)&#123;
        int sta &#x3D; a.size();
        int stb &#x3D; b.size();
        int index &#x3D; 0;
        while(index &lt; sta &amp;&amp; index &lt; stb)&#123;
            if(a[index] &#x3D;&#x3D; b[index]) index++;
            else if(dict[a[index]] &lt; dict[b[index]]) return true;
            else if(dict[a[index]] &gt; dict[b[index]]) return false;
        &#125;
        if(index &#x3D;&#x3D; sta) return true;
        return false;
    &#125;

    bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) &#123;
        for(int i &#x3D; 0 ; i &lt; order.size() ; i++)&#123;
            dict[order[i]] &#x3D; i;
        &#125;
        for(int i &#x3D; 0 ; i &lt; words.size() - 1; i++)&#123;
            if(!comp(words[i], words[i+1])) return false;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-037-小行星碰撞"><a href="#剑指-Offer-II-037-小行星碰撞" class="headerlink" title="剑指 Offer II 037. 小行星碰撞"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/XagZNi/">剑指 Offer II 037. 小行星碰撞</a></h4><p>给定一个整数数组 asteroids，表示在同一行的行星。</p>
<p>对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。</p>
<p>找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322105123270.png" alt="image-20230322105123270"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) &#123;
        vector&lt;int&gt;res;
        for(auto &amp;i : asteroids)&#123;
            while(!res.empty() &amp;&amp; i &lt; 0 &amp;&amp; res.back() &gt; 0 &amp;&amp; -i &gt; res.back()) res.pop_back();
            if(res.empty() || res.back() &lt; 0 || i &gt; 0) res.push_back(i);
            else if(res.back() + i &#x3D;&#x3D; 0) res.pop_back();
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-036-后缀表达式"><a href="#剑指-Offer-II-036-后缀表达式" class="headerlink" title="剑指 Offer II 036. 后缀表达式"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/8Zf90G/">剑指 Offer II 036. 后缀表达式</a></h4><p>根据 逆波兰表示法，求该后缀表达式的计算结果。</p>
<p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322105748534.png" alt="image-20230322105748534"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        stack&lt;string&gt; st;
        for(auto s : tokens) &#123;
            if(s !&#x3D; &quot;+&quot; &amp;&amp; s !&#x3D; &quot;-&quot; &amp;&amp; s!&#x3D; &quot;*&quot; &amp;&amp; s!&#x3D; &quot;&#x2F;&quot;) st.push(s);
            else &#123;
                int right &#x3D; stoi(st.top());
                st.pop();
                int left &#x3D; stoi(st.top());
                st.pop();
                if(s &#x3D;&#x3D; &quot;+&quot;) st.push(to_string(left + right));
                else if (s &#x3D;&#x3D; &quot;-&quot;) st.push(to_string(left - right));
                else if (s &#x3D;&#x3D; &quot;*&quot;) st.push(to_string(left * right));
                else if (s &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(to_string(left &#x2F; right));
            &#125;
        &#125;
        return stoi(st.top());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-038-每日温度"><a href="#剑指-Offer-II-038-每日温度" class="headerlink" title="剑指 Offer II 038. 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/iIQa4I/">剑指 Offer II 038. 每日温度</a></h4><p>请根据每日 气温 列表 temperatures ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322110613674.png" alt="image-20230322110613674"></p>
<blockquote>
<p><strong>单调递减栈</strong></p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;
        stack&lt;int&gt; st; &#x2F;&#x2F; 递减栈
        vector&lt;int&gt; result(T.size(), 0);
        st.push(0);
        for (int i &#x3D; 1; i &lt; T.size(); i++) &#123;
            while (!st.empty() &amp;&amp; T[i] &gt; T[st.top()]) &#123; &#x2F;&#x2F; 注意栈不能为空
                result[st.top()] &#x3D; i - st.top();
                st.pop();
            &#125;
            st.push(i);

        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int trap(vector&lt;int&gt;&amp; height) &#123;
        stack&lt;int&gt; st;
        st.push(0);
        int sum &#x3D; 0;
        for (int i &#x3D; 1; i &lt; height.size(); i++) &#123;
            while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;
                int mid &#x3D; st.top();
                st.pop();
                if (!st.empty()) &#123;
                    int h &#x3D; min(height[st.top()], height[i]) - height[mid];
                    int w &#x3D; i - st.top() - 1;
                    sum +&#x3D; h * w;
                &#125;
            &#125;
            st.push(i);
        &#125;
        return sum;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322123113881.png" alt="image-20230322123113881"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        stack&lt;int&gt; st;
        vector&lt;int&gt; res(nums1.size(),-1);
        st.push(0);
        unordered_map&lt;int,int&gt; m;
        for(int i &#x3D; 0 ; i &lt; nums1.size() ; i++) m[nums1[i]] &#x3D; i;

        for(int i &#x3D; 1 ; i &lt; nums2.size() ; i++)&#123;
            if(nums2[i] &lt;&#x3D; nums2[st.top()]) st.push(i);
            else &#123;
                while(!st.empty() &amp;&amp; nums2[i] &gt; nums2[st.top()])&#123;
                    if(m.count(nums2[st.top()]) &gt; 0)&#123;
                        res[m[nums2[st.top()]]] &#x3D; nums2[i];
                    &#125;
                    st.pop();
                &#125;
                st.push(i);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322123843258.png" alt="image-20230322123843258"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; res(nums.size(), -1);
        stack&lt;int&gt; st;
        st.push(0);
        for(int i &#x3D; 0 ; i &lt; nums.size() * 2 ; i++)&#123;
            while(!st.empty() &amp;&amp; nums[i % nums.size()] &gt; nums[st.top()])&#123;
                res[st.top()] &#x3D; nums[i % nums.size()];
                st.pop();
            &#125;
            st.push(i % nums.size());
        &#125; 
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230322124746593.png" alt="image-20230322124746593"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;
        int res &#x3D; 0;
        stack&lt;int&gt; st;
        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        st.push(0);
        for(int i &#x3D; 1 ; i &lt; heights.size() ; i++)&#123;
            while(!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()])&#123;
                int mid &#x3D; st.top();
                st.pop();
                int h &#x3D; heights[mid];
                int w &#x3D; i - st.top() - 1;
                res &#x3D; max(res, h*w);
            &#125;
            st.push(i);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-040-矩阵中最大的矩形"><a href="#剑指-Offer-II-040-矩阵中最大的矩形" class="headerlink" title="剑指 Offer II 040. 矩阵中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/PLYXKQ/">剑指 Offer II 040. 矩阵中最大的矩形</a></h4><blockquote>
<p>因为最大矩阵一定是以矩阵的某一行为底边的，所以可以遍历各行寻找答案。以矩阵第一行为底的最大矩阵面积，等效于前一题中的直方图数组为 [1, 0, 1, 0, 0]；以第二行等效为 [2, 0, 2, 1, 1]；以第三行等效为 [3, 1, 3, 2, 2]；以第四行等效为 [4, 0, 0, 3, 0]；遍历完所有行，就能得到最大矩形的面积。注意一点，原矩阵内存的是字符。</p>
</blockquote>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230323123206697.png" alt="image-20230323123206697"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int maximalRectangle(vector&lt;string&gt;&amp; matrix) &#123;
        if (matrix.size() &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        vector&lt;int&gt; heights(matrix[0].size(), 0);
        int maxArea &#x3D; 0;
        for (int i &#x3D; 0; i &lt; matrix.size(); ++i) &#123;
            for (int j &#x3D; 0; j &lt; matrix[0].size(); ++j) &#123;
                if (matrix[i][j] &#x3D;&#x3D; &#39;0&#39;) &#123;
                    heights[j] &#x3D; 0;
                &#125;
                else &#123;
                    heights[j] +&#x3D; matrix[i][j] - &#39;0&#39;;
                &#125;
            &#125;
            maxArea &#x3D; max(maxArea, largestRectangleArea(heights));
        &#125;
        return maxArea;
    &#125;

    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;
        stack&lt;int&gt; sta;
        sta.push(-1);
        int maxArea &#x3D; 0;
        for (int i &#x3D; 0; i &lt; heights.size(); ++i) &#123;
            while (sta.top() !&#x3D; -1 &amp;&amp; heights[sta.top()] &gt;&#x3D; heights[i]) &#123;
                int height &#x3D; heights[sta.top()];
                sta.pop();
                int width &#x3D; i - sta.top() - 1;
                maxArea &#x3D; max(maxArea, height * width);
            &#125;
            sta.push(i);
        &#125;

        while (sta.top() !&#x3D; -1) &#123;
            int height &#x3D; heights[sta.top()];
            sta.pop();
            int width &#x3D; heights.size() - sta.top() - 1;
            maxArea &#x3D; max(maxArea, height * width);
        &#125;
        return maxArea;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-047-二叉树剪枝"><a href="#剑指-Offer-II-047-二叉树剪枝" class="headerlink" title="剑指 Offer II 047. 二叉树剪枝"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pOCWxh/">剑指 Offer II 047. 二叉树剪枝</a></h4><p>给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。</p>
<p>节点 node 的子树为 node 本身，以及所有 node 的后代。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    TreeNode* pruneTree(TreeNode* root) &#123;
        if (!root) &#123;
            return nullptr;
        &#125;
        root-&gt;left &#x3D; pruneTree(root-&gt;left);
        root-&gt;right &#x3D; pruneTree(root-&gt;right);
        if (root-&gt;val &#x3D;&#x3D; 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;
            return nullptr;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-049-从根节点到叶节点的路径数字之和"><a href="#剑指-Offer-II-049-从根节点到叶节点的路径数字之和" class="headerlink" title="剑指 Offer II 049. 从根节点到叶节点的路径数字之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3Etpl5/">剑指 Offer II 049. 从根节点到叶节点的路径数字之和</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; res;
    void travl(TreeNode* root, string s)&#123;
        if(root -&gt; left &#x3D;&#x3D; nullptr &amp;&amp; root -&gt; right &#x3D;&#x3D; nullptr) &#123;
            s +&#x3D; to_string(root-&gt;val);
            res.push_back(stoi(s));
            return;
        &#125;
        s +&#x3D; to_string(root-&gt;val);
        if(root -&gt; left !&#x3D; nullptr) travl(root-&gt;left, s);
        if(root -&gt; right !&#x3D; nullptr) travl(root-&gt;right, s);
    &#125;

    int sumNumbers(TreeNode* root) &#123;
        int ans &#x3D; 0;
        travl(root, &quot;&quot;);
        for(auto x : res) ans +&#x3D; x;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-050-向下的路径节点之和"><a href="#剑指-Offer-II-050-向下的路径节点之和" class="headerlink" title="剑指 Offer II 050. 向下的路径节点之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/6eUYwP/">剑指 Offer II 050. 向下的路径节点之和</a></h4><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230327145647879.png" alt="image-20230327145647879"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int res;
    void dfs(TreeNode* root, int targetSum)&#123;
        if(!root) return;
        dfsnode(root,targetSum, 0);
        dfs(root-&gt;left, targetSum);
        dfs(root-&gt;right, targetSum); 
    &#125;

    void dfsnode(TreeNode* node, int targetSum, long long cur)&#123;
        if(!node) return;
        cur +&#x3D; node-&gt;val;
        if(cur &#x3D;&#x3D; targetSum) res++;
        dfsnode(node-&gt;left, targetSum, cur);
        dfsnode(node-&gt;right, targetSum, cur);
    &#125;

    int pathSum(TreeNode* root, int targetSum) &#123;
        dfs(root, targetSum);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-051-节点之和最大的路径"><a href="#剑指-Offer-II-051-节点之和最大的路径" class="headerlink" title="剑指 Offer II 051. 节点之和最大的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jC7MId/">剑指 Offer II 051. 节点之和最大的路径</a></h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int manu &#x3D; -1000;
    int travl(TreeNode* node)&#123;
        if(!node) return -1000;
        int left &#x3D; travl(node-&gt;left);
        int right &#x3D; travl(node-&gt;right);
        manu &#x3D; max(manu, node-&gt;val + left + right);
        manu &#x3D; max(manu, left);
        manu &#x3D; max(manu, right);
        int val &#x3D; max(node-&gt;val, node-&gt;val + left);
        val &#x3D; max(node-&gt;val + right, val);
        return val;
    &#125;

    int maxPathSum(TreeNode* root) &#123;
        int maxn &#x3D; travl(root);
        return max(maxn, manu);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-052-展平二叉搜索树"><a href="#剑指-Offer-II-052-展平二叉搜索树" class="headerlink" title="剑指 Offer II 052. 展平二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/NYBBNL/">剑指 Offer II 052. 展平二叉搜索树</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230327171745160.png" alt="image-20230327171745160"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 递归
class Solution &#123;
public:
    TreeNode* newRoot &#x3D; nullptr, *pre &#x3D; new TreeNode(-1);
    TreeNode* increasingBST(TreeNode* root) &#123;
        inorder(root);
        return newRoot;
    &#125;

    void inorder(TreeNode* root) &#123;
        if (!root) return;
        inorder(root-&gt;left);
        
        if (!newRoot) newRoot &#x3D; root;
        pre-&gt;right &#x3D; root;
        root-&gt;left &#x3D; nullptr;
        pre &#x3D; root;

        inorder(root-&gt;right);
    &#125;
&#125;;

&#x2F;&#x2F;耍赖法
class Solution &#123;
public:
    TreeNode* increasingBST(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; st;
        vector&lt;TreeNode*&gt; res;
        if(root &#x3D;&#x3D; nullptr) return root;
        st.push(root);
        while(!st.empty())&#123;
            TreeNode* node &#x3D; st.top();
            if(node !&#x3D; nullptr)&#123;
                st.pop();
                if(node-&gt;right) st.push(node-&gt;right);
                st.push(node);
                st.push(nullptr);
                if(node-&gt;left) st.push(node-&gt;left);
            &#125;
            else &#123;
                st.pop();
                node &#x3D; st.top();
                st.pop();
                res.push_back(node);
            &#125;
        &#125;
        for(int i &#x3D; 0 ; i &lt; res.size()-1 ; i++)&#123;
            cout &lt;&lt; res[i]-&gt;val &lt;&lt; endl;
            res[i]-&gt;left &#x3D; nullptr;
            res[i]-&gt;right &#x3D; res[i+1];
        &#125;
        res[res.size()-1]-&gt;right &#x3D; nullptr;
        res[res.size()-1]-&gt;left &#x3D; nullptr;
        root &#x3D; res[0];
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-062-实现前缀树"><a href="#剑指-Offer-II-062-实现前缀树" class="headerlink" title="剑指 Offer II 062. 实现前缀树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/QC3q1f/">剑指 Offer II 062. 实现前缀树</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Trie &#123;
    Trie *child[26];
    bool isWord;
public:
    &#x2F;** Initialize your data structure here. *&#x2F;
    Trie() &#123;
        isWord &#x3D; false;
        for(int i&#x3D;0;i&lt;26;i++)&#123;
            child[i] &#x3D; nullptr;
        &#125;
    &#125;
    
    &#x2F;** Inserts a word into the trie. *&#x2F;
    void insert(string word) &#123;
        Trie *t &#x3D; this;
        for(char c: word)&#123;
            if(!t -&gt; child[c-&#39;a&#39;])&#123;
                t-&gt;child[c-&#39;a&#39;] &#x3D; new Trie();
            &#125;
            t &#x3D; t-&gt;child[c-&#39;a&#39;];
        &#125;
        t-&gt;isWord &#x3D; true;
    &#125;
    
    &#x2F;** Returns if the word is in the trie. *&#x2F;
    bool search(string word) &#123;
        Trie *t &#x3D; this;
        for(char c:word)&#123;
            if(!t -&gt; child[c - &#39;a&#39;])&#123;
                return false;
            &#125;
            t &#x3D; t-&gt;child[c - &#39;a&#39;];
        &#125;
        return t-&gt;isWord;
    &#125;
    
    &#x2F;** Returns if there is any word in the trie that starts with the given prefix. *&#x2F;
    bool startsWith(string prefix) &#123;
        Trie *t &#x3D; this;
        for(char c:prefix)&#123;
            if(!t-&gt;child[c-&#39;a&#39;])&#123;
                return false;
            &#125;
            t &#x3D; t-&gt;child[c - &#39;a&#39;];
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-063-替换单词"><a href="#剑指-Offer-II-063-替换单词" class="headerlink" title="剑指 Offer II 063. 替换单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/UhWRSj/">剑指 Offer II 063. 替换单词</a></h4><blockquote>
<p>在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>
<p>现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>
<p>你需要输出替换之后的句子。</p>
</blockquote>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230401004621930.png" alt="image-20230401004621930"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Trie &#123;
    unordered_map&lt;char, Trie *&gt; children;
&#125;;

class Solution &#123;
public:
    string replaceWords(vector&lt;string&gt;&amp; dictionary, string sentence) &#123;
        Trie *trie &#x3D; new Trie();
        for (auto &amp;word : dictionary) &#123;
            Trie *cur &#x3D; trie;
            for (char &amp;c: word) &#123;
                if (!cur-&gt;children.count(c)) &#123;
                    cur-&gt;children[c] &#x3D; new Trie();
                &#125;
                cur &#x3D; cur-&gt;children[c];
            &#125;
            cur-&gt;children[&#39;#&#39;] &#x3D; new Trie();
        &#125;
        vector&lt;string&gt; words &#x3D; split(sentence, &#39; &#39;);
        for (auto &amp;word : words) &#123;
            word &#x3D; findRoot(word, trie);
        &#125;
        string ans;
        for (int i &#x3D; 0; i &lt; words.size() - 1; i++) &#123;
            ans.append(words[i]);
            ans.append(&quot; &quot;);
        &#125;
        ans.append(words.back());
        return ans;
    &#125;

    vector&lt;string&gt; split(string &amp;str, char ch) &#123;
        int pos &#x3D; 0;
        int start &#x3D; 0;
        vector&lt;string&gt; ret;
        while (pos &lt; str.size()) &#123;
            while (pos &lt; str.size() &amp;&amp; str[pos] &#x3D;&#x3D; ch) &#123;
                pos++;
            &#125;
            start &#x3D; pos;
            while (pos &lt; str.size() &amp;&amp; str[pos] !&#x3D; ch) &#123;
                pos++;
            &#125;
            if (start &lt; str.size()) &#123;
                ret.emplace_back(str.substr(start, pos - start));
            &#125;
        &#125;
        return ret;
    &#125;

    string findRoot(string &amp;word, Trie *trie) &#123;
        string root;
        Trie *cur &#x3D; trie;
        for (char &amp;c : word) &#123;
            if (cur-&gt;children.count(&#39;#&#39;)) &#123;
                return root;
            &#125;
            if (!cur-&gt;children.count(c)) &#123;
                return word;
            &#125;
            root.push_back(c);
            cur &#x3D; cur-&gt;children[c];
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-064-神奇的字典"><a href="#剑指-Offer-II-064-神奇的字典" class="headerlink" title="剑指 Offer II 064. 神奇的字典"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/US1pGT/">剑指 Offer II 064. 神奇的字典</a></h4><p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p>
<p>实现 MagicDictionary 类：</p>
<ul>
<li>MagicDictionary() 初始化对象</li>
<li>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同</li>
<li>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Trie &#123;
    bool isEnd;
    vector&lt;Trie*&gt; children;
    Trie() : isEnd(false), children(26, NULL) &#123;&#125;
    ~Trie() &#123;
        for (Trie* child : children) &#123;
            if (child) delete child;
        &#125;
    &#125;

&#125;;
class MagicDictionary &#123;
    Trie* root;
    void addWord(string&amp; str) &#123;
        Trie* cur &#x3D; root;
        for (char&amp; c : str) &#123;
            if (cur-&gt;children[c - &#39;a&#39;] &#x3D;&#x3D; NULL) &#123;
                cur-&gt;children[c - &#39;a&#39;] &#x3D; new Trie();
            &#125;
            cur &#x3D; cur-&gt;children[c - &#39;a&#39;];
        &#125;
        cur-&gt;isEnd &#x3D; true;
    &#125;

    bool backtracking(Trie* cur, string&amp; word, int index, int cnt) &#123;
        if (index &#x3D;&#x3D; word.size()) &#123;
            if (cnt &#x3D;&#x3D; 1 &amp;&amp; cur-&gt;isEnd &#x3D;&#x3D; true) return true;
            else return false;
        &#125;
        for (int i &#x3D; 0; i &lt; 26; ++i) &#123;
            &#x2F;&#x2F; 不进入空节点
            if (cur-&gt;children[i] &#x3D;&#x3D; NULL) continue;
            if (&#39;a&#39; + i &#x3D;&#x3D; word[index]) &#123;
                if (backtracking(cur-&gt;children[i], word, index + 1, cnt)) return true;
            &#125; else if (cnt &#x3D;&#x3D; 0 &amp;&amp; &#39;a&#39; + i !&#x3D; word[index]) &#123;
                if (backtracking(cur-&gt;children[i], word, index + 1, cnt + 1)) return true;
            &#125;
        &#125;
        return false;
    &#125;
public:
    &#x2F;** Initialize your data structure here. *&#x2F;
    MagicDictionary() &#123;
        root &#x3D; new Trie();
    &#125;
    
    void buildDict(vector&lt;string&gt; dictionary) &#123;
        for (string&amp; str : dictionary) &#123;
            addWord(str);
        &#125;
    &#125;
    
    bool search(string searchWord) &#123;
        Trie* cur &#x3D; root;
        return backtracking(cur, searchWord, 0, 0);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-065-最短的单词编码"><a href="#剑指-Offer-II-065-最短的单词编码" class="headerlink" title="剑指 Offer II 065. 最短的单词编码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/iSwD2y/">剑指 Offer II 065. 最短的单词编码</a></h4><p>单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：</p>
<ul>
<li>words.length == indices.length</li>
<li>助记字符串 s 以 ‘#’ 字符结尾</li>
<li>对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 ‘#’ 字符结束（但不包括 ‘#’）的 子字符串 恰好与 words[i] 相等</li>
</ul>
<p>给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minimumLengthEncoding(vector&lt;string&gt;&amp; words) &#123;
        for(auto &amp;s : words)&#123;
            reverse(s.begin(),s.end());
        &#125;
        sort(words.begin(),words.end());
        int res&#x3D;0;
        for(int i&#x3D;0;i&lt;words.size()-1;i++)&#123;
            int size&#x3D;words[i].size();
            if(words[i]&#x3D;&#x3D;words[i+1].substr(0,size)) continue;
            res+&#x3D;size+1;
        &#125;
        return res+words.back().size()+1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-066-单词之和"><a href="#剑指-Offer-II-066-单词之和" class="headerlink" title="剑指 Offer II 066. 单词之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/z1R5dt/">剑指 Offer II 066. 单词之和</a></h4><p>实现一个 MapSum 类，支持两个方法，insert 和 sum：</p>
<p>MapSum() 初始化 MapSum 对象<br>void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。<br>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MapSum &#123;
public:
    map&lt;string,int&gt; mp;
    &#x2F;** Initialize your data structure here. *&#x2F;
    MapSum() &#123;
        
    &#125;
    
    void insert(string key, int val) &#123;
        mp[key] &#x3D; val;
    &#125;
    
    int sum(string prefix) &#123;
        int ans &#x3D; 0;
        string s;
        for(auto it&#x3D;mp.begin();it!&#x3D;mp.end();it++)
        &#123;
            s &#x3D; it-&gt;first;
            if(s.find(prefix)&#x3D;&#x3D;0)
            &#123;
                ans +&#x3D; (it-&gt;second);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-067-最大的异或"><a href="#剑指-Offer-II-067-最大的异或" class="headerlink" title="剑指 Offer II 067. 最大的异或"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或</a></h4><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    
    struct Trie&#123;
        struct TrieNode
        &#123;
            bool end;
            TrieNode* child[2];
        &#125;;
        TrieNode * root;
        Trie()&#123;
            root &#x3D; new TrieNode();
        &#125;
        void insert(int x)
        &#123;
            TrieNode *p &#x3D; root;
            for(int i &#x3D; 31; i &gt;&#x3D;0; --i)
            &#123;
                int bit &#x3D; (x &gt;&gt; i) &amp; 1;
                if(!p-&gt;child[bit])
                    p-&gt;child[bit] &#x3D; new TrieNode();
                p &#x3D; p-&gt;child[bit];
            &#125;
            p-&gt;end &#x3D; true;
        &#125;
        
        int search_max_XOR(int x)
        &#123;
            TrieNode *p &#x3D; root;
            int ans &#x3D; 0;
            for(int i &#x3D; 31; i &gt;&#x3D; 0; --i)
            &#123;
                int bit &#x3D; (x &gt;&gt; i) &amp; 1;
                if(p-&gt;child[bit^1])
                &#123;
                    p &#x3D; p-&gt;child[bit^1];
                    ans &#x3D; ans | (1 &lt;&lt; i);
                &#125;
                else
                    p &#x3D; p-&gt;child[bit];
            &#125;
            return ans;
        &#125;
    &#125;;
    
    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return 0;
        Trie t;
        t.insert(nums[0]);
        int ans &#x3D; INT_MIN;
        for(int i &#x3D; 1; i &lt; n; ++i)
        &#123;
            ans &#x3D; max(ans, t.search_max_XOR(nums[i]));
            t.insert(nums[i]);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-073-狒狒吃香蕉"><a href="#剑指-Offer-II-073-狒狒吃香蕉" class="headerlink" title="剑指 Offer II 073. 狒狒吃香蕉"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/nZZqjQ/">剑指 Offer II 073. 狒狒吃香蕉</a></h4><p>狒狒喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p>
<p>狒狒可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。  </p>
<p>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p>
<blockquote>
<p>很独特的二分</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) &#123;
        int maxn &#x3D; 0;
        for(int x : piles)&#123;
            maxn &#x3D; max(maxn, x);
        &#125;
        int l &#x3D; 1;
        int r &#x3D; maxn;
        while(l &lt;&#x3D; r)&#123;
            int hx &#x3D; 0;
            int k &#x3D; l + ((r - l) &gt;&gt; 1);
            for(auto x : piles) &#123;
                hx +&#x3D; (x - 1) &#x2F; k + 1;
            &#125;
            if(hx &gt; h) l &#x3D; k + 1;
            else r &#x3D; k - 1;
        &#125;
        return l;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-078-合并排序链表"><a href="#剑指-Offer-II-078-合并排序链表" class="headerlink" title="剑指 Offer II 078. 合并排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vvXgSW/">剑指 Offer II 078. 合并排序链表</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230405192516405.png" alt="image-20230405192516405"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 优先队列
class Solution &#123;
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;
        auto compare &#x3D; [](ListNode* x, ListNode* y) -&gt; bool &#123; return x-&gt;val &gt; y-&gt;val; &#125;;
        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(compare)&gt; q (compare);
        for (auto node : lists)
            if (node) q.push(node);

        function&lt;ListNode*()&gt; merge &#x3D; [&amp;]() -&gt; ListNode* &#123;
            if (q.empty()) return nullptr;
            auto node &#x3D; q.top(); q.pop();
            if (node-&gt;next)
                q.push(node-&gt;next);
            node-&gt;next &#x3D; merge();
            return node;
        &#125;;

        return merge();
    &#125;
&#125;;

&#x2F;&#x2F; 分治
class Solution &#123;
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) &#123;
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, *tail &#x3D; &amp;head, *aPtr &#x3D; a, *bPtr &#x3D; b;
        while (aPtr &amp;&amp; bPtr) &#123;
            if (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;
                tail-&gt;next &#x3D; aPtr; aPtr &#x3D; aPtr-&gt;next;
            &#125; else &#123;
                tail-&gt;next &#x3D; bPtr; bPtr &#x3D; bPtr-&gt;next;
            &#125;
            tail &#x3D; tail-&gt;next;
        &#125;
        tail-&gt;next &#x3D; (aPtr ? aPtr : bPtr);
        return head.next;
    &#125;

    ListNode* merge(vector &lt;ListNode*&gt; &amp;lists, int l, int r) &#123;
        if (l &#x3D;&#x3D; r) return lists[l];
        if (l &gt; r) return nullptr;
        int mid &#x3D; (l + r) &gt;&gt; 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    &#125;

    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;
        return merge(lists, 0, lists.size() - 1);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-093-最长斐波那契数列"><a href="#剑指-Offer-II-093-最长斐波那契数列" class="headerlink" title="剑指 Offer II 093. 最长斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/Q91FMA/">剑指 Offer II 093. 最长斐波那契数列</a></h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int lenLongestFibSubseq(vector&lt;int&gt;&amp; arr) &#123;
        int maxn &#x3D; 0;
        int n &#x3D; arr.size();
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n,0));
        for(int k &#x3D; 2 ; k &lt; n ; k++) &#123;
            int i &#x3D; 0, j &#x3D; k - 1;
            while(i &lt; j) &#123;
                int sum &#x3D; arr[i] + arr[j];
                if(sum &#x3D;&#x3D; arr[k]) &#123;
                    dp[j][k] &#x3D; dp[i][j] + 1;
                    maxn &#x3D; max(maxn, dp[j][k]);
                    i++;
                    j--;
                &#125;
                if(sum &lt; arr[k]) i++;
                if(sum &gt; arr[k]) j--;
            &#125;
        &#125;
        return maxn &#x3D;&#x3D; 0 ? 0 : maxn + 2;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-094-最少回文分割"><a href="#剑指-Offer-II-094-最少回文分割" class="headerlink" title="剑指 Offer II 094. 最少回文分割"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/omKAoA/">剑指 Offer II 094. 最少回文分割</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230411032451815.png" alt="image-20230411032451815"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int minCut(string s) &#123;
        vector&lt;vector&lt;bool&gt;&gt;vv(s.size(),vector&lt;bool&gt;(s.size(),false));
        for(int i&#x3D;s.size()-1;i&gt;&#x3D;0;i--)&#123;
            for(int j&#x3D;i;j&lt;s.size();j++)&#123;
                if(s[i]&#x3D;&#x3D;s[j]&amp;&amp;(j-i&lt;&#x3D;1||vv[i+1][j-1]))&#123;
                    vv[i][j]&#x3D;true;
                &#125;
            &#125;
        &#125;
        vector&lt;int&gt;dp(s.size(),0);&#x2F;&#x2F;dp[i]表示个字符，分割的最少次数；
        &#x2F;&#x2F;dp[i]&#x3D;
        for(int i&#x3D;0;i&lt;s.size();i++) dp[i]&#x3D;i;
        for(int i&#x3D;1;i&lt;s.size();i++)&#123;
           if( vv[0][i])&#123;
               dp[i]&#x3D;0;
               continue;
           &#125;
           for(int j&#x3D;0;j&lt;i;j++)&#123;
               if(vv[j+1][i])&#123;
                   dp[i]&#x3D;min(dp[i],dp[j]+1);
               &#125;
           &#125;
        &#125;
          return dp[s.size()-1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-096-字符串交织"><a href="#剑指-Offer-II-096-字符串交织" class="headerlink" title="剑指 Offer II 096. 字符串交织"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/IY6buf/">剑指 Offer II 096. 字符串交织</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230411032539528.png" alt="image-20230411032539528"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isInterleave(string s1, string s2, string s3) &#123;
        int size1 &#x3D; s1.size();
        int size2 &#x3D; s2.size();
        int size3 &#x3D; s3.size();
        if(size3 !&#x3D; size1 + size2)  return false;
        &#x2F;&#x2F;dp[i][j]表示s1的前i位和s2的前j位是否能连接成s3的前i + j位
        vector&lt;vector&lt;bool&gt;&gt; dp(size1 + 1, vector&lt;bool&gt; (size2 + 1, false));
        dp[0][0] &#x3D; true;
        for(int i &#x3D; 1; i &lt;&#x3D; size1; ++i)&#123;
            if(s1[i - 1] !&#x3D; s3[i - 1])  break;
            dp[i][0] &#x3D; true;
        &#125;
        for(int j &#x3D; 1; j &lt;&#x3D; size2; ++j)&#123;
            if(s2[j - 1] !&#x3D; s3[j - 1])  break;
            dp[0][j] &#x3D; true;
        &#125;
        for(int i &#x3D; 1; i &lt;&#x3D; size1; ++i)&#123;
            for(int j &#x3D; 1; j &lt;&#x3D; size2; ++j)&#123;
                if(s1[i - 1] &#x3D;&#x3D; s3[i + j - 1])
                    dp[i][j] &#x3D; dp[i - 1][j];
                if(s2[j - 1] &#x3D;&#x3D; s3[i + j - 1])
                    dp[i][j] &#x3D; dp[i][j - 1] || dp[i][j];
            &#125;
        &#125;
        return dp[size1][size2];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-097-子序列的数目"><a href="#剑指-Offer-II-097-子序列的数目" class="headerlink" title="剑指 Offer II 097. 子序列的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/21dk04/">剑指 Offer II 097. 子序列的数目</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230412162716735.png" alt="image-20230412162716735"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int numDistinct(string s, string t) &#123;
        vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size() + 1, vector&lt;uint64_t&gt;(t.size() + 1));
        for (int i &#x3D; 0; i &lt; s.size(); i++) dp[i][0] &#x3D; 1;
        for (int j &#x3D; 1; j &lt; t.size(); j++) dp[0][j] &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; s.size(); i++) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; t.size(); j++) &#123;
                if (s[i - 1] &#x3D;&#x3D; t[j - 1]) &#123;
                    dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];
                &#125; else &#123;
                    dp[i][j] &#x3D; dp[i - 1][j];
                &#125;
            &#125;
        &#125;
        return dp[s.size()][t.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-106-二分图"><a href="#剑指-Offer-II-106-二分图" class="headerlink" title="剑指 Offer II 106. 二分图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vEAB3K/">剑指 Offer II 106. 二分图</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230416000349478.png" alt="image-20230416000349478"></p>
<p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230416000359444.png" alt="image-20230416000359444"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;
        vector&lt;int&gt; visited(graph.size());
        for(int i &#x3D; 0 ; i &lt; graph.size() ; i++) &#123;
            if(visited[i] &#x3D;&#x3D; 0 &amp;&amp; !dfs(graph, i, 1, visited)) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;

private: 
    bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int v, int color, vector&lt;int&gt;&amp; visited) &#123;
        if(visited[v] !&#x3D; 0) &#123;
            return visited[v] &#x3D;&#x3D; color;
        &#125;
        visited[v] &#x3D; color;
        for(int w : graph[v]) &#123;
            if(!dfs(graph, w, -color, visited)) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-107-矩阵中的距离"><a href="#剑指-Offer-II-107-矩阵中的距离" class="headerlink" title="剑指 Offer II 107. 矩阵中的距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230416002804533.png" alt="image-20230416002804533"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;
        queue&lt;pair&lt;int,int&gt;&gt; q;
        int m &#x3D; mat.size();
        int n &#x3D; mat[0].size();
        for(int i &#x3D; 0 ; i &lt; m ; i++) &#123;
            for(int j &#x3D; 0 ; j &lt; n ; j++) &#123;
                if(mat[i][j] &#x3D;&#x3D; 0) &#123;
                    q.push(&#123;i, j&#125;);
                &#125; else &#123;
                    mat[i][j] &#x3D; -1;
                &#125;
            &#125;
        &#125;
        vector&lt;int&gt; dx&#123;-1, 1, 0, 0&#125;;
        vector&lt;int&gt; dy&#123;0, 0 , -1, 1&#125;;
        while(!q.empty()) &#123;
            pair&lt;int,int&gt; point &#x3D; q.front();
            q.pop();
            int x &#x3D; point.first;
            int y &#x3D; point.second;
            for(int i &#x3D; 0 ; i &lt; 4 ; i++) &#123;
                int newX &#x3D; x + dx[i];
                int newY &#x3D; y + dy[i];
                if (newX &gt;&#x3D; 0 &amp;&amp; newX &lt; m &amp;&amp; newY &gt;&#x3D; 0 &amp;&amp; newY &lt; n 
                        &amp;&amp; mat[newX][newY] &#x3D;&#x3D; -1) &#123;
                    mat[newX][newY] &#x3D; mat[x][y] + 1;
                    q.push(&#123;newX, newY&#125;);
                &#125;
            &#125;
        &#125;
        return mat;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-108-单词演变"><a href="#剑指-Offer-II-108-单词演变" class="headerlink" title="剑指 Offer II 108. 单词演变"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/om3reC/">剑指 Offer II 108. 单词演变</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230416045333630.png" alt="image-20230416045333630"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 双向bfs
class Solution &#123;
public:
    struct Node &#123;
        string str;
        int val;
        Node(string _str, int _val) : str(_str), val(_val) &#123;&#125;
    &#125;;

    string s, e;
    const int INF &#x3D; 0x3f3f3f3f;
    unordered_set&lt;string&gt; set;
    int ladderLength(string _s, string _e, vector&lt;string&gt;&amp; ws) &#123;
        s &#x3D; _s;
        e &#x3D; _e;
        for (const auto&amp; w : ws) set.insert(w);
        if (set.find(e) &#x3D;&#x3D; set.end()) return 0;
        int ans &#x3D; astar();
        return ans &#x3D;&#x3D; -1 ? 0 : ans + 1;
    &#125;

    int astar() &#123;
        auto cmp &#x3D; [](const Node&amp; a, const Node&amp; b) &#123; return a.val &gt; b.val; &#125;;
        priority_queue&lt;Node, vector&lt;Node&gt;, decltype(cmp)&gt; q(cmp);
        unordered_map&lt;string, int&gt; dist;
        dist[s] &#x3D; 0;
        q.emplace(s, f(s));

        while (!q.empty()) &#123;
            Node poll &#x3D; q.top();
            q.pop();
            string str &#x3D; poll.str;
            int distance &#x3D; dist[str];
            if (str &#x3D;&#x3D; e) &#123;
                break;
            &#125;
            int n &#x3D; str.length();
            for (int i &#x3D; 0; i &lt; n; i++) &#123;
                for (int j &#x3D; 0; j &lt; 26; j++) &#123;
                    string sub &#x3D; str;
                    sub[i] &#x3D; &#39;a&#39; + j;
                    if (set.find(sub) &#x3D;&#x3D; set.end()) continue;
                    if (dist.find(sub) &#x3D;&#x3D; dist.end() || dist[sub] &gt; distance + 1) &#123;
                        dist[sub] &#x3D; distance + 1;
                        q.emplace(sub, dist[sub] + f(sub));
                    &#125;
                &#125;
            &#125;
        &#125;
        return dist.find(e) !&#x3D; dist.end() ? dist[e] : -1;
    &#125;

    int f(string str) &#123;
        if (str.length() !&#x3D; e.length()) return INF;
        int n &#x3D; str.length();
        int ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            ans +&#x3D; str[i] &#x3D;&#x3D; e[i] ? 0 : 1;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-109-开密码锁"><a href="#剑指-Offer-II-109-开密码锁" class="headerlink" title="剑指 Offer II 109. 开密码锁"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zlDJc7/">剑指 Offer II 109. 开密码锁</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230416054337377.png" alt="image-20230416054337377"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;双向bfs
class Solution &#123;
public:
    string s,t; 
    unordered_set&lt;string&gt; st;
    int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123;
        s &#x3D; &quot;0000&quot;;
        t &#x3D; target;
        if(s &#x3D;&#x3D; t) return 0;
        for(const auto&amp; d : deadends) st.insert(d);
        if(st.count(s)) return -1;
        int ans &#x3D; bfs();
        return ans;
    &#125;
    int bfs()&#123;
        queue&lt;string&gt; d1,d2;
        unordered_map&lt;string,int&gt; m1,m2;
        d1.push(s); m1[s] &#x3D; 0;
        d2.push(t); m2[t] &#x3D; 0;
        while(d1.size() and d2.size())&#123;
            int t &#x3D; -1;
            if(d1.size() &lt;&#x3D; d2.size())&#123;
                t &#x3D; update(d1,m1,m2);
            &#125;
            else&#123;
                t &#x3D; update(d2,m2,m1);
            &#125;
            if(t !&#x3D; -1) return t;
        &#125;
        return -1;
    &#125;
    int update(queue&lt;string&gt;&amp; q,unordered_map&lt;string,int&gt;&amp; cur,unordered_map&lt;string,int&gt;&amp; other)&#123;
        int m &#x3D; q.size();
        while (m-- &gt; 0) &#123;
            string t &#x3D; q.front(); q.pop();
            int step &#x3D; cur[t];
            for(int i &#x3D; 0; i &lt; 4; i++)&#123;
                for(int j &#x3D; -1; j &lt;&#x3D; 1; j++)&#123;
                    if(j &#x3D;&#x3D; 0) continue;
                    int origin &#x3D; t[i] - &#39;0&#39;;
                    int next &#x3D; (origin + j) % 10;
                    if(next &#x3D;&#x3D; -1) next &#x3D; 9;
                    string copy &#x3D; t;
                    copy[i] &#x3D; &#39;0&#39; + next;
                    if(st.count(copy) or cur.count(copy)) continue;
                    if(other.count(copy)) return step + 1 + other[copy];
                    else&#123;
                        q.push(copy);
                        cur[copy] &#x3D; step + 1;
                    &#125;
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-110-所有路径"><a href="#剑指-Offer-II-110-所有路径" class="headerlink" title="剑指 Offer II 110. 所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bP4bmD/">剑指 Offer II 110. 所有路径</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230416055008614.png" alt="image-20230416055008614"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    vector&lt;int&gt; path;
    int n;

    vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;
        n &#x3D; graph.size();
        path.push_back(0);
        dfs(graph,0);
        return ans;
    &#125;

    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph,int i)&#123;
        if(i &#x3D;&#x3D; n - 1)&#123;
            ans.push_back(path);
            return;
        &#125;
        if(graph[i].size() &#x3D;&#x3D; 0)&#123;
            return;
        &#125;
        for(int &amp; j : graph[i])&#123;
            path.push_back(j);
            dfs(graph,j);
            path.pop_back();
        &#125;
        return;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-111-计算除法"><a href="#剑指-Offer-II-111-计算除法" class="headerlink" title="剑指 Offer II 111. 计算除法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vlzXQL/">剑指 Offer II 111. 计算除法</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230417132753980.png" alt="image-20230417132753980"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123;
        unordered_map&lt;string, double&gt; umap;
        unordered_map&lt;string, int&gt; uset;
        vector&lt;bool&gt; used(equations.size(), false);
        int setIndex &#x3D; 0;
        for (int i &#x3D; 0; i &lt; equations.size(); i++)
        &#123;
            if (!used[i])
            &#123;
                used[i] &#x3D; true;
                &#x2F;&#x2F;a确定
                if (umap.count(equations[i][0]))
                &#123;
                    uset[equations[i][1]] &#x3D; setIndex;
                    umap[equations[i][1]] &#x3D; umap[equations[i][0]] &#x2F; values[i];
                &#125;
                &#x2F;&#x2F;b确定
                else if (umap.count(equations[i][1]))
                &#123;
                    uset[equations[i][0]] &#x3D; setIndex;
                    umap[equations[i][0]] &#x3D; umap[equations[i][1]] * values[i];
                &#125;
                else
                &#123;
                    &#x2F;&#x2F;新的集合
                    setIndex++;
                    uset[equations[i][0]] &#x3D; setIndex;
                    uset[equations[i][1]] &#x3D; setIndex;
                    umap[equations[i][0]] &#x3D; values[i];
                    umap[equations[i][1]] &#x3D; 1.0;
                &#125;
            &#125;
            for (int j &#x3D; i + 1; j &lt; equations.size(); j++)
            &#123;
                if (used[j])
                    continue;
                if (!umap.count(equations[j][0]) &amp;&amp; !umap.count(equations[j][1]))
                    continue;

                used[j] &#x3D; true;
                &#x2F;&#x2F;a确定
                if (umap.count(equations[j][0]))
                &#123;
                    uset[equations[j][1]] &#x3D; setIndex;
                    umap[equations[j][1]] &#x3D; umap[equations[j][0]] &#x2F; values[j];
                &#125;
                &#x2F;&#x2F;b确定
                else if (umap.count(equations[j][1]))
                &#123;
                    uset[equations[j][0]] &#x3D; setIndex;
                    umap[equations[j][0]] &#x3D; umap[equations[j][1]] * values[j];
                &#125;
            &#125;
        &#125;
        vector&lt;double&gt; result;
        for (auto &amp;c : queries)
        &#123;
            &#x2F;&#x2F;能查找到两个数，并且都在一个集合里才有意义
            if (umap.count(c[0]) &amp;&amp; umap.count(c[1]) &amp;&amp; uset[c[0]] &#x3D;&#x3D; uset[c[1]])
                result.push_back(umap[c[0]] &#x2F; umap[c[1]]);
            else
                result.push_back(-1);
        &#125;
        return result;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-112-最长递增路径"><a href="#剑指-Offer-II-112-最长递增路径" class="headerlink" title="剑指 Offer II 112. 最长递增路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fpTFWP/">剑指 Offer II 112. 最长递增路径</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230417132900104.png" alt="image-20230417132900104"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
    int ans, n, m;
    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;
    int dp[222][222];
public:
    int dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp; g) &#123;
        if(dp[x][y]) return dp[x][y];
        dp[x][y] &#x3D; 1;
        for(int i &#x3D; 0; i &lt; 4; i++) &#123;
            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];
            if(a &lt; n &amp;&amp; a &gt;&#x3D; 0 &amp;&amp; b &lt; m &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; g[a][b] &gt; g[x][y]) &#123;
                dp[x][y] &#x3D; max(dp[x][y], dfs(a, b, g) + 1);
            &#125;
        &#125;
        return dp[x][y];
    &#125;
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; g) &#123;
        n &#x3D; g.size(), m &#x3D; g[0].size();
        for(int i &#x3D; 0; i &lt; n; i++) &#123;
            for(int j &#x3D; 0; j &lt; m; j++) &#123;
                ans &#x3D; max(ans, dfs(i, j, g));
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-113-课程顺序"><a href="#剑指-Offer-II-113-课程顺序" class="headerlink" title="剑指 Offer II 113. 课程顺序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/QA2IGt/">剑指 Offer II 113. 课程顺序</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230417132932793.png" alt="image-20230417132932793"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;
        vector&lt;int&gt;ans;
        vector&lt;vector&lt;int&gt;&gt;edges(numCourses,vector&lt;int&gt;());
        vector&lt;int&gt;in_degree(numCourses,0);

        for(const auto&amp;e:prerequisites)&#123;
            ++in_degree[e[0]];
            edges[e[1]].push_back(e[0]);
        &#125;

        queue&lt;int&gt;my_queue;
        for(int i&#x3D;0;i&lt;in_degree.size();i++)&#123;
            if(in_degree[i]&#x3D;&#x3D;0)&#123;
                my_queue.push(i);
            &#125;

        &#125;
        
        while(!my_queue.empty())&#123;
            auto cour_id&#x3D;my_queue.front();
            my_queue.pop();
            ans.push_back(cour_id);

            for(const auto &amp;c:edges[cour_id])&#123;
               if(in_degree[c]&#x3D;&#x3D;1)&#123;
                   my_queue.push(c);
               &#125;
               --in_degree[c];
            &#125;
        &#125;
        
        if(ans.size()!&#x3D;numCourses)&#123;
            return vector&lt;int&gt;();
        &#125;else&#123;
            return ans;
        &#125;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-114-外星文字典"><a href="#剑指-Offer-II-114-外星文字典" class="headerlink" title="剑指 Offer II 114. 外星文字典"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230418135157799.png" alt="image-20230418135157799"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const int N &#x3D; 26, M &#x3D; N * N;
class Solution &#123;
public:
    int h[N], e[M], ne[M], idx &#x3D; 0;
    bool st[N];
    int in[N], cnt &#x3D; 0; &#x2F;&#x2F; 上面三行要写在class Solution内部，不然每次调用不会清空
    void add(int a, int b)
    &#123;
        e[idx] &#x3D; b, ne[idx]&#x3D; h[a], h[a] &#x3D; idx ++ ;
    &#125;

    bool build(string s, string t)
    &#123;
        int n &#x3D; min(s.size(), t.size());
        for (int i &#x3D; 0; i &lt; n; i ++ )
        &#123;
            int a &#x3D; s[i] - &#39;a&#39;, b &#x3D; t[i] - &#39;a&#39;;
            if (a !&#x3D; b) 
            &#123;
                add(a, b);
                in[b] ++ ;
                return true;
            &#125;
        &#125;
        return s.size() &lt;&#x3D; t.size(); &#x2F;&#x2F; 必须要等号，因为字典里有两个一样的串也算构建成功
    &#125;

    string alienOrder(vector&lt;string&gt;&amp; words) &#123;
        memset(h, -1, sizeof h);    
        int n &#x3D; words.size();
        string res &#x3D; &quot;&quot;;
        for (int i &#x3D; 0; i &lt; n; i ++ )
        &#123;
            for (auto c: words[i])
            &#123;
                if (!st[c - &#39;a&#39;])
                &#123;
                    cnt ++ ;
                    st[c - &#39;a&#39;] &#x3D; true;
                &#125;
            &#125;
            for (int j &#x3D; 0; j &lt; i; j ++ )
            &#123;
                if (!build(words[j], words[i])) 
                    return &quot;&quot;;
            &#125;
        &#125;
        queue&lt;int&gt; q;
        for (int i &#x3D; 0; i &lt; 26; i ++ )
        &#123;
            if (!in[i] &amp;&amp; st[i])
                q.push(i);
        &#125;
        while (q.size())
        &#123;
            int t &#x3D; q.front();
            q.pop();
            res +&#x3D; (char)(t + &#39;a&#39;);
            for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])
            &#123;
                int j &#x3D; e[i];
                if (-- in[j] &#x3D;&#x3D; 0)
                    q.push(j);
            &#125;
        &#125;
        return cnt &#x3D;&#x3D; res.size() ? res : &quot;&quot;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-115-重建序列"><a href="#剑指-Offer-II-115-重建序列" class="headerlink" title="剑指 Offer II 115. 重建序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230418135239292.png" alt="image-20230418135239292"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    bool sequenceReconstruction(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; sequences) &#123;
        unordered_map&lt;int, unordered_set&lt;int&gt;&gt; d;
        for(auto x : sequences)&#123;
            for(int i &#x3D; 1; i &lt; x.size(); i++)&#123;
                d[x[i-1]].insert(x[i]);
            &#125;
        &#125;
        for(int i &#x3D; 1; i &lt; nums.size(); i++)&#123;
            if(d[nums[i-1]].count(nums[i]) &#x3D;&#x3D; 0) return false;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-116-省份数量"><a href="#剑指-Offer-II-116-省份数量" class="headerlink" title="剑指 Offer II 116. 省份数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bLyHh0/">剑指 Offer II 116. 省份数量</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230418135303668.png" alt="image-20230418135303668"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;
        vector&lt;int&gt; visited(isConnected.size(),0);

        function&lt;void(int)&gt; visit_city &#x3D; [&amp;](int city)
        &#123;
            if(visited[city]&#x3D;&#x3D;1)
                return;
            visited[city] &#x3D; 1;
            auto &amp; next_citys &#x3D; isConnected[city];
            for(int next_city &#x3D; 0;next_city&lt;next_citys.size();next_city++)
            &#123;
                if(next_citys[next_city]&#x3D;&#x3D;1)
                &#123;
                    visit_city(next_city);
                &#125;
            &#125;
        &#125;;

        int ret &#x3D; 0;
        for(int city &#x3D; 0;city&lt;isConnected.size();city++)
        &#123;
            if(visited[city]&#x3D;&#x3D;0)
            &#123;
                ret++;
                visit_city(city);
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-117-相似的字符串"><a href="#剑指-Offer-II-117-相似的字符串" class="headerlink" title="剑指 Offer II 117. 相似的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/H6lPxb/">剑指 Offer II 117. 相似的字符串</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230419123250341.png" alt="image-20230419123250341"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class DSU&#123;
public:
    vector&lt;int&gt; f;
    DSU(int n)&#123;
        f.resize(n);
        for(int i &#x3D; 0; i &lt; n; i++)&#123;
            f[i] &#x3D; i;
        &#125;
    &#125;
    int Find(int x)&#123;
        if(x &#x3D;&#x3D; f[x]) return x;
        else return f[x] &#x3D; Find(f[x]);
    &#125;
    void Union(int x,int y)&#123;
        int _x &#x3D; Find(x);
        int _y &#x3D; Find(y);
        if(_x !&#x3D; _y)&#123;
            f[_y] &#x3D; _x;
        &#125;
    &#125;

    int get()&#123;
        int res &#x3D; 0;
        for(int i &#x3D; 0;i &lt; f.size();i++)&#123;
            res +&#x3D; (f[i] &#x3D;&#x3D; i);
        &#125;
        return res;
    &#125;
&#125;;


class Solution &#123;
public:
    int numSimilarGroups(vector&lt;string&gt;&amp; strs) &#123;
        int n &#x3D; strs.size();
        DSU dsu(n);
        for(int i &#x3D; 0;i &lt; n; i++)&#123;
            for(int j &#x3D; i + 1; j &lt; n; j++)&#123;
                if(isSimilar(strs[i],strs[j]))&#123;
                    dsu.Union(i,j);
                &#125;
            &#125;
        &#125;
        return dsu.get();
    &#125;
private:
    bool isSimilar(const string&amp; A,const string&amp; B)&#123;
        int cnt &#x3D; 0;
        for(int i &#x3D; 0; i &lt; A.size(); i++)&#123;
            cnt +&#x3D; (A[i] !&#x3D; B[i]);
        &#125;
        return cnt &lt;&#x3D; 2;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-118-多余的边"><a href="#剑指-Offer-II-118-多余的边" class="headerlink" title="剑指 Offer II 118. 多余的边"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230419123326087.png" alt="image-20230419123326087">‘</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Solution &#123;
public:
    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;
        vector&lt;int&gt; rp(1001);
        int sz &#x3D; edges.size();
        &#x2F;&#x2F; 初始化各元素为单独的集合，代表节点就是其本身
        for(int i&#x3D;0;i&lt;sz;i++)
            rp[i] &#x3D; i;
        for(int j&#x3D;0;j&lt;sz;j++)&#123;
            &#x2F;&#x2F; 找到边上两个节点所在集合的代表节点
            int set1 &#x3D; find(edges[j][0], rp);
            int set2 &#x3D; find(edges[j][1], rp);
            if(set1 &#x3D;&#x3D; set2)  &#x2F;&#x2F; 两个集合代表节点相同，说明出现环，返回答案
                return edges[j]; 
            else    &#x2F;&#x2F; 两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上
                rp[set1] &#x3D; set2;
        &#125;
        return &#123;0, 0&#125;;
    &#125;

    &#x2F;&#x2F; 查找路径并返回代表节点，实际上就是给定当前节点，返回该节点所在集合的代表节点
    &#x2F;&#x2F; 之前这里写的压缩路径，引起歧义，因为结果没更新到vector里，所以这里改成路径查找比较合适
    &#x2F;&#x2F; 感谢各位老哥的提议
    int find(int n, vector&lt;int&gt; &amp;rp)&#123;
        int num &#x3D; n;
        while(rp[num] !&#x3D; num)
            num &#x3D; rp[num];
        return num;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="剑指-Offer-II-119-最长连续序列"><a href="#剑指-Offer-II-119-最长连续序列" class="headerlink" title="剑指 Offer II 119. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/WhsWhI/">剑指 Offer II 119. 最长连续序列</a></h4><p><img src="C:\Users\谢伟杰\AppData\Roaming\Typora\typora-user-images\image-20230419123810213.png" alt="image-20230419123810213"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class UF &#123;
private:
    vector&lt;int&gt; parent;
    vector&lt;int&gt; size;
public:
    UF(int n) &#123;
        parent.resize(n);
        size.resize(n);
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            parent[i] &#x3D; i;
            size[i] &#x3D; 1;
        &#125;
    &#125;

    int find(int x) &#123;
        if (parent[x] !&#x3D; x) &#123;
            parent[x] &#x3D; find(parent[x]);
        &#125;
        return parent[x];
    &#125;

    void union_(int p, int q) &#123;
        int rootP &#x3D; find(p);
        int rootQ &#x3D; find(q);
        if (rootP &#x3D;&#x3D; rootQ) &#123;
            return;
        &#125;
        parent[rootP] &#x3D; rootQ;
        size[rootQ] +&#x3D; size[rootP];
    &#125;

    int getMaxConnectSize() &#123;
        int maxSize &#x3D; 0;
        for (int i &#x3D; 0; i &lt; parent.size(); i++) &#123;
            if (i &#x3D;&#x3D; parent[i]) &#123;
                maxSize &#x3D; max(maxSize, size[i]);
            &#125;
        &#125;
        return maxSize;
    &#125;
&#125;;

class Solution &#123;
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;
        unordered_map&lt;int, int&gt; map;
        UF uf(nums.size());

        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            if (map.count(nums[i])) &#123;
                continue;
            &#125;
            if (map.count(nums[i] - 1)) &#123;
                uf.union_(i, map[nums[i] - 1]);
            &#125;
            if (map.count(nums[i] + 1)) &#123;
                uf.union_(i, map[nums[i] + 1]);
            &#125;
            map[nums[i]] &#x3D; i;
        &#125;
        return uf.getMaxConnectSize();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Smile Slight</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://smileslight.github.io/2022/10/31/Offer/">https://smileslight.github.io/2022/10/31/Offer/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Smile Slight</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C/">
                                    <span class="chip bg-color">C++</span>
                                </a>
                            
                                <a href="/tags/%E5%89%91%E6%8C%87/">
                                    <span class="chip bg-color">剑指</span>
                                </a>
                            
                                <a href="/tags/%E5%88%B7%E9%A2%98/">
                                    <span class="chip bg-color">刷题</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/10/31/LC75/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="LC75">
                        
                        <span class="card-title">LC75</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            LC75
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-10-31
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Smile Slight
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                    <a href="/tags/%E5%88%B7%E9%A2%98/">
                        <span class="chip bg-color">刷题</span>
                    </a>
                    
                    <a href="/tags/LeetCode75/">
                        <span class="chip bg-color">LeetCode75</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/07/31/100hot-1/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="100hot">
                        
                        <span class="card-title">100hot</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-07-31
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Smile Slight
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                    <a href="/tags/%E5%88%B7%E9%A2%98/">
                        <span class="chip bg-color">刷题</span>
                    </a>
                    
                    <a href="/tags/100hot/">
                        <span class="chip bg-color">100hot</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="632021463"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">Smile Slight</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/SmileSlight" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1585118039@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1585118039" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1585118039" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
